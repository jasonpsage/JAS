/**
 * @fileoverview
 * Provides low-level core functionality.  Requires nothing.
 * <p>
 * Provides core APIs for creating object-oriented and event-driven JavaScript code.  Features include:
 * <ul>
 *  <li>Provides API for declaring JavaScript classes which includes support for
 *   specifying abstract and virtual properties and validating subtypes to such
 *   specification.</li>
 *  <li>Provides a "Method Wrapper" function (Core.method()) to create a function which will invoke 
 *    a member function of a specific object instance (enabling invocation with the "this pointer" set
 *    appropriately).</li>
 *  <li>Provides event/listener management framework.  Event-listeners which invoke
 *    methods of an object instance may be created using the Core.method() function.</li>
 *  <li>Provides a "Large Map" useful for managing an associative array that is frequently modified
 *    and will exist for a long period of time.  This object is unfortunately necessary due to
 *    issues present in certain clients (Internet Explorer 6 memory leak / performance degradation).</li>
 *  <li>Provides array manipulation utilities.<li>
 *  <li>Provides some simple debugging utilities, e.g., a pseudo-console output.</li>
 *  <li>Does not provide any web-specific functionality.</li>
 * </ul>
 */

/**
 * Namespace for core functionality.
 * @namespace
 */
Core = {

    /**
     * Creates a duplicate copy of a function by wrapping the original in a closure.
     *
     * @param f the function
     * @return an effectively identical copy
     */
    _copyFunction: function(f) {
        return function() {
            f.apply(this, arguments);
        };
    },
    
    /**
     * Creates an empty function.
     */
    _createFunction: function() {
        return function() { };
    },
    
    /**
     * Creates a new class, optionally extending an existing class.
     * This method may be called with one or two parameters as follows:
     * <p>
     * <code>Core.extend(definition)</code>
     * <code>Core.extend(baseClass, definition)</code>
     * <p>
     * Each property of the definition object will be added to the prototype of the returned defined class.
     * Properties that begin with a dollar-sign (<code>$</code>) will be processed specially:
     * <p>
     * <ul>
     * <li>The <code>$construct</code> property, which must be a function, will be used as the constructor.
     * The <code>$load</code> property, which must be a function, f provided, will be used as a static initializer,
     * executed once when the class is *defined*.  The this pointer will be set to the class when
     * this method is executed.</li>
     * <li>The <code>$static</code> property, an object, if provided, will have its properties installed as class variables.</li>
     * <li>The <code>$abstract</code> property, an object or <code>true</code>, if provided, will define methods that
     * must be implemented by derivative classes.  If the value is simply <code>true</code>, the object will be marked as
     * abstract (such that it does not necessarily need to provide implementations of abstract methods defined in its 
     * base class.)</li>
     * <li>The <code>$virtual</code> property, an object, if provided, defines methods that will be placed into the prototype
     * that may be overridden by subclasses.  Attempting to override a property/method of the superclass that
     * is not defined in the virtual block will result in an exception.  Having the default behavior NOT allow
     * for overriding ensures that namespacing between super- and sub-types if all internal variables are instance
     * during <code>Core.extend()</code>.</li>
     * </ul>
     * <p>
     * Use of this method enables a class to be derived WITHOUT executing the constructor of the base class
     * in order to create a prototype for the derived class.  This method uses a "shared prototype" architecture,
     * where two objects are created, a "prototype class" and a "constructor class".  These two objects share
     * the same prototype, but the "prototype class" has an empty constructor.  When a class created with
     * this method is derived, the "prototype class" is used to create a prototype for the derivative.
     * <p>
     * This method will return the constructor class, which contains an internal reference to the 
     * prototype class that will be used if the returned class is later derived by this method.
     * 
     * @param {Function} baseClass the base class
     * @param {Object} definition an associative array containing methods and properties of the class
     * @return the constructor class
     */
    extend: function() {
        // Configure baseClass/definition arguments.
        var baseClass = arguments.length == 1 ? null : arguments[0];
        var definition = arguments.length == 1 ? arguments[0] : arguments[1];
        
        var x, name;
        
        // Perform argument error checking.
        if (arguments.length == 2) {
            if (typeof(baseClass) != "function") {
                throw new Error("Base class is not a function, cannot derive.");
            }
        }
        if (!definition) {
            throw new Error("Object definition not provided.");
        }
        
        // Create the constructor class.
        var constructorClass;
        if (definition.$construct) {
            // Definition provides constructor, provided constructor function will be used as object.
            constructorClass = definition.$construct;
            
            // Remove property such that it will not later be added to the object prototype.
            delete definition.$construct;
        } else {
            // Definition does not provide constructor.
            if (baseClass) {
                // Base class available: copy constructor function from base class.
                // Note: should function copying not be supported by a future client,
                // it is possible to simply create a new constructor which invokes the base
                // class constructor (using closures and Function.apply()) to achieve the
                // same effect (with a slight performance penalty).
                constructorClass = Core._copyFunction(baseClass);
            } else {
                // No base class: constructor is an empty function.
                constructorClass = Core._createFunction();
            }
        }
        
        // Create virtual property storage.
        constructorClass.$virtual = {};
        
        // Store reference to base class in constructor class.
        constructorClass.$super = baseClass;

        if (baseClass) {
            // Create class with empty constructor that shares prototype of base class.
            var prototypeClass = Core._createFunction();
            prototypeClass.prototype = baseClass.prototype;
            
            // Create new instance of constructor-less prototype for use as prototype of new class.
            constructorClass.prototype = new prototypeClass();
        }
        
        // Assign constructor correctly.
        constructorClass.prototype.constructor = constructorClass;

        // Add abstract properties.
        if (definition.$abstract) {
            constructorClass.$abstract = {};
            if (baseClass && baseClass.$abstract) {
                // Copy abstract properties from base class.
                for (x in baseClass.$abstract) {
                    constructorClass.$abstract[x] = baseClass.$abstract[x];
                }
            }

            if (definition.$abstract instanceof Object) {
                // Add abstract properties from definition.
                for (x in definition.$abstract) {
                    constructorClass.$abstract[x] = true;
                    constructorClass.$virtual[x] = true;
                }
            }
            
            // Remove property such that it will not later be added to the object prototype.
            delete definition.$abstract;
        }
        
        // Copy virtual property flags from base class to shared prototype.
        if (baseClass) {
            for (name in baseClass.$virtual) {
                constructorClass.$virtual[name] = baseClass.$virtual[name];
            }
        }
        
        // Add virtual instance properties from definition to shared prototype.
        if (definition.$virtual) {
            Core._inherit(constructorClass.prototype, definition.$virtual, constructorClass.$virtual);
            for (name in definition.$virtual) {
                constructorClass.$virtual[name] = true;
            }

            // Remove property such that it will not later be added to the object prototype.
            delete definition.$virtual;
        }
        
        // Add toString and valueOf manually, as they will not be iterated
        // by for-in iteration in Internet Explorer.
        if (definition.hasOwnProperty("toString")) {
            constructorClass.prototype.toString = definition.toString;
        }
        if (definition.hasOwnProperty("valueOf")) {
            constructorClass.prototype.valueOf = definition.valueOf;
        }

        // Remove properties such that they will not later be added to the object prototype.
        delete definition.toString;
        delete definition.valueOf;

        // Add Mixins.
        if (definition.$include) {
            // Reverse order of mixins, such that later-defined mixins will override earlier ones.
            // (Mixins will only be added if they will NOT override an existing method.)
            var mixins = definition.$include.reverse();
            Core._processMixins(constructorClass, mixins);
            
            // Remove property such that it will not later be added to the object prototype.
            delete definition.$include;
        }

        // Store $load static initializer and remove from definition so it is not inherited in static processing.
        var loadMethod = null;
        if (definition.$load) {
            loadMethod = definition.$load;

            // Remove property such that it will not later be added to the object prototype.
            delete definition.$load;
        }
        
        // Process static properties and methods defined in the '$static' object.
        if (definition.$static) {
            Core._inherit(constructorClass, definition.$static);

            // Remove property such that it will not later be added to the object prototype.
            delete definition.$static;
        }

        // Process instance properties and methods.
        Core._inherit(constructorClass.prototype, definition, constructorClass.$virtual);
        
        // If class is concrete, verify all abstract methods are provided.
        if (!constructorClass.$abstract) {
            this._verifyAbstractImpl(constructorClass);
        }
        
        // Invoke static constructors.
        if (loadMethod) {
            // Invoke $load() function with "this" pointer set to class.
            loadMethod.call(constructorClass);
        }
        
        return constructorClass;
    },
    
    /**
     * Retrieves a value from an object hierarchy.
     *
     * Examples: 
     * Given the following object 'o': <code>{ a: { b: 4, c: 2 }}</code>
     * <ul>
     * <li><code>Core.get(o, ["a", "b"]) will return <code>4</code>.</li>
     * <li><code>Core.get(o, ["a", "c"]) will return <code>2</code>.</li>
     * <li><code>Core.get(o, ["a", "d"]) will return <code>null</code>.</li>
     * <li><code>Core.get(o, ["a"]) will return <code>{ b: 4, c: 2 }</code>.</li>
     * <li><code>Core.get(o, ["b"]) will return <code>null</code>.</li>
     * <li><code>Core.get(o, ["d"]) will return <code>null</code>.</li>
     * </ul>
     *
     * @param object an arbitrary object from which the value should be retrieved
     * @param {Array} path an array of object property names describing the path to retrieve
     * @return the value, if found, or null if it does not exist
     */
    get: function(object, path) {
        for (var i = 0; i < path.length; ++i) {
            object = object[path[i]];
            if (!object) {
                return null;
            }
        }

        return object;
    },
    
    /**
     * Determines if the specified propertyName of the specified object is a virtual
     * property, i.e., that it can be overridden by subclasses.
     */
    _isVirtual: function(virtualProperties, propertyName) {
        switch (propertyName) {
        case "toString":
        case "valueOf":
            return true;
        }
        
        return virtualProperties[propertyName];
    },
    
    /**
     * Installs properties from source object into destination object.
     * <p>
     * In the case where the destination object already has a property defined
     * and the "virtualProperties" argument is provided, the "virtualProperties"
     * collection will be checked to ensure that property is allowed to be
     * overridden.  If "virtualProperties" is omitted, any property may be
     * overridden.
     *
     * @param destination the destination object
     * @param soruce the source object
     * @param virtualProperties (optional) collection of virtual properties from base class.
     */
    _inherit: function(destination, source, virtualProperties) {
        for (var name in source) {
            if (virtualProperties && destination[name] !== undefined && !this._isVirtual(virtualProperties, name)) {
                // Property exists in destination as is not marked as virtual.
                throw new Error("Cannot override non-virtual property \"" + name + "\".");
            } else {
                destination[name] = source[name];
            }
        }
    },
    
    /**
     * Creates a new function which executes a specific method of an object instance.
     * Any arguments passed to the returned function will be passed to the method.
     * The return value of the method will be returned by the function.
     *
     * CAUTION: When adding and removing methods as listeners, note that two separately
     * constructed methods will not be treated as equal, even if their instance and method
     * properties are the same.  Failing to heed this warning can result in a memory leak,
     * as listeners would never be removed.
     *
     * @param instance the object instance
     * @param {Function} method the method to be invoked on the instance
     * @return the return value provided by the method
     */
    method: function(instance, method) {
        return function() {
            return method.apply(instance, arguments);
        };
    },
    
    /**
     * Add properties of mixin objects to destination object.
     * Mixins will be added in order, and any property which is already
     * present in the destination object will not be overridden.
     *
     * @param destination the destination object
     * @param {Array} mixins the mixin objects to add 
     */
    _processMixins: function(destination, mixins) {
        for (var i = 0; i < mixins.length; ++i) {
            for (var mixinProperty in mixins[i]) {
                if (destination.prototype[mixinProperty]) { 
                    // Ignore mixin properties that already exist.
                    continue;
                }
                destination.prototype[mixinProperty] = mixins[i][mixinProperty];
            }
        }
    },
    
    /**
     * Sets a value in an object hierarchy.
     *
     * Examples: 
     * Given the following object 'o': <code>{ a: { b: 4, c: 2 } }</code>
     * <ul>
     * <li><code>Core.set(o, ["a", "b"], 5)</code> will update the value of 'o' to be: <code>{ a: { b: 5, c: 2 } }</code></li>
     * <li><code>Core.set(o, ["a", "d"], 7)</code> will update the value of 'o' to be:
     * <code>{ a: { b: 4, c: 2, d: 7 } }</code></li>
     * <li><code>Core.set(o, ["e"], 9)</code> will update the value of 'o' to be: <code>{ a: { b: 4, c: 2 }, e: 9 }</code></li>
     * <li><code>Core.set(o, ["f", "g"], 8)</code> will update the value of 'o' to be: 
     * <code>{ a: { b: 4, c: 2 }, f: { g: 8 } }</code></li>
     * <li><code>Core.set(o, ["a"], 10)</code> will update the value of 'o' to be: <code>{ a: 10 }</code></li>
     * </ul>
     *
     * @param object an arbitrary object from which the value should be retrieved
     * @param {Array} path an array of object property names describing the path to retrieve
     * @return the value, if found, or null if it does not exist
     */
    set: function(object, path, value) {
        var parentObject = null;
        
        // Find or create container object.
        for (var i = 0; i < path.length - 1; ++i) {
            parentObject = object; 
            object = object[path[i]];
            if (!object) {
                object = {};
                parentObject[path[i]] = object;
            }
        }
        
        // Assign value.
        object[path[path.length - 1]] = value;
    },
    
    /**
     * Verifies that a concrete derivative of an abstract class implements
     * abstract properties present in the base class.
     *
     * @param constructorClass the class to verify
     */
    _verifyAbstractImpl: function(constructorClass) {
         var baseClass = constructorClass.$super;
         if (!baseClass || !baseClass.$abstract || baseClass.$abstract === true) {
             return;
         }
         
         for (var x in baseClass.$abstract) {
             if (constructorClass.prototype[x] == null) {
                 throw new Error("Concrete class does not provide implementation of abstract method \"" + x + "\".");
             }
         }
    }
};

/**
 * Namespace for debugging related utilities.
 * @class
 */
Core.Debug = { 

    /**
     * The DOM element to which console output should be written.
     * @type HTMLElement
     */
    consoleElement: null,
    
    /**
    * Flag indicating whether console output should be displayed as alerts.
    * Enabling is generally not recommended.
    * @type Boolean
    */
    useAlertDialog: false,
    
    /**
     * Writes a message to the debug console.
     * 
     * @param {String} text the message
     */
    consoleWrite: function(text) {
        if (Core.Debug.consoleElement) {
            var entryElement = document.createElement("div");
            entryElement.appendChild(document.createTextNode(text));
            if (Core.Debug.consoleElement.childNodes.length === 0) {
                Core.Debug.consoleElement.appendChild(entryElement);
            } else {
                Core.Debug.consoleElement.insertBefore(entryElement, Core.Debug.consoleElement.firstChild);
            }
        } else if (Core.Debug.useAlertDialog) {
            alert("DEBUG:" + text);
        }
    },
    
    /**
     * Creates a string representation of the state of an object's instance variables.
     *
     * @param object the object to convert to a string
     * @return the string
     * @type String
     */
    toString: function(object) {
        var s = "";
        for (var x in object) {
            if (typeof object[x] != "function") { 
                s += x + ":" + object[x] + "\n";
            }
        }
        return s;
    }
};

/**
 * Arrays namespace.
 */
Core.Arrays = {

    /**
     * Returns <tt>true</tt> if the first array contains all of the elements
     * in the second array.
     *
     * @param {Array} array1 the array to be analyzed
     * @param {Array} array2 an array whose elements must all be present in <code>array1</code>
     *        for this method to return <code>true</code>
     * @param {Boolean} unique optional flag indicating that all elements in array2 are unique
     * @return <tt>true</tt> if the first array contains all of the elements
     *         in the second array
     * @type Boolean
     */
    containsAll: function(array1, array2, unique) {
        if (unique && array1.length < array2.length) {
            return false;
        }
        if (array2.length === 0) {
            return true;
        }
        var found, item;
        for (var i = 0; i < array2.length; ++i) {
            found = false;
            item = array2[i];
            for (var j = 0; j < array1.length; ++j) {
                if (item == array1[j]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    },

    /**
     * Returns the index of the specified item within the array, or -1 if it 
     * is not contained in the array.  
     * 
     * @param item the item
     * @return the index of the item, or -1 if it is not present in the array
     * @type Number
     */
    indexOf: function(array, item) {
        for (var i = 0; i < array.length; ++i) {
            if (item == array[i]) {
                return i;
            }
        }
        return -1;
    },
    
    /**
     * Removes the first instance of the specified item from an array.
     * If the item does not exist in the array, no action is taken.
     * Equality is determined using the '==' operator.
     * 
     * @param array the array from which the item should be removed
     * @param item the item to remove
     */
    remove: function(array, item) {
        for (var i = 0; i < array.length; ++i) {
            if (item == array[i]) {
                array.splice(i, 1);
                return;
            }
        }
    },
    
    /**
     * Removes duplicate items from an array.
     * Items retained in the array may not appear in the previous order.
     * 
     * @param array the array from which duplicates are to be removed.
     */
    removeDuplicates: function(array) {
        array.sort();
        var removeCount = 0;
        // Iterate from last element to second element.
        for (var i = array.length - 1; i > 0; --i) {
            // Determine if element is equivalent to previous element.
            if (array[i] == array[i - 1]) {
                // If duplicate, copy last element in array over current element.
                array[i] = array[array.length - 1 - removeCount];
                
                // Increment removeCount (indicating how much the length of the array should be decremented)
                ++removeCount;
            }
        }
        
        if (removeCount > 0) {
            array.length = array.length - removeCount;
        }
    }
};

/**
 * Associative array wrapper which periodically recreates the associative array
 * in order to avoid memory leakage and performance problems on certain browser
 * platforms, i.e., Internet Explorer 6.
 * Null values are not permitted as keys.  Setting a key to a null value
 * will result in the key being removed.
 */
Core.Arrays.LargeMap = Core.extend({
    
    $static: {
    
        /** 
         * Flag indicating whether forced garbage collection should be enabled.
         * This flag should be manually set in environments where it is required.
         * (The web module does this automatically for IE6.)
         */
        garbageCollectEnabled: false
    },
    
    /**
     * Number of removes since last associative array re-creation.
     * @type Number
     */
    _removeCount: 0,
    
    /**
     * Number (integer) of removes between associative array re-creation.
     * @type Number
     */
    garbageCollectionInterval: 250,
    
    /**
     * Associative mapping.
     */
    map: null, 
    
    /**
     * Creates a new LargeMap.
     */
    $construct: function() {
        this.map = {};
    },
    
    /**
     * Performs 'garbage-collection' operations, recreating the array.
     * This operation is necessary due to Internet Explorer memory leak
     * issues.
     */
    _garbageCollect: function() {
        this._removeCount = 0;
        var newMap = {};
        for (var key in this.map) {
            newMap[key] = this.map[key];
        }
        this.map = newMap;
    },
    
    /**
     * Removes the value referenced by the specified key.
     *
     * @param key the key
     */
    remove: function(key) {
        delete this.map[key];
        if (Core.Arrays.LargeMap.garbageCollectEnabled) {
            ++this._removeCount;
            if (this._removeCount >= this.garbageCollectionInterval) {
                this._garbageCollect();
            }
        }
    },
    
    /**
     * Returns a string representation, for debugging purposes only.
     * 
     * @return a string representation of the map
     * @type String
     */
    toString: function() {
        return Core.Debug.toString(this.map);
    }
});

/**
 * A collection of event listeners.  Provides capability to manage listeners
 * of multiple types, and fire events to listeners based on type.
 */
Core.ListenerList = Core.extend({

    /**
     * Array containing event types and event listeners.  
     * Even indexes contain event types, and the subsequent odd
     * index contain Functions to invoke.
     * @type Array
     */
    _data: null,
   
    /**
     * Creates a new listener list.
     * 
     * @constructor
     */
    $construct: function() {
        this._data = [];
    },

    /**
     * Adds an event listener.
     * 
     * @param {String} eventType the event type
     * @param {Function} eventTarget the event target
     */
    addListener: function(eventType, eventTarget) {
        this._data.push(eventType, eventTarget);
    },
    
    /**
     * Fires an event.
     * 
     * @param event the event to fire
     * @return true if all event listeners returned values that evaluate to true, 
     *         or false if any event listeners returned values that evaluate to 
     *         false
     * @type Boolean
     */
    fireEvent: function(event) {
        if (event.type == null) {
            throw new Error("Cannot fire event, type property not set.");
        }
        
        var i, returnValue = true, listeners = [];
        
        for (i = 0; i < this._data.length; i += 2) {
            if (this._data[i] == event.type) {
                listeners.push(this._data[i + 1]);
            }
        }
        
        for (i = 0; i < listeners.length; ++i) {
            returnValue = listeners[i](event) && returnValue; 
        }
        return returnValue;
    },
    
    /**
     * Returns an array containing the types of all listeners
     * in the list.
     * 
     * @return the event types
     * @type Array
     */
    getListenerTypes: function() {
        var types = [];
        for (var i = 0; i < this._data.length; i += 2) {
            types.push(this._data[i]);
        }
        Core.Arrays.removeDuplicates(types);
        return types;
    },
    
    /**
     * Returns an array of all listeners for a specific event type.
     * 
     * @param {String} eventType the event type
     * @return the listeners
     * @type Array
     */
    getListeners: function(eventType) {
        var listeners = [];
        for (var i = 0; i < this._data.length; i += 2) {
            if (this._data[i] == eventType) {
                listeners.push(this._data[i + 1]);
            }
        }
        return listeners;
    },
    
    /**
     * Determines the number of listeners for a specific event type.
     * 
     * @param {String} eventType the event type
     * @return the listener count
     * @type Number
     */
    getListenerCount: function(eventType) {
        var count = 0;
        for (var i = 0; i < this._data.length; i += 2) {
            if (this._data[i] == eventType) {
                ++count;
            }
        }
        return count;
    },
    
    /**
     * Determines if the listeners list has any listeners of a specific type.
     * 
     * @param {String} eventType the event type
     * @return true if any listeners exist
     * @type Boolean
     */
    hasListeners: function(eventType) {
        for (var i = 0; i < this._data.length; i += 2) {
            if (this._data[i] == eventType) {
                return true;
            }
        }
        return false;
    },
    
    /**
     * Determines if any number of listeners are registered to the list.
     * 
     * @return true if the listener list is empty
     * @type Boolean
     */
    isEmpty: function() {
        return this._data.length === 0;
    },
    
    /**
     * Removes an event listener.
     * 
     * CAUTION: If you are unregistering an event listener created with Core.method(), please see the documentation for
     * Core.method() and note that a new closure-wrapped method is returned each time Core.method() is invoked.
     * Thus calling removeListener(Core.method(this, this,_someListener)) will NOT remove an existing listener.
     * The solution to this issue is to retain a reference to Core.method() wrapped listeners within the object
     * that will register and unregister them.
     * 
     * 
     * @param {String} eventType the event type
     * @param {Function} eventTarget the event target
     */
    removeListener: function(eventType, eventTarget) {
        for (var i = 0; i < this._data.length; i += 2) {
            if (this._data[i] == eventType && eventTarget == this._data[i + 1]) {
                var oldLength = this._data.length;
                this._data.splice(i, 2);
                return;
            }
        }
    },
    
    /** @see Object#toString */
    toString: function() {
        var out = "";
        for (var i = 0; i < this._data.length; i += 2) {
            if (i > 0) {
                out += ", ";
            }
            out += this._data[i] + ":" + this._data[i + 1];
        }
        return out;
    }
});

/**
 * Provides locale-specific resources for multiple localizations.
 * A default resource map and locale-specific resource maps may be added to a resource bundle.
 * The resource bundle may then be queried to return a complete resource map for a specific locale.
 * When a locale-specific map is requested, any entries not available specifically in that map will be provided
 * by more generic resource maps that have been added to the bundle.
 */
Core.ResourceBundle = Core.extend({

    $static: {
    
        /**
         * Generates a less specific version of the specified language code.
         * Returns null if no "parent" language code can be determined.
         * This operation is implemented  by removing the sub-tag (if found)
         * from the specified RFC 1766 language code.  If the language
         * code does not have a sub-tag, null is returned.
         *
         * @param {String} languageCode an RFC 1766 language code
         * @return a less specific version of the specified language code,
         *         or null if none can be determined
         * @type String 
         */
        getParentLanguageCode: function(languageCode) {
            if (languageCode.indexOf("-") == -1) {
                return null;
            } else {
                return languageCode.substring(0, languageCode.indexOf("-"));
            }
        }
    },

    /**
     * Association between RFC 1766 language codes and resource maps.
     * These are the maps which have been added using the <code>set()</code> method.
     * The contents of these maps may not be modified.
     */
    _sourceMaps: null,
    
    /**
     * Cache of generated resource maps which fill omissions in more-specific resource maps
     * with those from less-specific resource maps.  A generated map is returned
     * when the user requests a locale-specific map.
     */
    _generatedMaps: null,
    
    /**
     * The default resource map that should be used in the event that a
     * locale-specific map is not available for a particular language code.
     */
    _defaultMap: null,

    /**
     * Creates a new <code>ResourceBundle</code>.
     * 
     * @param defaultMap the default resource map
     */
    $construct: function(defaultMap) {
        this._sourceMaps = {};
        this._generatedMaps = {};
        this._defaultMap = defaultMap;
    },
    
    /**
     * Returns a locale-specific resource map.  The returned map will contain entries from less-specific and/or the default map
     * if they are not available from the map for the specified language code. 
     * 
     * @param {String} languageCode an RFC 1766 language code, or null to return the default map
     * @return a locale-specific map for the language code
     */
    get: function(languageCode) {
        var map = languageCode ? this._generatedMaps[languageCode] : this._defaultMap;
        if (map) {
            return map;
        }
    
        map = {};
        var x;

        // Copy items from exact language resource map into generated resource map.
        var sourceMap = this._sourceMaps[languageCode];
        if (sourceMap) {
            for (x in sourceMap) {
                map[x] = sourceMap[x];
            }
        }

        // Copy any missing items found in parent language resource map (if it exists) into new resource map.
        var parentLanguageCode = Core.ResourceBundle.getParentLanguageCode(languageCode);
        if (parentLanguageCode) {
            sourceMap = this._sourceMaps[parentLanguageCode];
            if (sourceMap) {
                for (x in sourceMap) {
                    if (map[x] === undefined) {
                        map[x] = sourceMap[x];
                    }
                }
            }
        }

        // Copy any missing items found in default resource map into new resource map.
        for (x in this._defaultMap) {
            if (map[x] === undefined) {
                map[x] = this._defaultMap[x];
            }
        }
        
        this._generatedMaps[languageCode] = map;
        return map;
    },

    /**
     * Adds a new locale-specific map to the bundle.
     * 
     *  @param languageCode the language code
     *  @param map the key-value resource map for the language code
     */
    set: function(languageCode, map) {
        this._generatedMaps = {};
        this._sourceMaps[languageCode] = map;
    },
    
    /** @see Object#toString */
    toString: function() {
        var out = "ResourceBundle: ";
        for (var x in this._sourceMaps) {
            out += " " + x;
        }
        return out;
    }
});
/**
 * @fileoverview
 * Provides low-level web-client-related APIs.  Features include:
 * <ul>
 *  <li>Provides cross-platform API for accessing web client features that have
 *   inconsistent implementations on various browser platforms.</li>
 *  <li>Provides HTTP Connection object (wrapper for XMLHttpRequest).</li>
 *  <li>Provides HTML DOM manipulation capabilities.</li>
 *  <li>Provides DOM event management facility, enabling capturing/bubbling phases
 *   on all browsers, including Internet Explorer 6.</li>
 *  <li>Provides "virtual positioning" capability for Internet Explorer 6 to
 *   render proper top/left/right/bottom CSS positioning.</li>
 *  <li>Provides facilities to convert dimensions (e.g., in/cm/pc) to pixels.</li>
 *  <li>Provides capabilities to measure rendered size of DOM fragments.</li>
 *  <li> Provides capabilities to asynchronously load and install JavaScript modules.</li>
 * </ul>
 * Requires Core.
 */

/**
 * Namespace for Web Core.
 * @namespace
 */
Core.Web = {

    /**
     * Flag indicating that a drag-and-drop operation is in process.
     * Setting this flag will prevent text selections within the browser.
     * It must be un-set when the drag operation completes.
     * 
     * @type Boolean
     */
    dragInProgress: false,
    
    /**
     * Initializes the Web Core.  This method must be executed prior to using any Web Core capabilities.
     */
    init: function() {
        if (Core.Web.initialized) {
            // Already initialized.
            return;
        }
    
        Core.Web.Env._init();
        Core.Web.Measure._calculateExtentSizes();
        Core.Web.Measure.Bounds._initMeasureContainer();
        if (Core.Web.Env.QUIRK_CSS_POSITIONING_ONE_SIDE_ONLY) {
            // Enable virtual positioning.
            Core.Web.VirtualPosition._init();
        }
    
        if (Core.Web.Env.ENGINE_MSHTML) {
            Core.Web.DOM.addEventListener(document, "selectstart", Core.Web._selectStartListener, false);
        }
        
        Core.Web.initialized = true;
    },
    
    /**
     * Internet Explorer-specific event listener to deny selection.
     * 
     * @param {Event} e the selection event
     */
    _selectStartListener: function(e) {
        e = e ? e : window.event;
        if (Core.Web.dragInProgress) {
            Core.Web.DOM.preventEventDefault(e);
        }
    }
};

/**
 * DOM manipulation utility method namespace.
 * @class
 */
Core.Web.DOM = {

    /**
     * Temporary storage for the element about to be focused (for clients that require 'delayed' focusing).
     */
    _focusPendingElement: null,
    
    /**
     * Runnable to invoke focus implementation (lazily created).
     * @type Core.Web.Scheduler.Runnable
     */
    _focusRunnable: null,

    /**
     * Adds an event listener to an object, using the client's supported event 
     * model.  This method does NOT support method references. 
     *
     * @param {Element} eventSource the event source
     * @param {String} eventType the type of event (the 'on' prefix should NOT be included
     *        in the event type, i.e., for mouse rollover events, "mouseover" would
     *        be specified instead of "onmouseover")
     * @param {Function} eventListener the event listener to be invoked when the event occurs
     * @param {Boolean} useCapture a flag indicating whether the event listener should capture
     *        events in the final phase of propagation (only supported by 
     *        DOM Level 2 event model, not available on Internet Explorer)
     */
    addEventListener: function(eventSource, eventType, eventListener, useCapture) {
        if (eventSource.addEventListener) {
            eventSource.addEventListener(eventType, eventListener, useCapture);
        } else if (eventSource.attachEvent) {
            eventSource.attachEvent("on" + eventType, eventListener);
        }
    },
    
    /**
     * Creates a new XML DOM.
     *
     * @param {String} namespaceUri the unique URI of the namespace of the root element in 
     *        the created document (not supported for
     *        Internet Explorer 6 clients, null may be specified for all clients)
     * @param {String} qualifiedName the name of the root element of the new document (this
     *        element will be created automatically)
     * @type Document
     * @return the created DOM
     */
    createDocument: function(namespaceUri, qualifiedName) {
        if (document.implementation && document.implementation.createDocument) {
            // DOM Level 2 Browsers
            var dom;
            if (Core.Web.Env.BROWSER_FIREFOX && Core.Web.Env.BROWSER_VERSION_MAJOR == 3 &&
                    Core.Web.Env.BROWSER_VERSION_MINOR === 0) {
                // https://bugzilla.mozilla.org/show_bug.cgi?id=431701
                dom = new DOMParser().parseFromString("<?xml version='1.0' encoding='UTF-8'?><" + qualifiedName + "/>",
                        "application/xml");
            } else {
                dom = document.implementation.createDocument(namespaceUri, qualifiedName, null);
            }
            if (!dom.documentElement) {
                dom.appendChild(dom.createElement(qualifiedName));
            }
            return dom;
        } else if (window.ActiveXObject) {
            // Internet Explorer
            var createdDocument = new ActiveXObject("Microsoft.XMLDOM");
            var documentElement = createdDocument.createElement(qualifiedName);
            createdDocument.appendChild(documentElement);
            return createdDocument;
        } else {
            throw new Error("XML DOM creation not supported by browser environment.");
        }
    },
    
    /**
     * Focuses the given DOM element.
     * The focus operation may be placed in the scheduler if the browser requires the focus
     * operation to be performed outside of current JavaScript context (i.e., in the case
     * where the element to be focused was just rendered in this context).
     * 
     * @param {Element} element the DOM element to focus
     */
    focusElement: function(element) {
        if (Core.Web.Env.QUIRK_DELAYED_FOCUS_REQUIRED) {
            if (!this._focusRunnable) {
                this._focusRunnable = new Core.Web.Scheduler.MethodRunnable(this._focusElementImpl);
            }
            Core.Web.DOM._focusPendingElement = element;
            Core.Web.Scheduler.add(this._focusRunnable);
        } else {
            this._focusElementImpl(element);
        }
    },
    
    /**
     * Focus element implementation.
     * 
     * @param {Element} element the DOM element to focus
     */
    _focusElementImpl: function(element) {
        if (!element) {
            element = Core.Web.DOM._focusPendingElement;
            Core.Web.DOM._focusPendingElement = null;
        }
        if (element && element.focus) {
            try {
                element.focus();
            } catch (ex) {
                // Silently digest IE focus exceptions.
            }
        }
    },
    
    /**
     * Returns the first immediate child element of parentElement with the specified tag name.
     * 
     * @param {Element} parentElement the parent element
     * @param tagName the tag name
     * @return the first child element of parentElement with the specified tag name,
     *         or null if no elements match
     * @type Element
     */
    getChildElementByTagName: function(parentElement, tagName) {
        var element = parentElement.firstChild;
        while (element) {
            if (element.nodeType == 1 && element.nodeName == tagName) {
                return element;
            }
            element = element.nextSibling;
        }
        return null;
    },
    
    /**
     * Returns an array containing all immediate child element of parentElement with the specified tag name.
     * 
     * @param {Element} parentElement the parent element
     * @param tagName the tag name
     * @return the child elements
     * @type Array
     */
    getChildElementsByTagName: function(parentElement, tagName) {
        var elements = [];
        var element = parentElement.firstChild;
        while (element) {
            if (element.nodeType == 1 && element.nodeName == tagName) {
                elements.push(element);
            }
            element = element.nextSibling;
        }
        return elements;
    },
    
    /**
     * Returns x/y coordinates of mouse relative to the element which fired an event.
     * 
     * @param {Event} e the event
     * @return object containing 'x' and 'y' properties specifying the numeric pixel
     *         coordinates of the mouse relative to the element, with {x: 0, y: 0}
     *         indicating its upper-left corner
     */
    getEventOffset: function(e) {
        if (typeof e.offsetX == "number") {
            return { x: e.offsetX, y: e.offsetY };
        } else {
            var bounds = new Core.Web.Measure.Bounds(this.getEventTarget(e));
            return { x: e.clientX - bounds.left, y: e.clientY - bounds.top };
        }
    },
    
    /**
     * Returns the target of an event, using the client's supported event model.
     * On clients which support the W3C DOM Level 2 event specification,
     * the <code>target</code> property of the event is returned.
     * On clients which support only the Internet Explorer event model,
     * the <code>srcElement</code> property of the event is returned.
     *
     * @param {Event} e the event
     * @return the target
     * @type Element
     */
    getEventTarget: function(e) {
        return e.target ? e.target : e.srcElement;
    },
    
    /**
     * Returns the related target of an event, using the client's supported event model.
     * On clients which support the W3C DOM Level 2 event specification,
     * the <code>relatedTarget</code> property of the event is returned.
     * On clients which support only the Internet Explorer event model,
     * the <code>toElement</code> property of the event is returned.
     *
     * @param {Event} e the event
     * @return the target
     * @type Element
     */
    getEventRelatedTarget: function(e) {
        return e.relatedTarget ? e.relatedTarget : e.toElement;
    },
    
    /**
     * Determines if <code>ancestorNode</code> is or is an ancestor of
     * <code>descendantNode</code>.
     *
     * @param {Node} ancestorNode the potential ancestor node
     * @param {Node} descendantNode the potential descendant node
     * @return true if <code>ancestorNode</code> is or is an ancestor of
     *         <code>descendantNode</code>
     * @type Boolean
     */
    isAncestorOf: function(ancestorNode, descendantNode) {
        var testNode = descendantNode;
        while (testNode !== null) {
            if (testNode == ancestorNode) {
                return true;
            }
            testNode = testNode.parentNode;
        }
        return false;
    },

    /**
     * Prevents the default action of an event from occurring, using the
     * client's supported event model.
     * On clients which support the W3C DOM Level 2 event specification,
     * the preventDefault() method of the event is invoked.
     * On clients which support only the Internet Explorer event model,
     * the 'returnValue' property of the event is set to false.
     *
     * @param {Event} e the event
     */
    preventEventDefault: function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    },
    
    /**
     * Removes all child nodes from the specified DOM node.
     *
     * @param {Node} node the parent node whose children should be deleted
     */
    removeAllChildren: function(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    },
    
    /**
     * Removes an event listener from an object, using the client's supported event 
     * model.  This method does NOT support method references.
     *
     * @param {Element} eventSource the event source
     * @param {String} eventType the type of event (the 'on' prefix should NOT be included
     *        in the event type, i.e., for mouse rollover events, "mouseover" would
     *        be specified instead of "onmouseover")
     * @param {Function} eventListener the event listener to be invoked when the event occurs
     * @param {Boolean}useCapture a flag indicating whether the event listener should capture
     *        events in the final phase of propagation (only supported by 
     *        DOM Level 2 event model, not available on Internet Explorer)
     */
    removeEventListener: function(eventSource, eventType, eventListener, useCapture) {
        if (eventSource.removeEventListener) {
            eventSource.removeEventListener(eventType, eventListener, useCapture);
        } else if (eventSource.detachEvent) {
            eventSource.detachEvent("on" + eventType, eventListener);
        }
    },
    
    /**
     * Removes the specified DOM node from the DOM tree. This method employs a workaround for the
     * <code>QUIRK_PERFORMANCE_LARGE_DOM_REMOVE</code> quirk.
     *
     * @param {Node} node the node which should be deleted
     */
    removeNode: function(node) {
        var parentNode = node.parentNode;
        if (!parentNode) {
            // not in DOM tree
            return;
        }
        if (Core.Web.Env.QUIRK_PERFORMANCE_LARGE_DOM_REMOVE) {
            this._removeNodeRecursive(node);
        } else {
            parentNode.removeChild(node);
        }
    },
    
    /**
     * Removes the specified DOM node from the DOM tree in a recursive manner, i.e. all descendants
     * of the given node are removed individually. This alleviates slow performance when removing large
     * DOM trees.
     *
     * @param {Node} node the node which should be deleted
    */
    _removeNodeRecursive: function(node) {
        var childNode = node.firstChild;
        while (childNode) {
            var nextChildNode = childNode.nextSibling;
            this._removeNodeRecursive(childNode);
            childNode = nextChildNode;
        }
        node.parentNode.removeChild(node);
    },
    
    /**
     * Stops an event from propagating ("bubbling") to parent nodes in the DOM, 
     * using the client's supported event model.
     * On clients which support the W3C DOM Level 2 event specification,
     * the stopPropagation() method of the event is invoked.
     * On clients which support only the Internet Explorer event model,
     * the 'cancelBubble' property of the event is set to true.
     *
     * @param {Event} e the event
     */
    stopEventPropagation: function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    }
};

/**
 * Provides information about the web browser environment.
 * @class
 */
Core.Web.Env = {

    /**
     * Flag indicating the Presto rendering engine is being used (Opera).
     */
    ENGINE_PRESTO: null,

    /**
     * Flag indicating the WebKit rendering engine is being used (Safari,
     * Chrome). Derivative of KHTML.
     */
    ENGINE_WEBKIT: null,

    /**
     * Flag indicating the KHTML rendering engine is being used (Konqueror).
     */
    ENGINE_KHTML: null,

    /**
     * Flag indicating the MSHTML/Trident rendering engine is being used
     * (Internet Explorer).
     */
    ENGINE_MSHTML: null,

    /**
     * Flag indicating the Gecko rendering engine is being used (Mozilla,
     * Firefox).
     */
    ENGINE_GECKO: null,

    /**
     * Flag indicating a Mozilla client or Mozilla-based client.
     */
    BROWSER_MOZILLA: null,

    /**
     * Flag indicating an Opera client.
     */
    BROWSER_OPERA: null,

    /**
     * Flag indicating an Konqueror client.
     */
    BROWSER_KONQUEROR: null,

    /**
     * Flag indicating a Mozilla Firefox client.
     */
    BROWSER_FIREFOX: null,

    /**
     * Flag indicating a Microsoft Internet Explorer client.
     */
    BROWSER_INTERNET_EXPLORER: null,

    /**
     * Flag indicating a Google Chrome client.
     */
    BROWSER_CHROME: null,

    /**
     * The major browser version. For Firefox 3.0.6 this would be 3.
     * 
     * @type Number
     */
    BROWSER_VERSION_MAJOR: null,

    /**
     * The minor browser version. For Firefox 3.0.6, this would be 0.
     * 
     * @type Number
     */
    BROWSER_VERSION_MINOR: null,

    /**
     * The major engine version. For Firefox 3.0.6, which uses the Gecko 1.9,
     * this would be 1.
     * 
     * @type Number
     */
    ENGINE_VERSION_MAJOR: null,

    /**
     * The minor engine version. For Firefox 3.0.6, which uses the Gecko 1.9,
     * this would be 9.
     * 
     * @type Number
     */
    ENGINE_VERSION_MINOR: null,

    /**
     * Flag indicating whether the user-agent string contains deceptive
     * information. This is true in the case of Opera, which contains MSIE info
     * in its version string.
     */
    DECEPTIVE_USER_AGENT: null,


    /**
     * Attribute name for CSS float attribute. Varies by browser.
     * @type String
     */
    CSS_FLOAT: "cssFloat",

    /**
     * Flag indicating that offset measurements do not take into account CSS
     * borders around elements.
     * @type Boolean
     */
    MEASURE_OFFSET_EXCLUDES_BORDER: null,

    /**
     * Flag indicating that the CSS "opacity" attribute is not supported.
     * @type Boolean
     */
    NOT_SUPPORTED_CSS_OPACITY: null,
    
    /**
     * Flag indicating that relative table column widths are not supported, 
     * e.g., "*" or "2*".
     * @type Boolean
     */
    NOT_SUPPORTED_RELATIVE_COLUMN_WIDTHS: null,
    
    /**
     * Flag indicating that selectionStart/selectionEnd/setSelectionRange() are not
     * supported on text field INPUT elements and TEXTAREA elements.
     * @type Boolean
     */
    NOT_SUPPORTED_INPUT_SELECTION: null,
    
    /**
     * Flag indicating complete lack of support for W3C DOM range API. 
     * @type Boolean
     */
    NOT_SUPPORTED_RANGE: null,

    /**
     * Flag indicating support for "mouseenter" and "mouseleave" events. This is
     * a proprietary IE event, but is necessary to use to control flicker in
     * rollover effects on high-level elements in this browser.
     * @type Boolean
     */
    PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED: null,

    /**
     * Flag indicating support for "selectstart" events.
     * @type Boolean
     */
    PROPRIETARY_EVENT_SELECT_START_SUPPORTED: null,

    /**
     * Flag indicating a DirectX filter is required to render elements with
     * reduced opacity.
     * @type Boolean
     */
    PROPRIETARY_IE_OPACITY_FILTER_REQUIRED: null,

    /**
     * Flag indicating PNG alpha channel effects require the use of a DirectX
     * filter. This filter is dangerous to use, as it can interfere with event
     * handlers registered on the DOM element.
     * @type Boolean
     */
    PROPRIETARY_IE_PNG_ALPHA_FILTER_REQUIRED: null,
    
    /**
     * Flag indicating support for the IE text range API.
     * @type Boolean
     */
    PROPRIETARY_IE_RANGE: null,
    
    /**
     * Flag indicating that keypress events will place charCode value in keyCode property.
     * @type Boolean
     */
    QUIRK_KEY_CODE_IS_CHAR_CODE: null,
    
    /**
     * Flag indicating that keypress events are fired for special keys.
     * @type Boolean
     */
    QUIRK_KEY_PRESS_FIRED_FOR_SPECIAL_KEYS: null,
    
    /**
     * Flag indicating that keypress events are fired for special keys.
     * @type Boolean
     */
    QUIRK_KEY_DOWN_NOT_FIRED_FOR_SPECIAL_KEYS: null,
    
    /**
     * Flag indicating collapsed borders appear inside a table's rendered rather
     * than around it. For example, a proper rendering for a 2px collapsed
     * border is that one pixel appear inside the table's are and one pixel
     * appear outside of it. The IE browser, for example, simply renders both
     * pixels of the border inside.
     * @type Boolean
     */
    QUIRK_CSS_BORDER_COLLAPSE_INSIDE: null,

    /**
     * Flag indicating that top and bottom or left and right CSS absolute
     * positioning properties may not be used on the same attribute. Virtual
     * positioning should be used in such cases.
     * @type Boolean
     */
    QUIRK_CSS_POSITIONING_ONE_SIDE_ONLY: null,

    /**
     * Flag indicating that setting focus is more reliably accomplished by
     * performing the operation in a separate JavaScript execution context.
     * @type Boolean
     */
    QUIRK_DELAYED_FOCUS_REQUIRED: null,
    
    /**
     * Flag indicating peculiar behavior in Internet Explorer where screen suddenly appears blank after
     * DOM manipulations have been performed.  This is commonly seen when many JavaScript execution contexts
     * are being invoked and possibly performing DOM manipulations.  The exact criteria to trigger this bug
     * has not yet been determined.  It does appear that IE's rendering engine somehow collapses as a result
     * and simply blanks the screen.  Resizing the window and certain DOM modifications will cause the screen's
     * image to be restored.
     * @type Boolean
     */
    QUIRK_IE_BLANK_SCREEN: null,
    
    /**
     * Flag indicating a fundamental issue in Internet Explorer's rendering engine wherein the browser is incapable of correctly
     * sizing/positioning elements unless certain CSS attributes (which should not be necessary) are present.
     * Setting the proprietary "zoom" attribute to a value of '1' can force this browser to properly layout an an element that 
     * sufferes this quirk.
     * See http://msdn.microsoft.com/en-us/library/bb250481.aspx 
     */
    QUIRK_IE_HAS_LAYOUT: null,

    /**
     * Flag indicating DOM updates to SELECT elements may result in their
     * appearance being changed, i.e., listboxes will become select fields.
     * @type Boolean
     */
    QUIRK_IE_SELECT_LIST_DOM_UPDATE: null,

    /**
     * Flag indicating that setting percent widths on SELECT elements may result
     * in undesired behavior, e.g., zero-width rendering.
     * @type Boolean
     */
    QUIRK_IE_SELECT_PERCENT_WIDTH: null,

    /**
     * Flag indicating that SELECT elements do not respect z-index settings.
     * @type Boolean
     */
    QUIRK_IE_SELECT_Z_INDEX: null,
    
    /**
     * Flag indicating an IE browser that incorrectly displays the security warning,
     * "This page contains both secure and nonsecure items. Do you want to display the nonsecure items?".
     * See http://support.microsoft.com/kb/925014
     * @type Boolean
     */
    QUIRK_IE_SECURE_ITEMS: null,

    /**
     * Flag indicating that IE browser does not properly render tables whose
     * widths are set to percent values when scrollbars are present. The
     * scrollbar is not included in the calculation of the container size, thus
     * a 100% wide table will not fit in its container when a vertical scrollbar
     * is present, and will trigger a horizontal scroll bar.
     * @type Boolean
     */
    QUIRK_IE_TABLE_PERCENT_WIDTH_SCROLLBAR_ERROR: null,

    /**
     * Quirk flag indicating that offset measurements on elements whose overflow setting is hidden
     * will be incorrectly reduced by the border size.  Used internally in measuring algorithms.
     * @type Boolean
     */
    QUIRK_MEASURE_OFFSET_HIDDEN_BORDER: null,

    /**
     * Flag indicating a bug in the Opera browser where absolute CSS positioning
     * and offset calculations are incorrectly performed. See
     * http://my.opera.com/community/forums/topic.dml?id=250572
     * @type Boolean
     */
    QUIRK_OPERA_CSS_POSITIONING: null,

    /**
     * Quirk indicating that removing large element hierarchies from the DOM
     * using a single removeChild invocation at the root results in poor
     * performance. Workaround is to iteratively remove smaller hierarchies.
     * @type Boolean
     */
    QUIRK_PERFORMANCE_LARGE_DOM_REMOVE: null,

    /**
     * Flag indicating XML documents being sent via XMLHttpRequest must have
     * text content manually escaped due to bugs in the Webkit render engine.
     * @type Boolean
     */
    QUIRK_WEBKIT_DOM_TEXT_ESCAPE: null,

    /**
     * Flag indicating that table cell widths do not include padding value.
     * @type Boolean
     */
    QUIRK_TABLE_CELL_WIDTH_EXCLUDES_PADDING: null,

    /**
     * Flag indicating that images which not yet been loaded will have size
     * information (width/height values).
     * @type Boolean
     */
    QUIRK_UNLOADED_IMAGE_HAS_SIZE: null,

    /**
     * User-agent string, in lowercase.
     */
    _ua: null,

    /**
     * The user agent string with all non-alpha character sequences replaced
     * with single slashes and with leading/trailing slashes appended. This
     * string can be searched for whole words using indexOf("/example/")
     */
    _uaAlpha: null,
    
    /**
     * Performs initial analysis of environment. Automatically invoked when
     * Core.Web module is initialized.
     */
    _init: function() {
        var browserVersion = null, 
            engineVersion = null, 
            engineId = false;

        this._ua = navigator.userAgent.toLowerCase();
        this._uaAlpha = "/" + this._ua.replace(/[^a-z]+/g, "/") + "/";
        
        // Parse version string for known major browsers, in reverse order of which they are imitated,
        // i.e., Chrome imitates Safari and Gecko, while Mozilla imitates nothing.
        if (this._testUAString("opera")) {
            this.BROWSER_OPERA = engineId = this.ENGINE_PRESTO = true;
            browserVersion = this._parseVersionInfo("opera/");
        } else if (this._testUAString("chrome")) {
            this.BROWSER_CHROME = engineId = this.ENGINE_WEBKIT = true;
            browserVersion = this._parseVersionInfo("chrome/");
        } else if (this._testUAString("safari")) {
            this.BROWSER_SAFARI = engineId = this.ENGINE_WEBKIT = true;
            browserVersion = this._parseVersionInfo("version/");
        } else if (this._testUAString("konqueror")) {
            this.BROWSER_KONQUEROR = engineId = this.ENGINE_KHTML = true;
            browserVersion = this._parseVersionInfo("konqueror/");
        } else if (this._testUAString("firefox")) {
            this.BROWSER_FIREFOX = this.BROWSER_MOZILLA = engineId = this.ENGINE_GECKO = true;
            browserVersion = this._parseVersionInfo("firefox/");
        } else if (this._testUAString("msie")) {
            this.BROWSER_INTERNET_EXPLORER = engineId = this.ENGINE_MSHTML = true;
            // Set engine version to browser version for MSIE/MSHTML.  Unfortunately "Trident" versioning
            // is unpredictable, with the MSIE8 UA string reporting "Trident/4.0" but MSIE6 supposedly using "Trident IV"
            // and MSIE7 supposedly using "Trident V".  We thus go by the suspected MSHTML DLL version, which is equivalent to
            // the IE version.
            engineVersion = browserVersion = this._parseVersionInfo("msie ");
        }
        
        if (!engineId) {
            // Browser/engine not yet identified, attempt to identify by engine.
            if (this._testUAString("presto")) {
                this.ENGINE_PRESTO = true;
            } else if (this._testUAString("webkit")) {
                this.ENGINE_WEBKIT = true;
            } else if (this._testUAString("khtml")) {
                this.ENGINE_KHTML = true;
            } else if (this._testUAString("trident")) {
                this.ENGINE_MSHTML = true;
            } else if (this._testUAString("gecko")) {
                this.BROWSER_MOZILLA = this.ENGINE_GECKO = true;
            }
        }
        
        if (!engineVersion) {
            if (this.ENGINE_PRESTO) {
                engineVersion = this._parseVersionInfo("presto/");
            } else if (this.ENGINE_WEBKIT) {
                engineVersion = this._parseVersionInfo("webkit/");
            } else if (this.ENGINE_GECKO) {
                engineVersion = this._parseVersionInfo("rv:");
                if (!browserVersion) {
                    browserVersion = engineVersion;
                }
            }
        }
        
        if (browserVersion) {
            this.BROWSER_VERSION_MAJOR = browserVersion.major;
            this.BROWSER_VERSION_MINOR = browserVersion.minor;
        }
        if (engineVersion) {
            this.ENGINE_VERSION_MAJOR = engineVersion.major;
            this.ENGINE_VERSION_MINOR = engineVersion.minor;
        }
        
        // Note deceptive user agent fields:
        // - Konqueror and Safari UA fields contain "like Gecko"
        // - Opera UA field typically contains "MSIE"
        // If this flag is set, browser is not GECKO/MSHTML
        this.DECEPTIVE_USER_AGENT = this.BROWSER_OPERA || this.BROWSER_SAFARI || this.BROWSER_CHROME || this.BROWSER_KONQUEROR;
        
        this.MEASURE_OFFSET_EXCLUDES_BORDER = false;
                
        // Set IE Quirk Flags
        if (this.BROWSER_INTERNET_EXPLORER) {
            // Internet Explorer Flags (all versions).
            this.CSS_FLOAT = "styleFloat";
            this.QUIRK_KEY_CODE_IS_CHAR_CODE = true;
            this.QUIRK_IE_SECURE_ITEMS = true;
            this.NOT_SUPPORTED_RANGE = true;
            this.NOT_SUPPORTED_INPUT_SELECTION = true;
            this.PROPRIETARY_IE_RANGE = true;
            this.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED = true;
            this.PROPRIETARY_EVENT_SELECT_START_SUPPORTED = true;
            this.QUIRK_DELAYED_FOCUS_REQUIRED = true;
            this.QUIRK_UNLOADED_IMAGE_HAS_SIZE = true;
            this.MEASURE_OFFSET_EXCLUDES_BORDER = true;
            this.QUIRK_IE_BLANK_SCREEN = true;
            this.QUIRK_IE_HAS_LAYOUT = true;
            
            if (this.BROWSER_VERSION_MAJOR < 8) {
                // Internet Explorer 6 and 7 Flags.
                this.QUIRK_TABLE_CELL_WIDTH_EXCLUDES_PADDING = true;
                this.NOT_SUPPORTED_RELATIVE_COLUMN_WIDTHS = true;
                this.QUIRK_CSS_BORDER_COLLAPSE_INSIDE = true;
                this.NOT_SUPPORTED_CSS_OPACITY = true;
                this.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED = true;
                this.QUIRK_IE_TABLE_PERCENT_WIDTH_SCROLLBAR_ERROR = true;
                this.QUIRK_IE_SELECT_PERCENT_WIDTH = true;
                
                if (this.BROWSER_VERSION_MAJOR < 7) {
                    // Internet Explorer 6 Flags.
                    this.QUIRK_IE_SELECT_LIST_DOM_UPDATE = true;
                    this.QUIRK_CSS_POSITIONING_ONE_SIDE_ONLY = true;
                    this.PROPRIETARY_IE_PNG_ALPHA_FILTER_REQUIRED = true;
                    this.QUIRK_IE_SELECT_Z_INDEX = true;
                    // Enable 'garbage collection' on large associative arrays to avoid memory leak.
                    Core.Arrays.LargeMap.garbageCollectEnabled = true;
                }
            }
        } else if (this.ENGINE_GECKO) {
            this.QUIRK_KEY_PRESS_FIRED_FOR_SPECIAL_KEYS = true;
            this.MEASURE_OFFSET_EXCLUDES_BORDER = true;
            this.QUIRK_MEASURE_OFFSET_HIDDEN_BORDER = true;
            if (this.BROWSER_FIREFOX) {
                if (this.BROWSER_VERSION_MAJOR < 2) {
                    this.QUIRK_DELAYED_FOCUS_REQUIRED = true;
                }
            } else {
                this.QUIRK_PERFORMANCE_LARGE_DOM_REMOVE = true;
                this.QUIRK_DELAYED_FOCUS_REQUIRED = true;
            }
        } else if (this.ENGINE_PRESTO) {
            this.QUIRK_KEY_CODE_IS_CHAR_CODE = true;
            this.QUIRK_TABLE_CELL_WIDTH_EXCLUDES_PADDING = true;
            if (this.BROWSER_VERSION_MAJOR == 9 && this.BROWSER_VERSION_MINOR >= 50) {
                this.QUIRK_OPERA_CSS_POSITIONING = true;
            }
            this.NOT_SUPPORTED_RELATIVE_COLUMN_WIDTHS = true;
        } else if (this.ENGINE_WEBKIT) {
            this.MEASURE_OFFSET_EXCLUDES_BORDER = true;
            if (this.ENGINE_VERSION_MAJOR < 526 || (this.ENGINE_VERSION_MAJOR == 526 && this.ENGINE_VERSION_MINOR < 8)) {
                this.QUIRK_WEBKIT_DOM_TEXT_ESCAPE = true; //https://bugs.webkit.org/show_bug.cgi?id=18421, fixed in 526.8
            }
        }
    },
    
    /**
     * Parses version information from user agent string. The text argument specifies
     * the string that prefixes the version info in the ua string (ie 'version/' for Safari for example).
     * <p>
     * The major version is retrieved by getting the int between text and the first dot. The minor version
     * is retrieved by getting the int between the first dot and the first non-numeric character that appears
     * after the dot, or the end of the ua string (whichever comes first).
     * If the ua string does not supply a minor version, the minor version is assumed to be 0.
     *
     * @param ua the lower cased user agent string
     * @param searchString the text that prefixes the version info (version info must be the first appearance of 
     *          this text in the ua string)
     */
    _parseVersionInfo: function(searchString) {
        var version = { };
        
        var ix1 = this._ua.indexOf(searchString);
        if (ix1 == -1) {
            return;
        }
        
        var ix2 = this._ua.indexOf(".", ix1);
        var ix3 = this._ua.length;
        
        if (ix2 == -1) {
            ix2 = this._ua.length;
        } else {
            // search for the first non-number character after the dot
            for (var i = ix2 + 1; i < this._ua.length; i++) {
                var c = this._ua.charAt(i);
                if (isNaN(c)) {
                    ix3 = i;
                    break;
                }
            }
        }
        
        version.major = parseInt(this._ua.substring(ix1 + searchString.length, ix2), 10);
        if (ix2 == this._ua.length) {
            version.minor = 0;
        } else {
            version.minor = parseInt(this._ua.substring(ix2 + 1, ix3), 10);
        }
        
        return version;
    },
    
    _testUAString: function(browser) {
        return this._uaAlpha.indexOf("/" + browser + "/") != -1;
    }
};

/**
 * Event Processing System namespace. The static methods in this object provide
 * a standard framework for handling DOM events across often-incompatible
 * browser platforms.
 * <p>
 * <b>Event Propagation:</b> Capturing listeners are notified of events first,
 * followed by bubbling listeners. During the capturing phase of event firing,
 * listeners on higher-level DOM elements are notified before the lower-level
 * DOM elements. During the bubbling phase of event firing, lower-level DOM
 * elements are notified before higher-level DOM elements.
 * <p>
 * For example, given the DOM hierarchy
 * <code>&lt;body&gt;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;</code>,
 * with click listeners registered for both capturing and bubbling phases on all
 * elements, the listener notification order for a click on the
 * <code>&lt;span&gt;</code> element would be as folows:
 * <ol>
 * <li>Notify capturing listener of <code>&lt;body&gt;</code> element.</li>
 * <li>Notify capturing listener of <code>&lt;div&gt;</code> element.</li>
 * <li>Notify capturing listener of <code>&lt;span&gt;</code> element.</li>
 * <li>Notify bubbling listener of <code>&lt;span&gt;</code> element.</li>
 * <li>Notify bubbling listener of <code>&lt;div&gt;</code> element.</li>
 * <li>Notify bubbling listener of <code>&lt;body&gt;</code> element.</li>
 * </ol>
 * <b>Listener Return Values:</b> Listeners should return a value of true if
 * they wish to continue to allow propogation of an event, and false if they do
 * not.
 * <p>
 * <b>Capturing/Bubbling Listeners:</b> This implementation allows for the
 * registration of both capturing and bubbling event listeners on all browser
 * platforms, including Internet Explorer, even though Internet Explorer does
 * not inhererntly support such listeners. This is accomplished by the Event
 * system adding a layer of abstraction between event registration and the
 * browser, and then invoking event listeners itself.
 * <p>
 * This implementation relies on the fact that all event listeners will be 
 * registered through it.  The implementation is in fact internally registering only
 * bubbling-phase event listeners on the DOM.  Thus, if other event listeners are 
 * registered directly on the DOM, scenarios may occur such as a direct-registered
 * bubbling listener receiving an event before a Core.Web.Event-registered capturing
 * listener.  This is not necessarily a critical issue, but the developer should
 * be aware of it. 
 * 
 * @class
 */
Core.Web.Event = {
    
    /**
     * Provides utilities for restricting selection of DOM elements.  These are necessary as double click and drag
     * events will cause/begin undesired selections.
     */
    Selection: {

        /**
         * Adds a listener to an element that will prevent text selection / highlighting as a result of mouse clicks.
         * The disable() method should be invoked when the element is to be disposed.
         * The event is registered using the event processor, so invoking Core.Web.Event.removeAll() on its
         * element will also dispose it.
         *
         * @param {Element} element the element on which to forbid text selection
         * @see Core.Web.Event.Selection#enable
         */
        disable: function(element) {
            Core.Web.Event.add(element, "mousedown", Core.Web.Event.Selection._disposeEvent, false);
            if (Core.Web.Env.PROPRIETARY_EVENT_SELECT_START_SUPPORTED) {
                Core.Web.Event.add(element, "selectstart", Core.Web.Event.Selection._disposeEvent, false);
            }
        },
        
        /**
         * Selection denial listener implementation.
         * 
         * @param e the selection/click event
         */
        _disposeEvent: function(e) {
            Core.Web.DOM.preventEventDefault(e);
        },
    
        /**
         * Removes a selection denial listener.
         * 
         * @param element the element from which to remove the selection denial listener
         * @see Core.Web.Event.Selection#enable
         */
        enable: function(element) {
            Core.Web.Event.remove(element, "mousedown", Core.Web.Event.Selection._disposeEvent, false);
            if (Core.Web.Env.PROPRIETARY_EVENT_SELECT_START_SUPPORTED) {
                Core.Web.Event.remove(element, "selectstart", Core.Web.Event.Selection._disposeEvent, false);
            }
        }
    },
    
    /**
     * Next available sequentially assigned element identifier.
     * Elements are assigned unique identifiers to enable mapping between 
     * elements and lists of registered event listeners.
     *
     * @type Integer
     */
    _nextId: 0,
    
    /**
     * Current listener count.
     */
    _listenerCount: 0,
    
    /**
     * Flag to display listener count every time an event is fired.  Enable this flag to check for listener leaks.
     */
    debugListenerCount: false,
    
    /**
     * Mapping between element ids and ListenerLists containing listeners to invoke during capturing phase.
     * @type Core.Arrays.LargeMap
     */
    _capturingListenerMap: new Core.Arrays.LargeMap(),
    
    /**
     * Mapping between element ids and ListenerLists containing listeners to invoke during bubbling phase.
     * @type Core.Arrays.LargeMap
     */
    _bubblingListenerMap: new Core.Arrays.LargeMap(),
    
    /**
     * Registers an event handler.
     *
     * @param {Element} element the DOM element on which to add the event handler
     * @param {String} eventType the DOM event type
     * @param {Function} eventTarget the event handler to invoke when the event is fired
     * @param {Boolean} capture true to fire the event during the capturing phase, false to fire the event during
     *        the bubbling phase
     */
    add: function(element, eventType, eventTarget, capture) {
        // Assign event processor element id to element if not present.
        if (!element.__eventProcessorId) {
            element.__eventProcessorId = ++Core.Web.Event._nextId;
        }
    
        var listenerList;
        
        // Determine the Core.ListenerList to which the listener should be added.
        if (element.__eventProcessorId == Core.Web.Event._lastId && 
                capture == Core.Web.Event._lastCapture) {
            // If the 'element' and 'capture' properties are identical to those specified on the prior invocation
            // of this method, the correct listener list is stored in the '_lastListenerList' property. 
            listenerList = Core.Web.Event._lastListenerList; 
        } else {
            // Obtain correct id->ListenerList mapping based on capture parameter.
            var listenerMap = capture ? Core.Web.Event._capturingListenerMap : Core.Web.Event._bubblingListenerMap;
            
            // Obtain ListenerList based on element id.                              
            listenerList = listenerMap.map[element.__eventProcessorId];
            if (!listenerList) {
                // Create new ListenerList if none exists.
                listenerList = new Core.ListenerList();
                listenerMap.map[element.__eventProcessorId] = listenerList;
            }
            
            // Cache element's event processor id, capture parameter value, and listener list.
            // If the same element/capture properties are provided in the next call (which commonly occurs),
            // the lookup operation will be unnecessary.
            Core.Web.Event._lastId = element.__eventProcessorId;
            Core.Web.Event._lastCapture = capture;
            Core.Web.Event._lastListenerList = listenerList;
        }
    
        // Register event listener on DOM element.
        if (!listenerList.hasListeners(eventType)) {
            Core.Web.DOM.addEventListener(element, eventType, Core.Web.Event._processEvent, false);
            ++Core.Web.Event._listenerCount;
        }

        // Add event handler to the ListenerList.
        listenerList.addListener(eventType, eventTarget);
    },
    
    /**
     * Listener method which is invoked when ANY event registered with the event processor occurs.
     * 
     * @param {Event} e 
     */
    _processEvent: function(e) {
        if (Core.Web.Event.debugListenerCount) {
            Core.Debug.consoleWrite("Core.Web.Event listener count: " + Core.Web.Event._listenerCount);        
        }

        e = e ? e : window.event;
        
        if (!e.target && e.srcElement) {
            // The Internet Explorer event model stores the target element in the 'srcElement' property of an event.
            // Modify the event such the target is retrievable using the W3C DOM Level 2 specified property 'target'.
            e.target = e.srcElement;
        }

        // Establish array containing elements ancestry, with index 0 containing 
        // the element and the last index containing its most distant ancestor.  
        // Only record elements that have ids.
        var elementAncestry = [];
        var targetElement = e.target;
        while (targetElement) {
            if (targetElement.__eventProcessorId) { // Element Node with identifier.
                elementAncestry.push(targetElement);
            }
            targetElement = targetElement.parentNode;
        }

        var listenerList, i, propagate = true;

        // Fire event to capturing listeners.
        for (i = elementAncestry.length - 1; i >= 0; --i) {
            listenerList = Core.Web.Event._capturingListenerMap.map[elementAncestry[i].__eventProcessorId];
            if (listenerList) {
                // Set registered target on event.
                e.registeredTarget = elementAncestry[i];
                if (!listenerList.fireEvent(e)) {
                    // Stop propagation if requested.
                    propagate = false;
                    break;
                }
            }
        }

        if (propagate) {
            // Fire event to bubbling listeners.
            for (i = 0; i < elementAncestry.length; ++i) {
                listenerList = Core.Web.Event._bubblingListenerMap.map[elementAncestry[i].__eventProcessorId];
                if (listenerList) {
                    // Set registered target on event.
                    e.registeredTarget = elementAncestry[i];
                    if (!listenerList.fireEvent(e)) {
                        // Stop propagation if requested.
                        break;
                    }
                }
            }
        }

        // Inform DOM to stop propagation of event, in all cases.
        // Event will otherwise be re-processed by higher-level elements registered with the event processor.
        Core.Web.DOM.stopEventPropagation(e);
    },
    
    /**
     * Unregisters an event handler.
     * 
     * CAUTION: If you are unregistering an event listener created with Core.method(), please see the documentation for
     * Core.method() and note that a new closure-wrapped method is returned each time Core.method() is invoked.
     * Thus calling removeListener(Core.method(this, this,_someListener)) will NOT remove an existing listener.
     * The solution to this issue is to retain a reference to Core.method() wrapped listeners within the object
     * that will register and unregister them.
     * 
     * If you are removing all listeners registered for a particular element (e.g., one which is being disposed)
     * it is more efficient to simply invoke removeAll().
     *
     * @param {Element} element the DOM element on which to add the event handler
     * @param {String} eventType the DOM event type
     * @param {Function} eventTarget the function to invoke when the event is fired
     * @param {Boolean} capture true to fire the event during the capturing phase, false to fire the event during
     *        the bubbling phase
     */
    remove: function(element, eventType, eventTarget, capture) {
        Core.Web.Event._lastId = null;
        
        if (!element.__eventProcessorId) {
            return;
        }
    
        // Obtain correct id->ListenerList mapping based on capture parameter.
        var listenerMap = capture ? Core.Web.Event._capturingListenerMap : Core.Web.Event._bubblingListenerMap;
    
        // Obtain ListenerList based on element id.                              
        var listenerList = listenerMap.map[element.__eventProcessorId];
        if (listenerList) {
            // Remove event handler from the ListenerList.
            listenerList.removeListener(eventType, eventTarget);
            
            if (listenerList.isEmpty()) {
                listenerMap.remove(element.__eventProcessorId);
            }

            // Unregister event listener on DOM element if all listeners have been removed.
            if (!listenerList.hasListeners(eventType)) {
                Core.Web.DOM.removeEventListener(element, eventType, Core.Web.Event._processEvent, false);
                --Core.Web.Event._listenerCount;
            }
        }
    },
    
    /**
     * Unregister all event handlers from a specific element.
     * Use of this operation is recommended when disposing of components, it is
     * more efficient than removing listeners individually and guarantees proper clean-up.
     * 
     * @param {Element} element the element
     */
    removeAll: function(element) {
        Core.Web.Event._lastId = null;
        if (!element.__eventProcessorId) {
            return;
        }
        Core.Web.Event._removeAllImpl(element, Core.Web.Event._capturingListenerMap);
        Core.Web.Event._removeAllImpl(element, Core.Web.Event._bubblingListenerMap);
    },
    
    /**
     * Implementation method for removeAll().
     * Removes all capturing or bubbling listeners from a specific element
     * 
     * @param {Element} element the element
     * @param {Core.Arrays.LargeMap} listenerMap the map from which the listeners should be removed, either
     *        Core.Web.Event._capturingListenerMap or Core.Web.Event._bubblingListenerMap
     */
    _removeAllImpl: function(element, listenerMap) {
        var listenerList = listenerMap.map[element.__eventProcessorId];
        if (!listenerList) {
            return;
        }
    
        var types = listenerList.getListenerTypes();
        for (var i = 0; i < types.length; ++i) {
            Core.Web.DOM.removeEventListener(element, types[i], Core.Web.Event._processEvent, false);
            --Core.Web.Event._listenerCount;
        }
        
        listenerMap.remove(element.__eventProcessorId);
    },
    
    /**
     * toString() implementation for debugging purposes.
     * Displays contents of capturing and bubbling listener maps.
     * 
     * @return string representation of listener maps
     * @type String
     */
    toString: function() {
        return "Capturing: " + Core.Web.Event._capturingListenerMap + "\n" + "Bubbling: " + Core.Web.Event._bubblingListenerMap;
    }
};

/**
 * An HTTP connection to the hosting server.  This method provides a cross
 * platform wrapper for XMLHttpRequest and additionally allows method
 * reference-based listener registration.  
 */
Core.Web.HttpConnection = Core.extend({

    /** The URL. */
    _url: null,
    
    /** The request content type. */
    _contentType: null,
    
    /** The request method. */
    _method: null,
    
    /** The message content object. */
    _messageObject: null,
    
    /** Listener storage facility. */
    _listenerList: null,
    
    /** Disposed state. */
    _disposed: false,
    
    /** Browser XMLHttpRequest object. */
    _xmlHttpRequest: null,
    
    /** Request header value map. */
    _requestHeaders: null,

    /**
     * Creates a new <code>HttpConnection</code>.
     * This method simply configures the connection, the connection
     * will not be opened until <code>connect()</code> is invoked.
     *
     * @param {String} url the target URL
     * @param {String} method the connection method, i.e., GET or POST
     * @param messageObject the message to send (may be a String or XML DOM)
     * @param {String} contentType the request content-type
     * @constructor
     */
    $construct: function(url, method, messageObject, contentType) {
        this._url = url;
        this._contentType = contentType;
        this._method = method;
        if (Core.Web.Env.QUIRK_WEBKIT_DOM_TEXT_ESCAPE && messageObject instanceof Document) {
            this._preprocessWebkitDOM(messageObject.documentElement);
        }
        
        this._messageObject = messageObject;
        this._listenerList = new Core.ListenerList();
    },
    
    /**
     * Preprocesses outgoing requests to Webkit (invoked when appropriate quirk is detected).
     * All less than, greater than, and ampersands are replaced with escaped values, as this render engine
     * is broken in this regard and will otherwise fail. Recursively invoked on nodes, starting with
     * document element.
     * 
     * @param {Node} node the node to process
     */
    _preprocessWebkitDOM: function(node) {
        if (node.nodeType == 3) {
            var value = node.data;
            value = value.replace(/&/g, "&amp;");
            value = value.replace(/</g, "&lt;");
            value = value.replace(/>/g, "&gt;");
            node.data = value;
        } else {
            var child = node.firstChild;
            while (child) {
                this._preprocessWebkitDOM(child);
                child = child.nextSibling;
            }
        }
    },
    
    /**
     * Adds a response listener to be notified when a response is received from the connection.
     * 
     * @param {Function} l the listener to add
     */
    addResponseListener: function(l) {
        this._listenerList.addListener("response", l);
    },
    
    /**
     * Executes the HTTP connection.
     * This method will return before the HTTP connection has received a response.
     */
    connect: function() {
        var usingActiveXObject = false;
        if (window.XMLHttpRequest) {
            this._xmlHttpRequest = new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            usingActiveXObject = true;
            this._xmlHttpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        } else {
            throw "Connect failed: Cannot create XMLHttpRequest.";
        }
    
        var instance = this;
        
        // Create closure around instance.
        this._xmlHttpRequest.onreadystatechange = function() { 
            if (!instance) {
                return;
            }
            try {
                instance._processReadyStateChange();
            } finally {
                if (instance._disposed) {
                    // Release instance reference to allow garbage collection.
                    instance = null;
                }
            }
        };
        
        this._xmlHttpRequest.open(this._method, this._url, true);

        // Set headers.
        if (this._requestHeaders && (usingActiveXObject || this._xmlHttpRequest.setRequestHeader)) {
            for(var h in this._requestHeaders) {
                try {
                    this._xmlHttpRequest.setRequestHeader(h, this._requestHeaders[h]);
                } catch (e) {
                    throw new Error("Failed to set header \"" + h + "\"");
                }
            }
        }
        
        // Set Content-Type, if supplied.
        if (this._contentType && (usingActiveXObject || this._xmlHttpRequest.setRequestHeader)) {
            this._xmlHttpRequest.setRequestHeader("Content-Type", this._contentType);
        }

        // Execute request.
        this._xmlHttpRequest.send(this._messageObject ? this._messageObject : null);
    },
    
    /**
     * Disposes of the connection.  This method must be invoked when the connection 
     * will no longer be used/processed.
     */
    dispose: function() {
        this._listenerList = null;
        this._messageObject = null;
        this._xmlHttpRequest = null;
        this._disposed = true;
        this._requestHeaders = null;
    },
    
    /**
     * Returns a header from the received response.
     * @param {String} header the header to retrieve
     */
    getResponseHeader: function(header) {
        return this._xmlHttpRequest ? this._xmlHttpRequest.getResponseHeader(header) : null;
    },
    
    /**
     * Returns all the headers of the response.
     * @param {String} header the header to retrieve
     */
    getAllResponseHeaders: function() {
        return this._xmlHttpRequest ? this._xmlHttpRequest.getAllResponseHeaders() : null;
    },
    
    /**
     * Returns the response status code of the HTTP connection, if available.
     * 
     * @return the response status code
     * @type Integer
     */
    getStatus: function() {
        return this._xmlHttpRequest ? this._xmlHttpRequest.status : null;
    },
    
    /**
     * Returns the response as text.
     * This method may only be invoked from a response handler.
     *
     * @return the response, as text
     * @type String
     */
    getResponseText: function() {
        return this._xmlHttpRequest ? this._xmlHttpRequest.responseText : null;
    },
    
    /**
     * Returns the response as an XML DOM.
     * This method may only be invoked from a response handler.
     *
     * @return the response, as an XML DOM
     * @type Document
     */
    getResponseXml: function() {
        return this._xmlHttpRequest ? this._xmlHttpRequest.responseXML : null;
    },
    
    /**
     * Event listener for <code>readystatechange</code> events received from
     * the <code>XMLHttpRequest</code>.
     */
    _processReadyStateChange: function() {
        if (this._disposed) {
            return;
        }
        
        if (this._xmlHttpRequest.readyState == 4) {
            var responseEvent;
            try {
                // 0 included as a valid response code for non-served applications.
                var valid = !this._xmlHttpRequest.status ||  
                        (this._xmlHttpRequest.status >= 200 && this._xmlHttpRequest.status <= 299);
                responseEvent = {type: "response", source: this, valid: valid};
            } catch (ex) {
                responseEvent = {type: "response", source: this, valid: false, exception: ex};
            }
            
            Core.Web.Scheduler.run(Core.method(this, function() {
                this._listenerList.fireEvent(responseEvent);
                this.dispose();
            }));
        }
    },
    
    /**
     * Removes a response listener to be notified when a response is received from the connection.
     * 
     * @param {Function} l the listener to remove
     */
    removeResponseListener: function(l) {
        this._listenerList.removeListener("response", l);
    },
    
    /**
     * Sets a header in the request.
     * 
     * @param {String} header the header to retrieve
     * @param {String} value the value of the header
     */
    setRequestHeader: function(header, value) {
        if (!this._requestHeaders) {
            this._requestHeaders = { };
        } 
        this._requestHeaders[header] = value;
    }
});

/**
 * Image-related utilities.
 * @class
 */
Core.Web.Image = {
    
    /**
     * Work object for monitorImageLoading() method.
     */
    _Monitor: Core.extend({

        /** Reference to _processImageLoad method. */
        _processImageLoadRef: null,
        
        /** Currently enqueued runnable. */
        _queuedRunnable: null,
        
        /** Listener to notify of successful image loadings. */
        _listener: null,
        
        /** Minimum Listener callback interval. */
        _interval: null,
        
        /** The number of images to be loaded. */
        _count: 0,
        
        /**
         * Creates a new image monitor.
         * 
         * @param {Element} element the root element which may (or may not) contain IMG elements
         * @param {Function} listener the method to invoke when images are loaded
         * @param {Number} interval the minimum time interval at which to notify the listener of successfully loaded images
         */
        $construct: function(element, listener, interval) {
            this._listener = listener;
            this._interval = interval || 250;
            this._processImageLoadRef = Core.method(this, this._processImageLoad);
            var imgs = element.getElementsByTagName("img");
            this._count = imgs.length;
            for (var i = 0; i < this._count; ++i) {
                if (!imgs[i].complete && (Core.Web.Env.QUIRK_UNLOADED_IMAGE_HAS_SIZE || 
                        (!imgs[i].height && !imgs[i].style.height))) {
                    Core.Web.DOM.addEventListener(imgs[i], "load", this._processImageLoadRef, false);
                }
            }
        },
        
        /**
         * Process an image loading event.
         * 
         * @param e the event object
         */
        _processImageLoad: function(e) {
            e = e ? e : window.event;
            Core.Web.DOM.removeEventListener(Core.Web.DOM.getEventTarget(e), "load", this._processImageLoadRef, false);
            --this._count;
            
            if (this._queuedRunnable && this._count === 0) {
                Core.Web.Scheduler.remove(this._queuedRunnable);
                this._queuedRunnable = null;
            }
            
            if (!this._queuedRunnable) {
                this._queuedRunnable = Core.Web.Scheduler.run(Core.method(this, function() {
                    this._queuedRunnable = null;
                    this._listener();
                }), this._count === 0 ? 0 : this._interval);
            }
        }
    }),
    
    /**
     * Registers a listener to receive notifications as image size information becomes available.
     * Registers "load" listeners on images which are children of the specified element, invoking the specified listener
     * zero or more times as the images load.  If all images are already loaded (e.g., they were cached) or have specified 
     * sizes, the listener may never be invoked.  If the images take some time to load, the listener may be invoked multiple times.
     * 
     * @param {Element} element the root element which may (or may not) contain IMG elements
     * @param {Function} l the method to invoke when images are loaded.
     * @param {Number} interval the maximum time interval at which the listener should be invoked (default value is 50ms, 
     *        the listener will be invoked immediately once all images have loaded)
     */
    monitor: function(element, l, interval) {
        var monitor = new Core.Web.Image._Monitor(element, l, interval);
    }
};

Core.Web.Key = {
    
    _KEY_TABLES: {
        
        GECKO: { 
            59: 186, 
            61: 187,
            109: 189
        },
        
        MAC_GECKO: {
        },
        
        PRESTO: {
            59: 186,
            61: 187,
            44: 188,
            45: 189,
            46: 190,
            47: 191,
            96: 192,
            91: 219,
            92: 220,
            93: 221,
            39: 222
        },
        
        WEBKIT: {
        }
    },
    
    _keyTable: null,
    
    _loadKeyTable: function() {
        if (Core.Web.Env.ENGINE_GECKO) {
            this._keyTable = this._KEY_TABLES.GECKO;
        } else if(Core.Web.Env.ENGINE_PRESTO) {
            this._keyTable = this._KEY_TABLES.PRESTO;
        } else {
            this._keyTable = { };
        }
    },

    translateKeyCode: function(keyCode) {
        if (!this._keyTable) {
            this._loadKeyTable();
        }
        return this._keyTable[keyCode] || keyCode;
    }
};

/**
 * Utilities for dynamically loading additional script libraries.
 * @class
 */
Core.Web.Library = {

    /**
     * Set of loaded libraries (keys are library urls, value is true when library has been loaded).
     */
    _loadedLibraries: { },
    
    /**
     * Determined source code line number of eval() library load statement (useful for debugging on browsers which do not 
     * properly report line numbers for evaluated scripts).
     * @type Number
     */
    evalLine: null,
    
    /**
     * A representation of a group of libraries to be loaded at the same time.
     * Libraries will be retrieved asynchronously, and then installed once ALL the libraries have
     * been retrieved.  Installation will be done in the order in which the add() method was
     * invoked to add libraries to the group (without regard for the order in which the 
     * HTTP server returns the library code).
     * 
     * A "load" event will be fired (listeners registered via <code>addLoadListener()</code>) when the group
     * has completed loading and the libraries have been installed.  The "success" property of the fired event
     * will be set to true in the event that all libraries were successfully loaded, and false otherwise.
     * In the event of a library loading failure, the following properties will be available in the event:
     * <ul>
     *  <li><code>url</code>: the URL of the failed library.</li>
     *  <li><code>ex</code>: the exception which occurred when attempting to load the library.</li>
     *  <li><code>cancel</code>: a boolean flag, initially set to false, which may be set to true to avoid
     *   having the library loader throw an exception for the failure.  If unset, the exception will be thrown.</li>
     * </ul>
     */
    Group: Core.extend({
    
        /** Listener storage. */
        _listenerList: null,
        
        /**
         * Array of libraries to be loaded.
         * @type Array
         */
        _libraries: null,
        
        /** Number of libraries which have been loaded. */
        _loadedCount: 0,
        
        /** Number of libraries to load. */
        _totalCount: 0,
    
        /**
         * Creates a new library group.
         * @constructor 
         */
        $construct: function() {
            this._listenerList = new Core.ListenerList();
            this._libraries = [];
        },
        
        /**
         * Adds a library to the library group.
         * Libraries which have previously been loaded will not be loaded again.
         *
         * @param {String} libraryUrl the URL from which to retrieve the library.
         */
        add: function(libraryUrl) {
            if (Core.Web.Library._loadedLibraries[libraryUrl]) {
                // Library already loaded: ignore.
                return;
            }
            
            var libraryItem = new Core.Web.Library._Item(this, libraryUrl);
            this._libraries.push(libraryItem);
        },
        
        /**
         * Adds a listener to be notified when all libraries in the group have been loaded.
         *
         * @param {Function} l the listener to add
         */
        addLoadListener: function(l) {
            this._listenerList.addListener("load", l);
        },
        
        /**
         * Determines if this library group contains any new (not previously loaded)
         * libraries.
         * 
         * @return true if any new libraries exist
         * @type Boolean
         */
        hasNewLibraries: function() {
            return this._libraries.length > 0;
        },
        
        /**
         * Installs all libraries in the group.
         * This method is invoked once all libraries have been successfully
         * retrieved.  It will invoke any registered load listeners
         * once the libraries have been installed.
         */
        _install: function() {
            for (var i = 0; i < this._libraries.length; ++i) {
                try {
                    this._libraries[i]._install();
                } catch (ex) {
                    var e = {
                        type: "load", 
                        source: this, 
                        success: false, 
                        ex: ex, 
                        url: this._libraries[i]._url,
                        cancel: false
                    };
                    try {
                        this._listenerList.fireEvent(e);
                    } finally {
                        if (!e.cancel) {
                            throw new Error("Exception installing library \"" + this._libraries[i]._url + "\"; " + ex);
                        }
                    }
                }
            }
            this._listenerList.fireEvent({type: "load", source: this, success: true});
        },
        
        /**
         * Event listener invoked when a single library has been successfully retrieved.
         * When all libraries have been retrieved, this method will invoke _install().
         */
        _notifyRetrieved: function() {
            ++this._loadedCount;
            if (this._loadedCount == this._totalCount) {
                this._install();
            }
        },
        
        /**
         * Initializes library loading.  When this method is invoked
         * the libraries will be asynchronously loaded.  This method
         * will return before the libraries have been loaded.
         * Once this method has been invoked, add() may no longer
         * be invoked.
         */
        load: function() {
            this._totalCount = this._libraries.length;
            for (var i = 0; i < this._libraries.length; ++i) {
                this._libraries[i]._retrieve();
            }
        },
        
        /**
         * Removes a listener from being notified when all libraries in the group have been loaded.
         *
         * @param {Function} l the listener to remove
         */
        removeLoadListener: function(l) {
            this._listenerList.removeListener("load", l);
        }
    }),

    /**
     * Representation of a single library to be loaded within a group
     */    
    _Item: Core.extend({
    
        /** URL Of library to load. */
        _url: null,
        
        /** Containing library group. */
        _group: null,
        
        /** 
         * Loaded library content (set when retrieved). 
         * @type String
         */
        _content: null,
    
        /**
         * Creates a new library item.
         * 
         * @param {Core.Web.Library.Group} group the library group in which the item is contained
         * @param {String} url the URL from which the library may be retrieved
         * @constructor
         */
        $construct: function(group, url) {
            this._url = url;
            this._group = group;
        },
        
        /**
         * Event listener for response from the HttpConnection used to retrieve the library.
         * 
         * @param e the event
         */
        _retrieveListener: function(e) {
            if (!e.valid) {
                throw new Error("Invalid HTTP response retrieving library \"" + this._url + 
                        "\", received status: " + e.source.getStatus());
            }
            this._content = e.source.getResponseText();
            this._group._notifyRetrieved();
        },
        
        /**
         * Installs the library.
         * The library must have been loaded before invoking this method.
         */
        _install: function() {
            if (Core.Web.Library._loadedLibraries[this._url]) {
                // If library was already loaded by another invocation, do not load it again.
                return;
            }
            Core.Web.Library._loadedLibraries[this._url] = true;
            if (this._content == null) {
                throw new Error("Attempt to install library when no content has been loaded.");
            }
            
            // Execute content to install library.
            Core.Web.Library.evalLine = new Error().lineNumber + 1;
            eval(this._content);
        },
        
        /**
         * Asynchronously retrieves the library.
         * This method will invoke the retrieve listener when the library has been completed,
         * it will return before the library has been retrieved.
         */
        _retrieve: function() {
            var conn = new Core.Web.HttpConnection(this._url, "GET");
            conn.addResponseListener(Core.method(this, this._retrieveListener));
            conn.connect();
        }
    }),
    
    /**
     * Loads required libraries and then executes a function.
     * This is a convenience method for use by applications that
     * automatically creates a Group and invokes the specified function
     * once the libraries have loaded.
     * This operation is asynchronous, this method will return before the specified function has been invoked.
     * Any libraries which have already been loaded will NOT be re-loaded.
     *
     * @param {Array} requiredLibraries the URLs of the libraries which must be loaded before the function can execute
     * @param {Function} f the function to execute
     */
    exec: function(requiredLibraries, f) {
        var group = null;
        for (var i = 0; i < requiredLibraries.length; ++i) {
            if (!Core.Web.Library._loadedLibraries[requiredLibraries[i]]) {
                if (group == null) {
                    group = new Core.Web.Library.Group();
                }
                group.add(requiredLibraries[i]);
            }
        }
        
        if (group == null) {
            Core.Web.Scheduler.run(f);
            return;
        }
        
        group.addLoadListener(f);
        group.load();
    }
};

/**
 * Namespace for measuring-related operations.
 * @class
 */
Core.Web.Measure = {

    _scrollElements: ["div", "body"],

    /** Size of one inch in horizontal pixels. */
    _hInch: 96,
    
    /** Size of one inch in vertical pixels. */
    _vInch: 96,
    
    /** Size of one 'ex' in horizontal pixels. */
    _hEx: 7,
    
    /** Size of one 'ex' in vertical pixels. */
    _vEx: 7,
    
    /** Size of one 'em' in horizontal pixels. */
    _hEm: 13.3333,
    
    /** Size of one 'em' in vertical pixels. */
    _vEm: 13.3333,
    
    /** Estimated scroll bar width. */
    SCROLL_WIDTH: 17,
    
    /** Estimated scroll bar height. */
    SCROLL_HEIGHT: 17,
    
    _PARSER: /^(-?\d+(?:\.\d+)?)(.+)?$/,

    /**
     * Converts any non-relative extent value to pixels.  Returns null in the case of a percentage extent.
     * 
     * @param {String} value a unitized extent value, e.g., "2px", "5em", etc.
     * @param {Boolean} horizontal a flag indicating whether the extent is horizontal (true) or vertical (false)
     * @return the pixel value (may have a fractional part)
     * @type Number
     */
    extentToPixels: function(extent, horizontal) {
        var parts = this._PARSER.exec(extent);
        if (!parts) {
            throw new Error("Invalid Extent: " + extent);
        }
        var value = parseFloat(parts[1]);
        var units = parts[2] ? parts[2] : "px";

        if (!units || units == "px") {
            return value;
        }
        var dpi = horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch;
        switch (units) {
        case "%":  return null;
        case "in": return value * (horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch);
        case "cm": return value * (horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch) / 2.54;
        case "mm": return value * (horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch) / 25.4;
        case "pt": return value * (horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch) / 72;
        case "pc": return value * (horizontal ? Core.Web.Measure._hInch : Core.Web.Measure._vInch) / 6;
        case "em": return value * (horizontal ? Core.Web.Measure._hEm   : Core.Web.Measure._vEm);
        case "ex": return value * (horizontal ? Core.Web.Measure._hEx   : Core.Web.Measure._vEx);
        }
    },

    /**
     * Updates internal measures used in converting length units 
     * (e.g., in, mm, ex, and em) to pixels.
     * Automatically invoked when Core.Web module is initialized.
     */
    _calculateExtentSizes: function() {
        var containerElement = document.getElementsByTagName("body")[0];
    
        var inchDiv4 = document.createElement("div");
        inchDiv4.style.width = "4in";
        inchDiv4.style.height = "4in";
        containerElement.appendChild(inchDiv4);
        Core.Web.Measure._hInch = inchDiv4.offsetWidth / 4;
        Core.Web.Measure._vInch = inchDiv4.offsetHeight / 4;
        containerElement.removeChild(inchDiv4);
        
        var emDiv24 = document.createElement("div");
        emDiv24.style.width = "24em";
        emDiv24.style.height = "24em";
        containerElement.appendChild(emDiv24);
        Core.Web.Measure._hEm = emDiv24.offsetWidth / 24;
        Core.Web.Measure._vEm = emDiv24.offsetHeight / 24;
        containerElement.removeChild(emDiv24);
        
        var exDiv24 = document.createElement("div");
        exDiv24.style.width = "24ex";
        exDiv24.style.height = "24ex";
        containerElement.appendChild(exDiv24);
        Core.Web.Measure._hEx = exDiv24.offsetWidth / 24;
        Core.Web.Measure._vEx = exDiv24.offsetHeight / 24;
        containerElement.removeChild(exDiv24);
        
        var scrollDiv = document.createElement("div");
        scrollDiv.style.cssText = "width:500px;height:100px;overflow:auto;";
        var largeDiv = document.createElement("div");
        largeDiv.style.cssText = "width:100px;height:200px;";
        scrollDiv.appendChild(largeDiv);
        var testDiv = document.createElement("div");
        testDiv.style.cssText = "width:100%;height:10px;";
        scrollDiv.appendChild(testDiv);
        containerElement.appendChild(scrollDiv);
        var measuredWidth = 500 - testDiv.offsetWidth;
        if (measuredWidth) {
            Core.Web.Measure.SCROLL_WIDTH = Core.Web.Measure.SCROLL_HEIGHT = measuredWidth;
        }
        containerElement.removeChild(scrollDiv);
    },
    
    /**
     * Measures the scrollbar offset of an element, including any
     * scroll-bar related offsets of its ancestors.
     * 
     * @param element the element to measure
     * @return the offset data, with 'left' and 'top' properties specifying the offset amounts
     * @type Object
     */
    _getScrollOffset: function(element) {
        var valueT = 0, valueL = 0;
        do {
            if (element.scrollLeft || element.scrollTop) {
                valueT += element.scrollTop  || 0;
                valueL += element.scrollLeft || 0; 
            }
            element = element.offsetParent;
        } while (element);
        return { left: valueL, top: valueT };
    },
    
    /**
     * Measures the cumulative offset of an element.
     * 
     * @param element the element to measure
     * @return the offset data, with 'left' and 'top' properties specifying the offset amounts
     * @type Object
     */
    _getCumulativeOffset: function(element) {
        var valueT = 0, 
            valueL = 0,
            init = true;
        do {
            valueT += element.offsetTop  || 0;
            valueL += element.offsetLeft || 0;
            if (!init && Core.Web.Env.MEASURE_OFFSET_EXCLUDES_BORDER) {
                if (element.style.borderLeftWidth && element.style.borderLeftStyle != "none") {
                    var borderLeft = Core.Web.Measure.extentToPixels(element.style.borderLeftWidth, true);
                    valueL += borderLeft;
                    if (Core.Web.Env.QUIRK_MEASURE_OFFSET_HIDDEN_BORDER && element.style.overflow == "hidden") {
                        valueL += borderLeft;
                    }
                }
                if (element.style.borderTopWidth && element.style.borderTopStyle != "none") {
                    var borderTop = Core.Web.Measure.extentToPixels(element.style.borderTopWidth, false);
                    valueT += borderTop;
                    if (Core.Web.Env.QUIRK_MEASURE_OFFSET_HIDDEN_BORDER && element.style.overflow == "hidden") {
                        valueT += borderTop;
                    }
                }
            }
            init = false;
            element = element.offsetParent;
        } while (element);
        return { left: valueL, top: valueT };
    },

    /**
     * Measures the boundaries of an element,i.e., its left and top position and/or
     * width and height.  If the element is not attached to the rendered DOM hierarchy,
     * the element will be temporarily removed from its hierarchy and placed in an
     * off-screen buffer for measuring.
     */
    Bounds: Core.extend({

        $static: {
            /**
             * Flag indicating that the dimension of elements should be calculated.
             */
            FLAG_MEASURE_DIMENSION: 0x1,
            
            /**
             * Flag indicating that the position of elements should be calculated.
             */
            FLAG_MEASURE_POSITION: 0x2,
            
            _initMeasureContainer: function() {
                // Create off-screen div element for evaluating sizes.
                this._offscreenDiv = document.createElement("div");
                this._offscreenDiv.style.cssText = 
                        "position: absolute; top: -1300px; left: -1700px; width: 1600px; height: 1200px;";
                document.body.appendChild(this._offscreenDiv);
            }
        },

        /**
         * The width of the element, in pixels.
         * @type Integer
         */
        width: null,
        
        /**
         * The height of the element, in pixels.
         * @type Integer
         */
        height: null,
        
        /**
         * The top coordinate of the element, in pixels relative to the upper-left corner of the interior of the window.
         * @type Integer
         */
        top: null,
         
        /**
         * The left coordinate of the element, in pixels relative to the upper-left corner of the interior of the window.
         * @type Integer
         */
        left: null,

        /**
         * Creates a new Bounds object to calculate the size and/or position of an element.
         * 
         * @param element the element to measure.
         * @param constraints an object containing width and or height properties specifying size of region in which to measure
         *        the element
         * @constructor
         */    
        $construct: function(element, constraints) {
            var flags = (constraints && constraints.flags) || 
                    (Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION | Core.Web.Measure.Bounds.FLAG_MEASURE_POSITION);

            if (element === document.body) {
                return { 
                    x: 0,
                    y: 0,
                    height: window.innerHeight || document.documentElement.clientHeight,
                    width: window.innerWidth || document.documentElement.clientWidth
                };
            }
            
            var testElement = element;
            while (testElement && testElement != document) {
                testElement = testElement.parentNode;
            }
            var rendered = testElement == document;
            
            var parentNode, nextSibling;
            
            if (flags & Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION) {
                if (!rendered) {
                    // Element must be added to off-screen element for measuring.
                    
                    // Store parent node and next sibling such that element may be replaced into proper position
                    // once off-screen measurement has been completed.
                    parentNode = element.parentNode;
                    nextSibling = element.nextSibling;
            
                    // Remove element from parent.
                    if (parentNode) {
                        parentNode.removeChild(element);
                    }
                    
                    if (constraints) {
                        if (constraints.width) {
                            Core.Web.Measure.Bounds._offscreenDiv.width = constraints.width;
                        }
                        if (constraints.height) {
                            Core.Web.Measure.Bounds._offscreenDiv.height = constraints.height;
                        }
                    }
                    
                    // Append element to measuring container DIV.
                    Core.Web.Measure.Bounds._offscreenDiv.appendChild(element);
                    
                    if (constraints) {
                        Core.Web.Measure.Bounds._offscreenDiv.width = "1600px";
                        Core.Web.Measure.Bounds._offscreenDiv.height = "1200px";
                    }
                }
                
                // Store width and height of element.
                this.width = element.offsetWidth;
                this.height = element.offsetHeight;
                
                if (!rendered) {
                    // Replace off-screen measured element in previous location.
                    Core.Web.Measure.Bounds._offscreenDiv.removeChild(element);
                    if (parentNode) {
                        parentNode.insertBefore(element, nextSibling);
                    }
                }
            }

            // Determine top and left positions of element if rendered on-screen.
            if (rendered && (flags & Core.Web.Measure.Bounds.FLAG_MEASURE_POSITION)) {
                var cumulativeOffset = Core.Web.Measure._getCumulativeOffset(element);
                var scrollOffset = Core.Web.Measure._getScrollOffset(element);
        
                this.top = cumulativeOffset.top - scrollOffset.top;
                this.left = cumulativeOffset.left - scrollOffset.left;
            }
        },
        
        /**
         * toString() implementation for debug purposes.
         * 
         * @return a string representation of the object
         * @type String
         */
        toString: function() {
            return (this.left != null ? (this.left + "," + this.top + " : ") : "") + 
                    (this.width != null ? ("[" + this.width + "x" + this.height + "]") : "");
        }
    })
};

/**
 * Scheduler namespace.
 * Provides capability to invoke code at regular intervals, after a delay, 
 * or after the current JavaScript execution context has completed.
 * Provides an object-oriented means of accomplishing this task.
 */
Core.Web.Scheduler = {
    
    /**
     * Collection of runnables to execute.
     */
    _runnables: [],
    
    /**
     * The thread handle returned by setTimeout().
     */ 
    _threadHandle: null,
    
    /**
     * Time at which next execution of the scheduler should occur.
     * When this field is not null, the _threadHandle field contains a
     * timeout scheduled to occur at this time.
     */
    _nextExecution: null,
    
    /**
     * Enqueues a Runnable to be executed by the scheduler.
     * If the runnable is currently enqueued, it will be removed and re-enqueued.  It will be next be invoked
     * after its specified time interval.
     * 
     * @param {Core.Web.Scheduler.Runnable} runnable the runnable to enqueue
     */
    add: function(runnable) {
        Core.Arrays.remove(Core.Web.Scheduler._runnables, runnable);
        runnable._nextExecution = new Date().getTime() + (runnable.timeInterval ? runnable.timeInterval : 0);
        Core.Web.Scheduler._runnables.push(runnable);
        Core.Web.Scheduler._setTimeout(runnable._nextExecution);
    },

    /**
     * Executes the scheduler, running any runnables that are due.
     * DESIGN NOTE: this method MUST ONLY be invoked by the timeout handle Core.Web.Scheduler._threadHandle.
     */
    _execute: function() {
        // Mark now-defunct timeout thread handle as null, because this method was invoked by it.
        Core.Web.Scheduler._threadHandle = null;
        
        var currentTime = new Date().getTime();
        var nextInterval = Number.MAX_VALUE;
        var i, runnable;
        
        // Execute pending runnables.
        for (i = 0; i < Core.Web.Scheduler._runnables.length; ++i) {
            runnable = Core.Web.Scheduler._runnables[i];
            if (runnable && runnable._nextExecution && runnable._nextExecution <= currentTime) {
                runnable._nextExecution = null;
                try {
                    runnable.run();
                } catch (ex) {
                    throw(ex);
                }
            }
        }

        var newRunnables = [];
        for (i = 0; i < Core.Web.Scheduler._runnables.length; ++i) {
            runnable = Core.Web.Scheduler._runnables[i];
            if (runnable == null) {
                continue;
            }

            if (runnable._nextExecution) {
                // Runnable is scheduled for execution: add it to new queue.
                newRunnables.push(runnable);
                
                // Determine time interval of this runnable, if it is the soonest to be executed, use its execution time
                // as the setTimeout delay.
                var interval = runnable._nextExecution - currentTime;
                if (interval < nextInterval) {
                    nextInterval = interval;
                }
                
                // Done processing this runnable.
                continue;
            }
            
            if (runnable.timeInterval != null && runnable.repeat) {
                // Runnable is executed at a repeating interval but is not scheduled: schedule it for execution.
                runnable._nextExecution = currentTime + runnable.timeInterval;
                newRunnables.push(runnable);
                
                // If this is the next runnable to be executed, use its execution time as the setTimeout delay.
                if (runnable.timeInterval < nextInterval) {
                    nextInterval = runnable.timeInterval;
                }
            }
        }
    
        // Store new runnable queue.
        Core.Web.Scheduler._runnables = newRunnables;
        
        if (nextInterval < Number.MAX_VALUE) {
            Core.Web.Scheduler._setTimeout(currentTime + nextInterval);
        }
    },
    
    /**
     * Dequeues a Runnable so it will no longer be executed by the scheduler.
     * 
     * @param {Core.Web.Scheduler.Runnable} runnable the runnable to dequeue
     */
    remove: function(runnable) {
        var index = Core.Arrays.indexOf(Core.Web.Scheduler._runnables, runnable);
        Core.Web.Scheduler._runnables[index] = null;
    },
    
    /**
     * Creates a new Runnable that executes the specified method and enqueues it into the scheduler.
     * 
     * @param {Number} time the time interval, in milliseconds, after which the Runnable should be executed
     *        (may be null/undefined to execute task immediately, in such cases repeat must be false)
     * @param {Boolean} repeat a flag indicating whether the task should be repeated
     * @param f a function to invoke, may be null/undefined
     * @return the created Runnable.
     * @type Core.Web.Scheduler.Runnable 
     */
    run: function(f, timeInterval, repeat) {
        var runnable = new Core.Web.Scheduler.MethodRunnable(f, timeInterval, repeat);
        Core.Web.Scheduler.add(runnable);
        return runnable;
    },
    
    /**
     * Starts the scheduler "thread", to execute at the specified time.
     * If the specified time is in the past, it will execute with a delay of 0.
     * 
     * @param {Number} nextExecution next execution time (milliseconds since epoch)
     */
    _setTimeout: function(nextExecution) {
        if (Core.Web.Scheduler._threadHandle != null && Core.Web.Scheduler._nextExecution < nextExecution) {
            // The current timeout will fire before nextExecution, thus no work needs to be done here.
            return;
        }
        
        if (Core.Web.Scheduler._threadHandle != null) {
            // Clear any existing timeout.
            window.clearTimeout(Core.Web.Scheduler._threadHandle);
        }
        
        var currentTime = new Date().getTime();
        Core.Web.Scheduler._nextExecution = nextExecution;
        var timeout = nextExecution - currentTime > 0 ? nextExecution - currentTime : 0;
        Core.Web.Scheduler._threadHandle = window.setTimeout(Core.Web.Scheduler._execute, timeout);
    },
    
    /**
     * Updates a previously added runnable to be executed based on its <code>timeInterval</code> setting.
     * Performs no action if specified runnable is not currently enqueued.
     * 
     * @param {Core.Web.Scheduler.Runnable} runnable the runnable to update
     */
    update: function(runnable) {
        if (Core.Arrays.indexOf(Core.Web.Scheduler._runnables, runnable) == -1) {
            return;
        }
        var currentTime = new Date().getTime();
        var timeInterval = runnable.timeInterval ? runnable.timeInterval : 0;
        runnable._nextExecution = currentTime + timeInterval;
        Core.Web.Scheduler._setTimeout(runnable._nextExecution);
    }
};

/**
 * A runnable task that may be scheduled with the Scheduler.
 */
Core.Web.Scheduler.Runnable = Core.extend({
    
    /** Next execution time (milliseconds since epoch) */
    _nextExecution: null,
    
    $virtual: {

        /** 
         * Time interval, in milliseconds after which the Runnable should be executed.
         * @type Number
         */
        timeInterval: null,
        
        /**
         * Flag indicating whether task should be repeated.
         * @type Boolean
         */
        repeat: false
    },

    $abstract: {
        
        /** Performs work, provided by derived object. */
        run: function() { }
    }
});

/**
 * A runnable task implementation that invokes a function at regular intervals.
 */
Core.Web.Scheduler.MethodRunnable = Core.extend(Core.Web.Scheduler.Runnable, {

    /**
     * The function to invoke.
     * @type Function
     */
    f: null,

    /**
     * Creates a new Runnable.
     *
     * @constructor
     * @param {Number} time the time interval, in milliseconds, after which the Runnable should be executed
     *        (may be null/undefined to execute task immediately, in such cases repeat must be false)
     * @param {Boolean} repeat a flag indicating whether the task should be repeated
     * @param {Function} f a function to invoke, may be null/undefined
     */
    $construct: function(f, timeInterval, repeat) {
        if (!timeInterval && repeat) {
            throw new Error("Cannot create repeating runnable without time delay:" + f);
        }
        this.f = f;
        this.timeInterval = timeInterval;
        this.repeat = !!repeat;
    },

    $virtual: {
        
        /**
         * Default run() implementation. Should be overridden by subclasses.
         */
        run: function() {
            this.f();
        }
    }
});

/**
 * Static object/namespace which provides cross-platform CSS positioning 
 * capabilities. Do not instantiate.
 * <p>
 * Internet Explorer 6 is ordinarily handicapped by its lack
 * of support for setting 'left' and 'right' or 'top' and 'bottom' positions
 * simultaneously on a single document element.
 * <p> 
 * To use virtual positioning, simply set the left/right/top/bottom
 * coordinates of an element and invoke redraw().  The redraw() method
 * must be invoked whenever the size of the element should be redrawn,
 * e.g., when the screen or its containing element resizes.
 * @class
 */
Core.Web.VirtualPosition = {

    /** Array containing vertical offset attributes to be added to calculation. */ 
    _OFFSETS_VERTICAL: ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"],
            
    /** Array containing horizontal offset attributes to be added to calculation. */ 
    _OFFSETS_HORIZONTAL: ["paddingLeft", "paddingRight", "marginLeft", "marginRight", "borderLeftWidth", "borderRightWidth"],
    
    /** Flag indicating whether virtual positioning is required/enabled. */
    enabled: false,
    
    /**
     * Calculates horizontal or vertical padding, border, and margin offsets for a particular style.
     *
     * @param offsetNames the names of the offsets styles to calculate, either
     *        _OFFSETS_VERTICAL or _OFFSETS_HORIZONTAL.
     * @param style the style whose offsets should be calculated
     * @return the pixel size of the offsets, or -1 if they cannot be calculated
     */
    _calculateOffsets: function(offsetNames, style) {
        var offsets = 0;
        for (var i = 0; i < offsetNames.length; ++i) {
            var value = style[offsetNames[i]];
            if (value) {
                if (value.toString().indexOf("px") == -1) {
                    return -1;
                }
                offsets += parseInt(value, 10);
            }
        }
        return offsets;
    },
    
    /**
     * Enables and initializes the virtual positioning system.
     */
    _init: function() {
        this.enabled = true;
    },
    
    /**
     * Redraws elements registered with the virtual positioning system.
     * Adjusts the style.height and style.width attributes of an element to 
     * simulate its specified top, bottom, left, and right CSS position settings
     * The calculation makes allowances for padding, margin, and border width.
     *
     * @param element the element to redraw
     */
    redraw: function(element) {
        if (!this.enabled) {
            return;
        }
    
        if (!element || !element.parentNode) {
            return;
        }
        
        var offsets;
    
        // Adjust 'height' property if 'top' and 'bottom' properties are set, 
        // and if all padding/margin/borders are 0 or set in pixel units.
        if (this._verifyPixelValue(element.style.top) && this._verifyPixelValue(element.style.bottom)) {
            // Verify that offsetHeight is valid, and do nothing if it cannot be calculated.
            // Such a do-nothing scenario is due to a not-up-to-date element cache,  where
            // the element is no longer hierarchy.
            var offsetHeight = element.parentNode.offsetHeight;
            if (!isNaN(offsetHeight)) {
                offsets = this._calculateOffsets(this._OFFSETS_VERTICAL, element.style);
                if (offsets != -1) {
                    var calculatedHeight = offsetHeight - parseInt(element.style.top, 10) - 
                            parseInt(element.style.bottom, 10) - offsets;
                    if (calculatedHeight <= 0) {
                        element.style.height = 0;
                    } else {
                        if (element.style.height != calculatedHeight + "px") {
                            element.style.height = calculatedHeight + "px";
                        }
                    }
                }
            }
        }
        
        // Adjust 'width' property if 'left' and 'right' properties are set, 
        // and if all padding/margin/borders are 0 or set in pixel units.
        if (this._verifyPixelValue(element.style.left) && this._verifyPixelValue(element.style.right)) {
            // Verify that offsetHeight is valid, and do nothing if it cannot be calculated.
            // Such a do-nothing scenario is due to a not-up-to-date element cache,  where
            // the element is no longer hierarchy.
            var offsetWidth = element.parentNode.offsetWidth;
            if (!isNaN(offsetWidth)) {
                offsets = this._calculateOffsets(this._OFFSETS_HORIZONTAL, element.style);
                if (offsets != -1) {
                    var calculatedWidth = offsetWidth - parseInt(element.style.left, 10) - 
                            parseInt(element.style.right, 10) - offsets;
                    if (calculatedWidth <= 0) {
                        element.style.width = 0;
                    } else {
                        if (element.style.width != calculatedWidth + "px") {
                            element.style.width = calculatedWidth + "px";
                        }
                    }
                }
            }
        }
    },
    
    /** 
     * Determines if the specified value contains a pixel dimension, e.g., "20px"
     * Returns false if the value is null/whitespace/undefined.
     *
     * @param value the value to evaluate
     * @return true if the value is a pixel dimension, false if it is not
     */
    _verifyPixelValue: function(value) {
        if (value == null || value === "") {
            return false;
        }
        var valueString = value.toString();
        return valueString == "0" || valueString.indexOf("px") != -1;
    }
};
/**
 * @fileoverview
 * Application framework main module.
 * Requires Core.
 */

/**
 * Main namespace of Echo framework.
 * @namespace
 */
Echo = { };

/**
 * Representation of a single application instance.
 * Derived objects must invoke constructor with root component id.
 * 
 * @event componentUpdate An event fired when any component within the application is updated.
 *        Listening for this event may degrade the performance of an application, due to the
 *        frequency with which it will be fired.
 * @event focus An event fired when the focused component of the application changes.
 * @event modal An event fired when the modal state of the application changes.
 */
Echo.Application = Core.extend({
    
    $static: {

        /**
         * Next unique identifier.
         */
        _nextUid: 1,
    
        /**
         * Generates a unique identifier.  Identifiers are unique for the duration of the existence of this namespace.
         */
        generateUid: function() {
            return this._nextUid++;
        }
    },
    
    $abstract: true,
    
    $virtual: {
    
        /**
         * Performs application initialization operations.  This method should be provided by an application implementation
         * if required.  The superclass' <code>init()</code> method should always be invoked out of convention.
         * The <code>client</code> property will be available. 
         */
        init: function() { },
        
        /**
         * Performs application disposal/resource cleanup operations. This method should be provided by an application
         * implementation if required. The superclass' <code>dispose()</code> method should always be invoked out of convention.
         * The <code>client</code> property will be available.
         */
        dispose: function() { },
        
        /**
         * Returns the active state of the application.
         * 
         * @return the active state of the application, a value of 
         *         true indicating the application is ready for user
         *         input, a value of false indicating otherwise
         * @type Boolean
         */
        isActive: function() {
            return true;
        }
    },
    
    /**
     * The client engine hosting the application.  
     * This property is provided solely for use by the application itself, it is not (and may not be) used internally for any
     * purpose. 
     * @type Object
     */
    client: null,

    /** 
     * Mapping between component ids and component instances.
     * @type Core.Arrays.LargeMap
     */
    _idToComponentMap: null,

    /** 
     * ListenerList instance for application-level events.
     * @type Core.ListenerList 
     */
    _listenerList: null,
    
    /** 
     * Default application locale.
     * @type String
     */
    _locale: null,
        
    /** 
     * Array of modal components.
     * This value is read-only.
     * @type Array 
     */
    _modalComponents: null,

    /** 
     * Displayed style sheet.
     * 
     * @type Echo.StyleSheet
     */
    _styleSheet: null,
    
    /** 
     * Currently focused component.
     * @type Echo.Component
     */
    _focusedComponent: null,
    
    /** 
     * Root component instance.
     * This value is read-only.
     * @type Echo.Component 
     */
    rootComponent: null,
    
    /** 
     * UpdateManager instance monitoring changes to the application for redraws. 
     * @type Echo.Update.Manager
     */
    updateManager: null,
    
    /**
     * FocusManager instance handling application focus behavior.
     * @type Echo.FocusManager
     */
    focusManager: null,
    
    /**
     * Creates a new application instance.  
     * @constructor
     */
    $construct: function() {
        this._idToComponentMap = new Core.Arrays.LargeMap();
        this._listenerList = new Core.ListenerList();
        this.rootComponent = new Echo.Component();
        this.rootComponent.componentType = "Root";
        this.rootComponent.register(this);
        this._modalComponents = [];
        this.updateManager = new Echo.Update.Manager(this);
        this.focusManager = new Echo.FocusManager(this);
    },

    /**
     * Adds an arbitrary event listener.
     * 
     * @param {String} eventType the event type name
     * @param {Function} eventTarget the method to invoke when the event occurs 
     *        (the event will be passed as the single argument)
     */
    addListener: function(eventType, eventTarget) {
        this._listenerList.addListener(eventType, eventTarget);
    },
    
    /**
     * Invoked by application container to dispose of the application.
     * Invokes application-overridable <code>dispose()</code> method.
     * Once invoked, the application will no longer function and cannot be used again.
     * This method will free any resources allocated by the application.
     */ 
    doDispose: function() {
        this.updateManager.dispose();
        this.dispose();
    },
    
    /**
     * Invoked by application container to initialize of the application.
     * Invokes application-overridable <code>init()</code> method.
     */ 
    doInit: function() {
        this.init();
    },
    
    /**
     * Recursively determines the current root component of the modal context.
     *
     * @param {Echo.Component} searchComponent (optional) the component from which to search
     *        (this parameter is provided when recursively searching, if omitted the sear
     *        will begin at the root component of the application).
     * @return the current modal context root component
     */
    _findModalContextRoot: function(searchComponent) {
        searchComponent = searchComponent ? searchComponent : this.rootComponent;
        for (var i = searchComponent.children.length - 1; i >= 0; --i) {
            var foundComponent = this._findModalContextRoot(searchComponent.children[i]);
            if (foundComponent) {
                return foundComponent;
            }
        }
        
        if (searchComponent.modalSupport && searchComponent.get("modal")) {
            return searchComponent;
        }
        
        return null;
    },

    /**
     * Provides notification of an arbitrary event.
     * Listeners will be notified based on the event's type property.
     * 
     * @param event the event to fire
     */
    fireEvent: function(event) {
        if (this._listenerList == null) {
            return;
        }
        this._listenerList.fireEvent(event);
    },

    /**
     * Focuses the previous/next component based on the currently focused component.
     * 
     * @param {Boolean} reverse false to focus the next component, true to focus the
     *        previous component
     */
    focusNext: function(reverse) {
        var focusedComponent = this.focusManager.find(null, reverse);
        if (focusedComponent != null) {
            this.setFocusedComponent(focusedComponent);
        }
    },
    
    /**
     * Retrieves the registered component with the specified render id.
     * 
     * @param {String} renderId the render id
     * @return the component
     * @type Echo.Component 
     */
    getComponentByRenderId: function(renderId) {
        return this._idToComponentMap.map[renderId];
    },
    
    /**
     * Returns the focused component.
     * 
     * @return the focused component
     * @type Echo.Component
     */
    getFocusedComponent: function() {
        return this._focusedComponent;
    },
    
    /**
     * Returns the default layout direction of the application.
     *
     * @return the default layout direction
     * @type Echo.LayoutDirection 
     */
    getLayoutDirection: function() {
        return this._layoutDirection ? this._layoutDirection : Echo.LayoutDirection.LTR;
    },
        
    /**
     * Returns the default locale of the application.
     *
     * @return the default locale
     * @type String 
     */
    getLocale: function() {
        return this._locale;
    },
        
    /**
     * Returns the root component of the modal context.
     *
     * @return the root component of the modal context
     * @type Echo.Component
     */
    getModalContextRoot: function() {
        if (this._modalComponents.length === 0) {
            return null;
        } else if (this._modalComponents.length == 1) {
            return this._modalComponents[0];
        }
        
        return this._findModalContextRoot();
    },
    
    /**
     * Returns the application style sheet.
     * 
     * @return the application style sheet
     * @type Echo.StyleSheet
     */
    getStyleSheet: function() {
        return this._styleSheet;
    },
    
    /**
     * Notifies the application of an update to a component.
     * Fires a <code>componentUpdate</code> event.
     * 
     * @param {Echo.Component} parent the parent component
     * @param {String} propertyName the updated property
     * @param oldValue the previous property value
     * @param newValue the new property value
     * @param rendered optional flag indicating whether the update has already been rendered by the containing client; 
     *        if enabled, the property update will not be sent to the update manager
     */
    notifyComponentUpdate: function(parent, propertyName, oldValue, newValue, rendered) {
        if (parent.modalSupport && propertyName == "modal") {
            this._setModal(parent, newValue);
        }
        if (this._listenerList.hasListeners("componentUpdate")) {
            this._listenerList.fireEvent({type: "componentUpdate", parent: parent, propertyName: propertyName, 
                    oldValue: oldValue, newValue: newValue});
        }
        if (!rendered) {
            this.updateManager._processComponentUpdate(parent, propertyName, oldValue, newValue);
        }
    },
    
    /**
     * Registers a component with the application.
     * Invoked when a component is added to a hierarchy of 
     * components that is registered with the application.
     * 
     * @param {Echo.Component} component the component to register
     */
    _registerComponent: function(component) {
        if (this._idToComponentMap.map[component.renderId]) {
            throw new Error("Component already exists with id: " + component.renderId);
        }
        this._idToComponentMap.map[component.renderId] = component;
        if (component.modalSupport && component.get("modal")) {
            this._setModal(component, true);
        }
    },
    
    /**
     * Removes an arbitrary event listener.
     * 
     * @param {String} eventType the event type name
     * @param {Function} eventTarget the method to invoke when the event occurs 
     *        (the event will be passed as the single argument)
     */
    removeListener: function(eventType, eventTarget) {
        this._listenerList.removeListener(eventType, eventTarget);
    },

    /**
     * Sets the focused component.
     * A "focus" event is fired to application listeners to inform them of the change.
     * 
     * @param {Echo.Component} newValue the new focused component
     */
    setFocusedComponent: function(newValue) {
        var oldValue = this._focusedComponent;
        
        // If required, find focusable parent containing 'newValue'.
        while (newValue != null && !newValue.focusable) {
            newValue = newValue.parent;
        }
        
        // Verify new focused component is within modal context.
        if (this._modalComponents.length > 0) {
            var modalContextRoot = this.getModalContextRoot();
            if (!modalContextRoot.isAncestorOf(newValue)) {
                // Reject request to focus component outside of modal context.
                return;
            }
        }
        
        if (this._focusedComponent == newValue) {
            return;
        }
        
        this._focusedComponent = newValue;
        this._listenerList.fireEvent({type: "focus", source: this, oldValue: oldValue, newValue: newValue });
    },
    
    /**
     * Sets the application default layout direction.
     * 
     * @param {Echo.LayoutDirection} newValue the new layout direction
     */
    setLayoutDirection: function(newValue) {
        this._layoutDirection = newValue;
        this.updateManager._processFullRefresh();
    },
    
    /**
     * Sets the application default locale.
     * 
     * @param {String} newValue the new locale
     */
    setLocale: function(newValue) {
        this._locale = newValue;
        this.updateManager._processFullRefresh();
    },
    
    /**
     * Informs the application of the modal state of a specific component.
     * When modal components are unregistered, this method must be executed
     * in order to avoid a memory leak.
     * 
     * @param component the component
     * @param modal the modal state
     */
    _setModal: function(component, modal) {
        Core.Arrays.remove(this._modalComponents, component);
        if (modal) {
            this._modalComponents.push(component);
        }
        
        // Auto-focus first component in modal context if component is currently focused component is not within modal context.
        if (this._modalComponents.length > 0 && this._focusedComponent) {
            var modalContextRoot = this.getModalContextRoot();
            if (!modalContextRoot.isAncestorOf(this._focusedComponent)) {
                if (modalContextRoot.focusable) {
                    this.setFocusedComponent(modalContextRoot);
                } else {
                    this.setFocusedComponent(this.focusManager.findInParent(modalContextRoot, false));
                }
            }
        }
        
        this.fireEvent({ source: this, type: "modal", modal: this._modalComponents.length > 0 });
    },
    
    /**
     * Sets the application style sheet.
     * 
     * @param {Echo.StyleSheet} newValue the new style sheet
     */
    setStyleSheet: function(newValue) {
        this._styleSheet = newValue;
        this.updateManager._processFullRefresh();
    },
    
    /**
     * Unregisters a component from the application.
     * This method is invoked when a component is removed from a hierarchy of 
     * components registered with the application.
     * 
     * @param {Echo.Component} component the component to remove
     */
    _unregisterComponent: function(component) {
        this._idToComponentMap.remove(component.renderId);
        if (component.modalSupport) {
            this._setModal(component, false);
        }
    }
});

/**
 * Factory to create new instances of arbitrary components.  This object is 
 * used to instantiate new components during XML de-serialization.
 * @class
 */
Echo.ComponentFactory = {
    
    /**
     * Mapping between type names and object constructors.
     */
    _typeToConstructorMap: {},
    
    /**
     * Creates a new instance of an arbitrary component.
     * 
     * @param {String} typeName the type name of the component
     * @param {String} renderId the component render id
     * @return a newly instantiated component
     * @type Echo.Component
     */
    newInstance: function(typeName, renderId) {
        var typeConstructor = this._typeToConstructorMap[typeName];
        if (!typeConstructor) {
            throw new Error("Type not registered with ComponentFactory: " + typeName);
        }
        var component = new typeConstructor();
        component.renderId = renderId;
        return component;
    },
    
    /**
     * Returns the component constructor for the specified type.
     *
     * @param {String} typeName the type name
     * @return the component constructor
     * @type Function
     */
    getConstructor: function(typeName) {
        return this._typeToConstructorMap[typeName];
    },
    
    /**
     * Determines the super type of a component, based on the type name of the component.
     *
     * @param {String} typeName the component type
     * @return the parent component type
     * @type String
     */
    getSuperType: function(typeName) {
        var typeConstructor = this._typeToConstructorMap[typeName];
        if (!typeConstructor) {
            // Type not registered, return Component base class name.
            return "Component";
        }
        if (typeConstructor.$super) {
            return typeConstructor.$super.prototype.componentType;
        } else {
            return null;
        }
    },
    
    /**
     * Registers a type name to a specific constructor.
     * 
     * @param typeName the type name
     * @param typeConstructor the constructor
     */
    registerType: function(typeName, typeConstructor) {
        if (this._typeToConstructorMap[typeName]) {
            throw new Error("Type already registered: " + typeName);
        }
        this._typeToConstructorMap[typeName] = typeConstructor;
    }
};

/**
 * Base class for components.
 * Derived classes should wishing to support hierarchal construction should provide constructors
 * with a first parameter name of 'properties' which is passed to the super-constructor.
 * In any case, the super-constructor must be invoked.
 * A component MUST have its componentType property set before it is used in a hierarchy.  Failing to do so
 * will throw an exception and/or result in indeterminate behavior.
 *
 * @sp {#Color} background the background color
 * @sp {#Font} font the component font
 * @sp {#Color} foreground the foreground color
 * @sp layoutData layout data information, describing how the component should be rendered by its container 
 * @event property An event fired when the a property of the component changes.  The <code>propertyName</code> property
 *        will specify the name of the changed property.  The <code>oldValue</code> and <code>newValue</code> properties
 *        (may) describe the previous and current states of the property, respectively.
 * @event init An event which is fired when the Component is added to a component hierarchy which is registered to an
 *        application.  The "application" property of the Component will be available when the event is fired.
 * @event dispose An event which is fired when the Component is about to be removed from a component hierarchy which is
 *        registered to an application.  The "application" property of the Component will be available when the event is fired.
 * @event parent An event which is fired when the Component's parent is changed.
 * @event children An event which is fired when a child is added to or removed from the Component.
 */
Echo.Component = Core.extend({
    
    $static: {

        /**
         * The next automatically assigned client render id.
         * @type Number
         */
        _nextRenderId: 0
    },
    
    $load: function() {
        Echo.ComponentFactory.registerType("Component", this);
    },

    $abstract: true,
    
    $virtual: {
    
        /**
         * Component type.  
         * This value should be the fully-qualified name of the component, e.g. "Foo.ExampleComponent".
         * This property must be set by implementors in order for peer discovery to work properly.
         * @type String
         */
        componentType: "Component",
        
        /** 
         * Flag indicating whether or not the component is focusable.
         * @type Boolean 
         */
        focusable: false,

        /**
         * Returns the child component at the specified index after sorting the
         * children in the order which they should be focused. The default
         * implementation simply returns the same value as getComponent().
         * Implementations should override this method when the natural order to
         * focus child components is different than their normal ordering (e.g.,
         * when the component at index 1 is positioned above the component at
         * index 0).
         * 
         * @param {Number} index the index of the child (in focus order)
         * @return the child component
         * @type Echo.Component
         */
        getFocusComponent: function(index) {
            return this.children[index];
        },
        
        /**
         *  Flag indicating whether component is rendered as a pane (pane components consume available height).
         *  @type Boolean 
         */
        pane: false
    },
    
    /**
     * Component layout direction.
     * @type Echo.LayoutDirection
     */
    _layoutDirection: null,
    
    /**
     * Component locale.
     * @type String
     */
    _locale: null,

    /**
     * The render id.
     * This value should be treated as read-only and immutable.
     * @type String
     */
    renderId: null,
    
    /**
     * The parent component.
     * This value is read-only.
     * @type Echo.Component
     */
    parent: null,
    
    /**
     * The registered application.
     * This value is read-only.
     * @type Echo.Application
     */
    application: null,
    
    /**
     * Listener list.  Lazily created.
     * @type Core.ListenerList
     */
    _listenerList: null,
    
    /**
     * Referenced external style
     */
    _style: null,
    
    /**
     * Assigned style name from application-level style sheet.
     * @type String
     */
    _styleName: null,

    /**
     * Enabled state of the component (default true).
     * @type Boolean
     */
    _enabled: true,
    
    /**
     * Array of child components.
     * This value is read-only.  Modifying this array will result in undefined behavior.
     * @type Array
     */
    children: null,
    
    /**
     * renderId of application-set next focusable component.
     * @type String 
     */
    focusNextId: null,
    
    /**
     * renderId of application-set previous focusable component.
     * @type String 
     */
    focusPreviousId: null,
    
    /**
     * Internal style used to store properties set directly on component.
     */
    _localStyle: null,
    
    /**
     * Creates a new Component.
     * The parent constructor MUST be invoked if it is overridden.  This is accomplished by including the statement
     * "BaseComponent.call(this, properties)" in any derivative constructor, where "BaseComponent" is
     * class from which the component is immediately derived (which may or may not be Echo.Component itself).
     *  
     * @param properties (Optional) associative mapping of initial property values (may be null)
     *        By default, all properties will be placed into the local style, except for the following:
     *        <ul>
     *         <li><code>styleName</code> specifies the component stylesheet style name</li>
     *         <li><code>style</code> specifies the referenced component style</li>
     *         <li><code>renderId</code> specifies the render id</li>
     *         <li><code>children</code> an array specifying the initial children of the component</li>
     *         <li><code>events</code> an associative mapping between event names and listener methods</li>
     *        </ul>
     */
    $construct: function(properties) {
        this.children = [];
        this._localStyle = { };
        
        if (properties) {
            for (var name in properties) {
                switch (name) {
                case "style": this._style = properties.style; break;
                case "styleName": this._styleName = properties.styleName; break;
                case "renderId": this.renderId = properties.renderId; break;
                case "children":
                    for (var i = 0; i < properties.children.length; ++i) {
                        this.add(properties.children[i]);
                    }
                    break;
                case "events":
                    for (var eventType in properties.events) {
                        this.addListener(eventType, properties.events[eventType]);
                    }
                    break;
                default:
                    this._localStyle[name] = properties[name];
                }
            }
        }
    },

    /**
     * Adds a component as a child.
     * 
     * @param {Echo.Component} component the component to add
     * @param {Number} index the (integer) index at which to add it (optional, omission
     *        will cause component to be appended to end)
     */
    add: function(component, index) {
        if (!(component instanceof Echo.Component)) {
            throw new Error("Cannot add child: specified component object is not derived from Echo.Component. " +
                    "Parent: " + this + ", Child: " + component);
        }
        if (!component.componentType) {
            throw new Error("Cannot add child: specified component object does not have a componentType property. " +
                    "Parent: " + this + ", Child: " + component);
        }
    
        if (component.parent) {
            component.parent.remove(component);
        }
        
        component.parent = this;
            
        if (index == null || index == this.children.length) {
            this.children.push(component);
        } else {
            this.children.splice(index, 0, component);
        }
        
        if (this.application) {
            component.register(this.application);
            this.application.notifyComponentUpdate(this, "children", null, component);
        }
        
        if (component._listenerList && component._listenerList.hasListeners("parent")) {
            component._listenerList.fireEvent({type: "parent", source: component, oldValue: null, newValue: this});
        }

        if (this._listenerList && this._listenerList.hasListeners("children")) {
            this._listenerList.fireEvent({type: "children", source: this, add: component, index: index});
        }
    },
    
    /**
     * Adds an arbitrary event listener.
     * 
     * @param {String} eventType the event type name
     * @param {Function} eventTarget the method to invoke when the event occurs 
     *        (the event will be passed as the single argument)
     */
    addListener: function(eventType, eventTarget) {
        if (this._listenerList == null) {
            this._listenerList = new Core.ListenerList();
        }
        this._listenerList.addListener(eventType, eventTarget);
        if (this.application) {
            this.application.notifyComponentUpdate(this, "listeners", null, eventType);
        }
    },
    
    /**
     * Provides notification of an arbitrary event.
     * Listeners will be notified based on the event's type property.
     * 
     * @param event the event to fire
     */
    fireEvent: function(event) {
        if (this._listenerList == null) {
            return;
        }
        this._listenerList.fireEvent(event);
    },
    
    /**
     * Returns an arbitrary property value.
     * 
     * @param {String} name the name of the property
     * @return the property value
     */
    get: function(name) {
        return this._localStyle[name];
    },
    
    /**
     * Retrieves the child component at the specified index.
     * 
     * @param {Number} index the (integer) index
     * @return the child component
     * @type Echo.Component
     */
    getComponent: function(index) {
        return this.children[index];
    },
    
    /**
     * Returns the number of child components.
     * 
     * @return the number of child components
     * @type Number
     */
    getComponentCount: function() {
        return this.children.length;
    },
    
    /**
     * Returns an arbitrary indexed property value.
     * 
     * @param {String} name the name of the property
     * @param {Number} index the index to return
     * @return the property value
     */
    getIndex: function(name, index) {
        var valueArray = this._localStyle[name];
        return valueArray ? valueArray[index] : null;
    },
    
    /**
     * Returns the component layout direction.
     * Note that in most cases it is preferable to set the layout direction of the Application, rather than individual components.
     * 
     * @return the component layout direction
     * @type Echo.LayoutDirection
     */
    getLayoutDirection: function() {
        return this._layoutDirection;
    },
    
    /**
     * Returns the component locale.
     * Note that in most cases it is preferable to set the locale of the Application, rather than individual components.
     * 
     * @return the component locale
     * @type String
     */
    getLocale: function() {
        return this._locale;
    },
    
    /**
     * Retrieves local style property map associations.  This method should only be used by a de-serialized for
     * the purpose of rapidly loading properties into a new component.
     * 
     * @return the internal style property map associations
     */
    getLocalStyleData: function() {
        return this._localStyle;
    },
    
    /**
     * Returns the layout direction with which the component should be rendered, based on analyzing the component's layout 
     * direction, its parent's, and/or the application's.
     * 
     * @return the rendering layout direction
     * @type Echo.LayoutDirection
     */
    getRenderLayoutDirection: function() {
        var component = this;
        while (component) {
            if (component._layoutDirection) {
                return component._layoutDirection;
            }
            component = component.parent;
        }
        if (this.application) {
            return this.application.getLayoutDirection();
        }
        return null;
    },
    
    /**
     * Returns the locale  with which the component should be rendered, based on analyzing the component's locale,
     * its parent's, and/or the application's.
     * 
     * @return the rendering locale
     * @type String
     */
    getRenderLocale: function() {
        var component = this;
        while (component) {
            if (component._locale) {
                return component._locale;
            }
            component = component.parent;
        }
        if (this.application) {
            return this.application.getLocale();
        }
        return null;
    },
    
    /**
     * Returns the style assigned to this component, if any.
     * 
     * @return the assigned style
     */
    getStyle: function() {
        return this._style;
    },
    
    /**
     * Returns the name of the style (from the application's style sheet) 
     * assigned to this component.
     * 
     * @return the style name
     * @type String
     */
    getStyleName: function() {
        return this._styleName;
    },
    
    /**
     * Returns the index of a child component, or -1 if the component
     * is not a child.
     * 
     * @param {Echo.Component} component the component
     * @return the index
     * @type Number
     */
    indexOf: function(component) {
        for (var i = 0; i < this.children.length; ++i) {
            if (this.children[i] == component) {
                return i;
            }
        }
        return -1;
    },
    
    /**
     * Determines if the component is active, that is, within the current modal context
     * and ready to receive input.
     * 
     * @return the active state
     * @type Boolean
     */
    isActive: function() {
        // Verify the component and its ancestors are all enabled.
        if (!this.isRenderEnabled()) {
            return false;
        }
        
        // Verify component is registered to an application, and that the application is active.
        if (!this.application || !this.application.isActive()) {
            return false;
        }
        
        // Verify component is in modal context.
        var modalContextRoot = this.application.getModalContextRoot();
        if (modalContextRoot != null && !modalContextRoot.isAncestorOf(this)) {
            return false;
        }
        
        return true;
    },
    
    /**
     * Determines if this component is or is an ancestor of another component.
     * 
     * @param {Echo.Component} c the component to test
     * @return true if an ancestor relationship exists
     * @type Boolean
     */
    isAncestorOf: function(c) {
        while (c != null && c != this) {
            c = c.parent;
        }
        return c == this;
    },
    
    /**
     * Determines the enabled state of this component.
     * Use isRenderEnabled() to determine whether a component should be rendered as enabled.
     * 
     * @return the enabled state of this specific component
     */
    isEnabled: function() {
        return this._enabled;
    },
    
    /**
     * Determines whether this <code>Component</code> should be rendered with
     * an enabled state.
     * Disabled <code>Component</code>s are not eligible to receive user input.
     * 
     * @return true if the component should be rendered enabled
     * @type Boolean
     */
    isRenderEnabled: function() {
        var component = this;
        while (component != null) {
            if (!component._enabled) {
                return false;
            }
            component = component.parent;
        }
        return true;
    },
    
    /**
     * Registers / unregisters a component that has been added/removed to/from a registered hierarchy
     * (a hierarchy that is registered to an application).
     * 
     * @param {Echo.Application} application the application (null to unregister the component)
     */
    register: function(application) {
        // Sanity check.
        if (application && this.application) {
            throw new Error("Attempt to re-register or change registered application of component.");
        }
        
        var i;
    
        if (!application) { // unregistering
            // Recursively unregister children.
            if (this.children != null) {
                for (i = 0; i < this.children.length; ++i) {
                     this.children[i].register(false); // Recursively unregister children.
                }
            }
            
            // Notify application.
            this.application._unregisterComponent(this);

            // Change application focus in the event the focused component is being removed.
            // Note that this is performed after de-registration to ensure any removed modal context is cleared.
            if (this.application._focusedComponent == this) {
                this.application.setFocusedComponent(this.parent);
            }

            // Notify dispose listeners.
            if (this._listenerList != null && this._listenerList.hasListeners("dispose")) {
                this._listenerList.fireEvent({ type: "dispose", source: this });
            }
        }
    
        // Link/unlink with application.
        this.application = application;
    
        if (application) { // registering
            // Assign render id if required.
            if (this.renderId == null) {
                this.renderId = "CL." + (++Echo.Component._nextRenderId);
            }
    
            // Notify application.
            this.application._registerComponent(this);
            
            // Notify init listeners.
            if (this._listenerList != null && this._listenerList.hasListeners("init")) {
                this._listenerList.fireEvent({ type: "init", source: this });
            }

            // Recursively register children.
            if (this.children != null) {
                for (i = 0; i < this.children.length; ++i) {
                     this.children[i].register(application); // Recursively unregister children.
                }
            }
        }
    },
    
    /**
     * Returns the value of a property that should be rendered,
     * based on the value set on this component, in the component's
     * specified style, and/or in the application's stylesheet.
     * 
     * @param {String} name the name of the property
     * @param defaultValue the default value to return if no value is 
     *        specified in an internal property, style, or stylesheet
     * @return the property value
     */
    render: function(name, defaultValue) {
        var value = this._localStyle[name];
        if (value == null) {
            if (this._style != null) {
                value = this._style[name];
            }
            if (value == null && this.application && this.application._styleSheet) {
                var style = this.application._styleSheet.getRenderStyle(
                        this._styleName != null ? this._styleName : "", this.componentType);
                if (style) {
                    value = style[name];
                }
            }
        }
        return value == null ? defaultValue : value;
    },
    
    /**
     * Returns the value of an indexed property that should be rendered,
     * based on the value set on this component, in the component's
     * specified style, and/or in the application's stylesheet.
     * 
     * @param {String} name the name of the property
     * @param {Number} index the (integer) index of the property
     * @param defaultValue the default value to return if no value is 
     *        specified in an internal property, style, or stylesheet
     * @return the property value
     */
    renderIndex: function(name, index, defaultValue) {
        var valueArray = this._localStyle[name];
        var value = valueArray ? valueArray[index] : null;
        if (value == null) {
            if (this._style != null) {
                valueArray = this._style[name];
                value = valueArray ? valueArray[index] : null;
            }
            if (value == null && this._styleName && this.application && this.application._styleSheet) {
                var style = this.application._styleSheet.getRenderStyle(
                        this._styleName != null ? this._styleName : "", this.componentType);
                if (style) {
                    valueArray = style[name];
                    value = valueArray ? valueArray[index] : null;
                }
            }
        }
        return value == null ? defaultValue : value;
    },
    
    /**
     * Removes a child component.
     * 
     * @param componentOrIndex the index of the component to remove, or the component to remove
     *        (values may be of type Echo.Component or Number)
     */
    remove: function(componentOrIndex) {
        var component;
        var index;
        if (typeof componentOrIndex == "number") {
            index = componentOrIndex;
            component = this.children[index];
            if (!component) {
                throw new Error("Component.remove(): index out of bounds: " + index + ", parent: " + this);
            }
        } else {
            component = componentOrIndex;
            index = this.indexOf(component);
            if (index == -1) {
                // Component is not a child: do nothing.
                return;
            }
        }
        
        if (this.application) {
            component.register(null);
        }
        
        this.children.splice(index, 1);
        component.parent = null;
        
        if (this.application) {
            this.application.notifyComponentUpdate(this, "children", component, null);
        }
        
        if (component._listenerList && component._listenerList.hasListeners("parent")) {
            component._listenerList.fireEvent({type: "parent", source: component, oldValue: this, newValue: null});
        }

        if (this._listenerList && this._listenerList.hasListeners("children")) {
            this._listenerList.fireEvent({type: "children", source: this, remove: component, index: index});
        }
    },
    
    /**
     * Removes all child components.
     */
    removeAll: function() {
        while (this.children.length > 0) {
            this.remove(this.children.length - 1);
        }
    },
    
    /**
     * Removes an arbitrary event listener.
     * 
     * @param {String} eventType the event type name
     * @param {Function} eventTarget the method to invoke when the event occurs 
     *        (the event will be passed as the single argument)
     */
    removeListener: function(eventType, eventTarget) {
        if (this._listenerList == null) {
            return;
        }
        this._listenerList.removeListener(eventType, eventTarget);
        if (this.application) {
            this.application.notifyComponentUpdate(this, "listeners", eventType, null);
        }
    },
    
    /** 
     * Sets the value of a property in the internal style.
     * 
     * @param {String} name the name of the property
     * @param value the new value of the property
     * @param rendered optional flag indicating whether the update has already been rendered by the containing client; 
     *        if enabled, the property update will not be sent to the update manager
     */
    set: function(name, newValue, rendered) {
        var oldValue = this._localStyle[name];
        if (oldValue === newValue) {
            return;
        }
        this._localStyle[name] = newValue;
        if (this._listenerList && this._listenerList.hasListeners("property")) {
            this._listenerList.fireEvent({type: "property", source: this, propertyName: name, 
                    oldValue: oldValue, newValue: newValue});
        }
        if (this.application) {
            this.application.notifyComponentUpdate(this, name, oldValue, newValue, rendered);
        }
    },
    
    /**
     * Sets the enabled state of the component.
     * 
     * @param newValue the new enabled state
     */
    setEnabled: function(newValue) {
        var oldValue = this._enabled;
        this._enabled = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, "enabled", oldValue, newValue);
        }
    },
    
    /** 
     * Sets the value of an indexed property in the internal style.
     * 
     * @param {String} name the name of the property
     * @param {Number} index the index of the property
     * @param newValue the new value of the property
     * @param rendered optional flag indicating whether the update has already been rendered by the containing client; 
     *        if enabled, the property update will not be sent to the update manager
     */
    setIndex: function(name, index, newValue, rendered) {
        var valueArray = this._localStyle[name];
        var oldValue = null;
        if (valueArray) {
            oldValue = valueArray[index];
            if (oldValue === newValue) {
                return;
            }
        } else {
            valueArray = [];
            this._localStyle[name] = valueArray;
        }
        valueArray[index] = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, name, oldValue, newValue, rendered);
        }
        if (this._listenerList && this._listenerList.hasListeners("property")) {
            this._listenerList.fireEvent({type: "property", source: this, propertyName: name, index: index,
                    oldValue: oldValue, newValue: newValue});
        }
    },
    
    /**
     * Sets a component-specific layout direction.
     * Note that in most cases it is preferable to set the layout direction of the Application, 
     * rather than individual components.
     * 
     * @param {Echo.LayoutDirection} newValue the new layout direction
     */
    setLayoutDirection: function(newValue) {
        var oldValue = this._layoutDirection;
        this._layoutDirection = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, "layoutDirection", oldValue, newValue);
        }
    },
    
    /**
     * Sets a component-specific locale.
     * Note that in most cases it is preferable to set the locale of the Application, 
     * rather than individual components.
     * 
     * @param {String} newValue the new layout direction
     */
    setLocale: function(newValue) {
        var oldValue = this._locale;
        this._locale = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, "locale", oldValue, newValue);
        }
    },
    
    /**
     * Sets the style of the component.
     * 
     * @param newValue the new style
     */
    setStyle: function(newValue) {
        var oldValue = this._style;
        this._style = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, "style", oldValue, newValue);
        }
    },
    
    /**
     * Sets the name of the style (from the application's style sheet) 
     * assigned to this component.
     * 
     * @param {String} newValue the style name
     */
    setStyleName: function(newValue) {
        var oldValue = this._styleName;
        this._styleName = newValue;
        if (this.application) {
            this.application.notifyComponentUpdate(this, "styleName", oldValue, newValue);
        }
    },
    
    /**
     * Returns a string representation of the component (default implementation).
     * 
     * @param {Boolean} longFormat an optional flag specifying whether all information about
     *        the component should be displayed (e.g., property values)
     * @return a string representation of the component
     * @type String
     */
    toString: function(longFormat) {
        var out = this.renderId + "/" + this.componentType;
        if (longFormat) {
            out += "\n";
            var componentCount = this.getComponentCount();
            out += this.renderId + "/properties:" + this._localStyle + "\n";
            for (var i = 0; i < componentCount; ++i) {
                var component = this.getComponent(i);
                out += this.renderId + "/child:" + component.renderId + "\n";
                out += component.toString(true);
            }
        }
        return out;
    }
});

/**
 * Provides focus management tools for an application.
 */
Echo.FocusManager = Core.extend({

    /**
     * The managed application.
     * @type Echo.Application
     */
    _application: null,

    /**
     * Focus management handler for a specific application instance.
     * One FocusManager is created for each application.
     * 
     * @param {Echo.Application} application the managed application
     */
    $construct: function(application) { 
        this._application = application;
    },
    
    /**
     * Searches the component hierarchy for the next component that should
     * be focused (based on the currently focused component).
     * Container components are queried to determine the order in which their
     * children should naturally be focused (certain components, e.g., SplitPanes,
     * will have a child focus order that may be different from the order of their 
     * children).
     * This search is depth first.
     * 
     * Search order (FORWARD):
     * 
     * (Start on Component)
     * First Child, next sibling, parent
     *
     * Search order (REVERSE):
     * Last Child, previous sibling, parent
     * 
     * @param {Echo.Component} component the component at which to begin searching
     * @param {Boolean} reverse flag indicating the direction of the search
     * @return the Component which should be focused
     * @type Echo.Component
     */
    find: function(component, reverse) {
        if (!component) {
            component = this._application.getFocusedComponent();
            if (!component) {
                component = this._application.rootComponent;
            }
        }
        
        // If a specific next focusable component has been specified, attempt to focus it.
        var setComponentId = reverse ? component.focusPreviousId : component.focusNextId;
        if (setComponentId) {
            var setComponent = this._application.getComponentByRenderId(setComponentId);
            if (setComponent && setComponent.isActive() && setComponent.focusable) {
                return setComponent;
            }
        }

        // The component which is currently focused by the application.
        var originComponent = component;
        
        // An associative array containing the ids of all previously visited components.
        var visitedComponents = { };
        
        // The value of 'component' on the previous iteration.
        var lastComponent = null;
        
        while (true) {
            // The candidate next component to be focused.
            var nextComponent = null, componentIndex;

            if ((reverse && component == originComponent) || (lastComponent && lastComponent.parent == component)) {
                // Searching in reverse on origin component (OR) Previously moved up: do not move down.
            } else {
                var componentCount = component.getComponentCount();
                if (componentCount > 0) {
                    // Attempt to move down.
                    // Next component is first child (searching forward) or last child (searching reverse).
                    nextComponent = component.getComponent(reverse ? componentCount - 1 : 0);
                    if (visitedComponents[nextComponent.renderId]) {
                        // Already visited children, cancel the move.
                        nextComponent = null;
                    }
                }
            }
                
            if (nextComponent == null) {
                // Attempt to move to next/previous sibling.
                if (component.parent) {
                    // Get previous sibling.
                    if (reverse) {
                        componentIndex = component.parent.indexOf(component);
                        if (componentIndex > 0) {
                            nextComponent = component.parent.getComponent(componentIndex - 1);
                        }
                    } else {
                        componentIndex = component.parent.indexOf(component);
                        if (componentIndex < component.parent.getComponentCount() - 1) {
                            nextComponent = component.parent.getComponent(componentIndex + 1);
                        }
                    }
                }
            }

            if (nextComponent == null) {
                // Attempt to move up.
                nextComponent = component.parent;
            }
            
            if (nextComponent == null) {
                return null;
            }

            lastComponent = component;
            component = nextComponent;
            visitedComponents[component.renderId] = true;
            
            if (component != originComponent && component.isActive() && component.focusable) {
                return component;
            }
        }
    },
    
    /**
     * Finds next (or previous) focusable descendant of a parent component.
     * This method requires that the application's currently focused component
     * be a descendant of the specified parent component.  The search will
     * be limited to descendants of the parent component, i.e., if a suitable descendant
     * component cannot be found, null will be returned.
     * 
     * The <code>minimumDistance</code> property may be used to skip a number of siblings.
     * This is used by components such as "Grid" which may want to find a focusable component
     * in the next row, skipping over all columns of the current row.  
     * If omitted the default value of this property is 1.  As an example, a value of 2
     * would skip the immediately adjacent sibling of the current focused component.
     *
     * @param {Echo.Component} parentComponent the parent component to search
     * @param {Boolean} reverse the search direction, false indicating to search forward, true
     *        indicating reverse
     * @param {Number} minimumDistance the fewest number of lateral focus moves to make before
     *        returning a focusable component (optional, default value of 1)
     * @return the focusable descendant, or null if one cannot be found
     * @type Echo.Component
     */
    findInParent: function(parentComponent, reverse, minimumDistance) {
        if (!minimumDistance) {
            minimumDistance = 1;
        }
        
        var visitedIds = {},
            focusedComponent = this._application.getFocusedComponent();

        if (!focusedComponent) {
            return null;
        }

        visitedIds[focusedComponent.renderId] = true;
        
        var focusedIndex = this._getDescendantIndex(parentComponent, focusedComponent);
        if (focusedIndex == -1) {
            return null;
        }
        
        var componentIndex = focusedIndex;
        var component = focusedComponent;
        do {
            component = this.find(component, reverse, visitedIds);
            if (component == null || visitedIds[component.renderId]) {
                return null;
            }
            componentIndex = this._getDescendantIndex(parentComponent, component);
            visitedIds[component.renderId] = true;
        } while (Math.abs(componentIndex - focusedIndex) < minimumDistance && component != focusedComponent);

        if (component == focusedComponent) {
            // Search wrapped, only one focusable component.
            return null;
        }
        
        this._application.setFocusedComponent(component);
        return component;
    },
    
    /**
     * Determines the index of the child of <code>parent</code> in which
     * <code>descendant</code> is contained.
     * 
     * @param {Echo.Component} parent the parent component
     * @param {Echo.Component} descendant the descendant component
     * @return the descendant index, or -1 if the component is not a descendant of <code>parent</code>
     * @type Number
     */
    _getDescendantIndex: function(parent, descendant) {
        while (descendant.parent != parent && descendant.parent != null) {
            descendant = descendant.parent;
        }
        if (descendant.parent == null) {
            return -1;
        }
        return parent.indexOf(descendant);
    }
});

/**
 * Describes the layout direction of text and content to provide support 
 * for bidirectional localization.
 */
Echo.LayoutDirection = Core.extend({
    
    /**
     * Flag indicating whether layout direction is left-to-right.
     * @type Boolean 
     */
    _ltr: false,
    
    /**
     * LayoutDirection property.  Do not instantiate, use LTR/RTL constants.
     * 
     * @param {Boolean} ltr true if the layout direction is left-to-right 
     */
    $construct: function(ltr) {
        this._ltr = ltr;
    },

    /**
     * Determines if the layout direction is left-to-right.
     * 
     * @return true if the layout direction is left-to-right
     * @type Boolean
     */
    isLeftToRight: function() {
        return this._ltr;
    }
});

/**
 * Global instance representing a left-to-right layout direction.
 * @type Echo.LayoutDirection
 * @final
 */
Echo.LayoutDirection.LTR = new Echo.LayoutDirection(true);

/**
 * Global instance representing a right-to-left layout direction.
 * @type Echo.LayoutDirection
 * @final
 */
Echo.LayoutDirection.RTL = new Echo.LayoutDirection(false);

/**
 * An application style sheet.
 */
Echo.StyleSheet = Core.extend({

    /** Map between style names and type-name to style maps. */
    _nameToStyleMap: null,

    /** 
     * Style cache mapping style names and type-name to style maps.  Behaves identically to _nameToStyleMap except styles are 
     * stored explicitly for every component type.  This provides quick access to style information for the renderer. 
     */
    _renderCache: null,
    
    /**
     * Creates a new style sheet.
     *
     * @param initialValues an optional mapping between style names 
     *        and maps between component types and styles
     */
    $construct: function(initialValues) {
        this._renderCache = { };
        this._nameToStyleMap = { };
        
        if (initialValues) {
            for (var styleName in initialValues) {
                for (var componentType in initialValues[styleName]) {
                     this.setStyle(styleName, componentType, initialValues[styleName][componentType]);
                }
            }
        }
    },
    
    /**
     * Returns the style that should be used for a component.
     * 
     * @param {String} name the component's style name
     * @param {String} componentType the type of the component
     * @return the style
     */
    getRenderStyle: function(name, componentType) {
        // Retrieve style from cache.
        var typeToStyleMap = this._renderCache[name];
        if (!typeToStyleMap) {
            return null;
        }
        var style = typeToStyleMap[componentType];
        if (style !== undefined) {
            // If style found in cache, return immediately.
            return style;
        } else {
            return this._loadRenderStyle(name, componentType);
        }
    },
    
    /**
     * Creates a rendered style object for a specific style name and componentType and stores it in
     * the cache.  This method is invoked by <code>getRenderStyle()</code> when a cached style cannot be found.
     *
     * @param {String} name the style name
     * @param {String} componentType the type of the component
     * @return the style
     */
    _loadRenderStyle: function(name, componentType) {
        // Retrieve value (type-to-style-map) from name-to-style-map with specified name key.
        var typeToStyleMap = this._nameToStyleMap[name];
        if (typeToStyleMap == null) {
            // No styles available for specified name, mark cache entry as null and return null.
            this._renderCache[name][componentType] = null;
            return null;
        }
        
        // Retrieve style for specific componentType.
        var style = typeToStyleMap[componentType];
        if (style == null) {
            var testType = componentType;
            while (style == null) {
                // Search super types of testType to find style until found.
                testType = Echo.ComponentFactory.getSuperType(testType);
                if (testType == null) {
                    // No style available for component type, mark cache entry as null and return null.
                    this._renderCache[name][testType] = null;
                    return null;
                }
                style = typeToStyleMap[testType];
            }
        }
        this._renderCache[name][componentType] = style;
        return style;
    },
    
    /**
     * Retrieves a specific style from the style sheet.
     * 
     * @param {String} name the style name
     * @param {String} componentType the component type
     * @return the style
     */
    getStyle: function(name, componentType) {
        var typeToStyleMap = this._nameToStyleMap[name];
        if (typeToStyleMap == null) {
            return null;
        }
        return typeToStyleMap[componentType];
    },
    
    /**
     * Stores a style in the style sheet.
     * 
     * @param {String} name the style name
     * @param {String} componentType the component type
     * @param the style
     */
    setStyle: function(name, componentType, style) {
        // Create or clear cache entry for name.
        this._renderCache[name] = {};
        
        var typeToStyleMap = this._nameToStyleMap[name];
        if (typeToStyleMap == null) {
            typeToStyleMap = {};
            this._nameToStyleMap[name] = typeToStyleMap;
        }
        typeToStyleMap[componentType] = style;
    }
});

// Update Management

/**
 * Namespace for update management.
 * Provides capabilities for storing property changes made to applications and components
 * such that display redraws may be performed efficiently in batches by application container.
 * @namespace
 */
Echo.Update = { };

/**
 * Representation of an update to a single existing component which is currently rendered on the screen.
 */
Echo.Update.ComponentUpdate = Core.extend({

    $static: {
    
        /**
         * Data object representing the old and new states of a changed property.
         *
         * @param oldValue the old value of the property
         * @param newValue the new value of the property
         */
        PropertyUpdate: function(oldValue, newValue) {
            this.oldValue = oldValue;
            this.newValue = newValue;
        }
    },
    
    /**
     * The <code>Manager</code> to which this update belongs.
     * @type Array
     */
    _manager: null,
    
    /**
     * The parent component represented in this <code>ComponentUpdate</code>.
     * @type Echo.Component
     */
    parent: null,
    
    /**
     * Storage for contextual information used by application container to render this update.
     * Object type and content are specified by the application container, this variable is not
     * used by the application module in any capacity.
     */
    renderContext: null,
    
    /**
     * The set of child Component ids added to the <code>parent</code>.
     * @type Array
     */
    _addedChildIds: null,
    
    /**
     * A mapping between property names of the parent component and 
     * <code>PropertyUpdate</code>s.
     */
    _propertyUpdates: null,
    
    /**
     * The set of child Component ids removed from the <code>parent</code>.
     * @type Array
     */
    _removedChildIds: null,
    
    /**
     * The set of descendant Component ids which are implicitly removed 
     * as they were children of removed children.
     * @type Array
     */
    _removedDescendantIds: null,

    /**
     * The set of child Component ids whose <code>LayoutData</code> 
     * was updated. 
     * @type Array
     */
    _updatedLayoutDataChildIds: null,
    
    /**
     * The set of listener types which have been added to/removed from the component.
     * Associative mapping between listener type names and boolean values, true representing
     * the notion that listeners of a type have been added or removed.
     */
    _listenerUpdates: null,

    /**
     * Creates a new ComponentUpdate.
     * 
     * @param {Echo.Component} parent the updated component
     */
    $construct: function(manager, parent) {
    
        /**
         * The <code>Manager</code> to which this update belongs.
         * @type Array
         */
        this._manager = manager;
        
        /**
         * The parent component represented in this <code>ComponentUpdate</code>.
         * @type Echo.Component
         */
        this.parent = parent;
    },
    
    /**
     * Records the addition of a child to the parent component.
     * 
     * @param {Echo.Component} child the added child
     */
    _addChild: function(child) {
        if (!this._addedChildIds) {
            this._addedChildIds = [];
        }
        this._addedChildIds.push(child.renderId);
        this._manager._idMap[child.renderId] = child;
    },
    
    /**
     * Appends removed children and descendants from another update to this
     * update as removed descendants.
     * This method is invoked when a component is removed that is an ancestor
     * of a component that has an update in the update manager.
     * 
     * @param {Echo.Update.CompoentUpdate} update the update from which to pull 
     *        removed components/descendants
     */
    _appendRemovedDescendants: function(update) {
        var i;
        
        // Append removed descendants.
        if (update._removedDescendantIds != null) {
            if (this._removedDescendantIds == null) {
                this._removedDescendantIds = [];
            }
            for (i = 0; i < update._removedDescendantIds.length; ++i) {
                this._removedDescendantIds.push(update._removedDescendantIds[i]);
            }
        }
        
        // Append removed children.
        if (update._removedChildIds != null) {
            if (this._removedDescendantIds == null) {
                this._removedDescendantIds = [];
            }
            for (i = 0; i < update._removedChildIds.length; ++i) {
                this._removedDescendantIds.push(update._removedChildIds[i]);
            }
        }
        
        if (this._removedDescendantIds != null) {
            Core.Arrays.removeDuplicates(this._removedDescendantIds);
        }
    },
    
    /**
     * Returns an array containing the children added in this update,
     * or null if none were added.
     * 
     * @return the added children
     * @type Array
     */
    getAddedChildren: function() {
        if (!this._addedChildIds) {
            return null;
        }
        var components = [];
        for (var i = 0; i < this._addedChildIds.length; ++i) {
            components[i] = this._manager._idMap[this._addedChildIds[i]];
        }
        return components;
    },
    
    /**
     * Returns an array containing the children removed in this update,
     * or null if none were removed.
     * 
     * @return the removed children
     * @type Array
     */
    getRemovedChildren: function() {
        if (!this._removedChildIds) {
            return null;
        }
        var components = [];
        for (var i = 0; i < this._removedChildIds.length; ++i) {
            components[i] = this._manager._removedIdMap[this._removedChildIds[i]];
        }
        return components;
    },
    
    /**
     * Returns an array containing the descendants of any children removed in
     * this update, or null if none were removed.  The removed children
     * themselves are not returned by this method.
     * 
     * @return the removed descendants
     * @type Array
     */
    getRemovedDescendants: function() {
        if (!this._removedDescendantIds) {
            return null;
        }
        var components = [];
        for (var i = 0; i < this._removedDescendantIds.length; ++i) {
            components[i] = this._manager._removedIdMap[this._removedDescendantIds[i]];
        }
        return components;
    },
    
    /**
     * Returns an array containing the children of this component whose
     * LayoutDatas have changed in this update, or null if no such
     * changes were made.
     * 
     * @return the updated layout data children
     * @type Array
     */
    getUpdatedLayoutDataChildren: function() {
        if (!this._updatedLayoutDataChildIds) {
            return null;
        }
        var components = [];
        for (var i = 0; i < this._updatedLayoutDataChildIds.length; ++i) {
            components[i] = this._manager._idMap[this._updatedLayoutDataChildIds[i]];
        }
        return components;
    },
    
    /**
     * Determines if any children were added during this update.
     * 
     * @return true if any children were added
     * @type Boolean
     */
    hasAddedChildren: function() {
        return this._addedChildIds != null;
    },
    
    /**
     * Determines if any children were removed during this update.
     * 
     * @return true if any children were removed
     * @type Boolean
     */
    hasRemovedChildren: function() {
        return this._removedChildIds != null;
    },
    
    /**
     * Determines if any children had their LayoutData changed during this update.
     * 
     * @return true if any children had their LayoutData changed
     * @type Boolean
     */
    hasUpdatedLayoutDataChildren: function() {
        return this._updatedLayoutDataChildIds != null;
    },
    
    /**
     * Determines if this update has any changed properties.
     * 
     * @return true if properties are being updated
     * @type Boolean
     */
    hasUpdatedProperties: function() {
        return this._propertyUpdates != null;
    },
    
    /**
     * Returns a <code>PropertyUpdate</code> describing an update to the
     * property with the given <code>name</code>.
     * 
     * @param name the name of the property being updated
     * @return the <code>PropertyUpdate</code>, or null if none exists
     * @type Echo.Update.ComponentUpdate.PropertyUpdate
     */
    getUpdatedProperty: function(name) {
        if (this._propertyUpdates == null) {
            return null;
        }
        return this._propertyUpdates[name];
    },
    
    /**
     * Determines if any listeners of a specific type were added or removed
     * from the component.
     * 
     * @param {String} listenerType the type of listener to query
     */
    isListenerTypeUpdated: function(listenerType) {
        return this._listenerUpdates == null ? false : this._listenerUpdates[listenerType]; 
    },
    
    /**
     * Returns the names of all properties being updated in this update.
     * 
     * @return the names of all updated properties, if no properties are updated an
     *         empty array is returned
     * @type Array
     */
    getUpdatedPropertyNames: function() {
        if (this._propertyUpdates == null) {
            return [];
        }
        var updatedPropertyNames = [];
        for (var i in this._propertyUpdates) {
            updatedPropertyNames.push(i);
        }
        return updatedPropertyNames;
    },
    
    /**
     * Determines if any of the specified properties has been
     * updated in this update.  The provided object should have
     * have keys for the desired property names and  values that evaluate 
     * to true, e.g. to determine if either the "text" and/or "icon" properties
     * changed, specify {text: true, icon: true}.
     * 
     * @param updatedPropertySet the updated property set
     * @return true if any of the specified properties has been updated in this update
     * @type Boolean
     */
    hasUpdatedPropertyIn: function(updatedPropertySet) {
        for (var x in this._propertyUpdates) {
            if (updatedPropertySet[x]) {
                return true;
            }
        }
        return false;
    },

    /**
     * Determines if the set of updated property names is contained
     * within the specified set.  The provided object should have
     * have keys for the desired property names and  values that evaluate 
     * to true, e.g. to determine if no properties other than "text" and "icon"
     * changed, specify {text: true, icon: true}. 
     * 
     * @param updatedPropertySet the updated property set
     * @return true if the set of updated property names is contained within the specified set
     * @type Boolean
     */
    isUpdatedPropertySetIn: function(updatedPropertySet) {
        for (var x in this._propertyUpdates) {
            if (!updatedPropertySet[x]) {
                return false;
            }
        }
        return true;
    },
    
    /**
     * Records the removal of a child from the parent component.
     * 
     * @param {Echo.Component} child the removed child
     */
    _removeChild: function(child) {
        this._manager._removedIdMap[child.renderId] = child;
    
        if (this._addedChildIds) {
            // Remove child from add list if found.
            Core.Arrays.remove(this._addedChildIds, child.renderId);
        }
        
        if (this._updatedLayoutDataChildIds) {
            // Remove child from updated layout data list if found.
            Core.Arrays.remove(this._updatedLayoutDataChildIds, child.renderId);
        }
    
        if (!this._removedChildIds) {
            this._removedChildIds = [];
        }
        
        this._removedChildIds.push(child.renderId);
    
        for (var i = 0; i < child.children.length; ++i) {
            this._removeDescendant(child.children[i]);
        }
    },
    
    /**
     * Records the removal of a descendant of the parent component.
     * All children of a removed component are recorded as removed
     * descendants when the child is removed.
     * This method will recursively invoke itself on children of
     * the specified descendant.
     * 
     * @param {Echo.Component} descendant the removed descendant 
     */
    _removeDescendant: function(descendant) {
        this._manager._removedIdMap[descendant.renderId] = descendant;
        if (!this._removedDescendantIds) {
            this._removedDescendantIds = [];
        }
        this._removedDescendantIds.push(descendant.renderId);
        for (var i = 0; i < descendant.children.length; ++i) {
            this._removeDescendant(descendant.children[i]);
        }
    },
    
    /**
     * Returns a string representation.
     * 
     * @return a string representation
     * @type String
     */
    toString: function() {
        var s = "ComponentUpdate\n";
        s += "- Parent: " + this.parent + "\n";
        s += "- Adds: " + this._addedChildIds + "\n";
        s += "- Removes: " + this._removedChildIds + "\n";
        s += "- DescendantRemoves: " + this._removedDescendantIds + "\n";
        s += "- Properties: " + Core.Debug.toString(this._propertyUpdates) + "\n";
        s += "- LayoutDatas: " + this._updatedLayoutDataChildIds + "\n";
        return s;
    },
    
    /**
     * Records the update of the LayoutData of a child component.
     * 
     * @param {Echo.Component} child the child component whose layout data was updated
     */
    _updateLayoutData: function(child) {
        this._manager._idMap[child.renderId] = child;
        if (this._updatedLayoutDataChildIds == null) {
            this._updatedLayoutDataChildIds = [];
        }
        this._updatedLayoutDataChildIds.push(child.renderId);
    },
    
    /**
     * Records the addition or removal of listeners to the parent component.
     * 
     * @param {String} listenerType the listener type
     */
    _updateListener: function(listenerType) {
        if (this._listenerUpdates == null) {
            this._listenerUpdates = { };
        }
        this._listenerUpdates[listenerType] = true;
    },
    
    /**
     * Records the update of a property of the parent component.
     * 
     * @param {String} propertyName the name of the property
     * @param oldValue the previous value of the property
     * @param newValue the new value of the property
     */
   _updateProperty: function(propertyName, oldValue, newValue) {
        if (this._propertyUpdates == null) {
            this._propertyUpdates = { };
        }
        var propertyUpdate = new Echo.Update.ComponentUpdate.PropertyUpdate(oldValue, newValue);
        this._propertyUpdates[propertyName] = propertyUpdate;
    }
});

/**
 * Monitors and records updates made to the application between repaints.
 * Provides API to determine changes to component hierarchy since last update
 * in order to efficiently repaint the screen.
 */
Echo.Update.Manager = Core.extend({
    
    /**
     * Associative mapping between component ids and Echo.Update.ComponentUpdate
     * instances.
     */
    _componentUpdateMap: null,
    
    /**
     * Flag indicating whether a full refresh or incremental update will be performed.
     * @type Boolean
     */
    fullRefreshRequired: false,
    
    /**
     * The application whose updates are being managed.
     * @type Echo.Application
     */
    application: null,
    
    /**
     * Flag indicating whether any updates are pending.
     * @type Boolean
     */
    _hasUpdates: false,
    
    /**
     * Internal listener list for update listeners.
     * @type Core.ListenerList
     */
    _listenerList: null,
    
    /**
     * Associative mapping between component ids and component instances for all
     * updates held in this manager object.
     */
    _idMap: null,
    
    /**
     * Associative mapping from the ids of components which are to be removed in this update to the components themselves.
     */
    _removedIdMap: null,
    
    /** 
     * The id of the last parent component whose child was analyzed by
     * _isAncestorBeingAdded() that resulted in that method returning false.
     * This id is stored for performance optimization purposes.
     * This performance optimization relies on the fact that _isAncestorBeingAdded()
     * will be invoked for each attempt to modify the hierarchy.
     * @type String
     */
    _lastAncestorTestParentId: null,
    
    /**
     * Creates a new Update Manager.
     *
     * @param {Echo.Application} application the supported application
     */
    $construct: function(application) {
        this._componentUpdateMap = { };
        this.application = application;
        this._listenerList = new Core.ListenerList();
        this._idMap = { };
        this._removedIdMap = { };
    },
    
    /**
     * Adds a listener to receive notification of update events.
     * 
     * @param {Function} l the listener to add
     */
    addUpdateListener: function(l) {
        this._listenerList.addListener("update", l);
    },
    
    /**
     * Creates a new ComponentUpdate object (or returns an existing one) for a
     * specific parent component.
     * 
     * @param {Echo.Component} parent the parent Component
     * @return a ComponentUpdate instance for that Component
     * @type Echo.Update.ComponentUpdate 
     */
    _createComponentUpdate: function(parent) {
        this._hasUpdates = true;
        var update = this._componentUpdateMap[parent.renderId];
        if (!update) {
            update = new Echo.Update.ComponentUpdate(this, parent);
            this._componentUpdateMap[parent.renderId] = update;
        }
        return update;
    },
    
    /**
     * Permanently disposes of the Update Manager, freeing any resources.
     */
    dispose: function() {
        this.application = null;
    },
    
    /**
     * Notifies update listeners of an event.
     */
    _fireUpdate: function() {
        if (!this._listenerList.isEmpty()) {
            this._listenerList.fireEvent({type: "update", source: this});
        }
    },
    
    /**
     * Returns the current pending updates.  Returns null in the event that that no pending updates exist.
     * 
     * @return an array containing all component updates (as Echo.Update.ComponentUpdates)
     * @type Array
     */
    getUpdates: function() {
        var updates = [];
        for (var key in this._componentUpdateMap) {
            updates.push(this._componentUpdateMap[key]);
        }
        return updates;
    },
    
    /**
     * Determines if any updates exist in the Update Manager.
     * 
     * @return true if any updates are present
     * @type Boolean
     */
    hasUpdates: function() {
        return this._hasUpdates;
    },
    
    /**
     * Determines if an ancestor of the specified component is being added.
     * This method must be invoked by all hierarchy modification operations.
     * 
     * @param {Echo.Component} component the component to evaluate
     * @return true if the component or an ancestor of the component is being added
     * @type Boolean
     */
    _isAncestorBeingAdded: function(component) {
        var child = component;
        var parent = component.parent;
        
        var originalParentId = parent ? parent.renderId : null;
        if (originalParentId && this._lastAncestorTestParentId == originalParentId) {
            // If last invocation of _isAncestorBeingAdded for the same component returned false, it is safe
            // to assume that this invocation will return false as well.
            return false;
        }
        
        while (parent) {
            var update = this._componentUpdateMap[parent.renderId];
            if (update && update._addedChildIds) {
                for (var i = 0; i < update._addedChildIds.length; ++i) {
                    if (update._addedChildIds[i] == child.renderId) {
                        return true;
                    }
                }
            }
            child = parent;
            parent = parent.parent;
        }
        
        this._lastAncestorTestParentId = originalParentId;
        return false;
    },
    
    /**
     * Processes a child addition to a component.
     * 
     * @param {Echo.Component} parent the parent component
     * @param {Echo.Component} child the added child component
     */
    _processComponentAdd: function(parent, child) {
        if (this.fullRefreshRequired) {
            // A full refresh indicates an update already exists which encompasses this update.
            return;
        }
        if (this._isAncestorBeingAdded(child)) {
            // An ancestor being added indicates an update already exists which encompasses this update.
            return;
        }
        var update = this._createComponentUpdate(parent);
        update._addChild(child);
    },
    
    /**
     * Process a layout data update to a child component.
     * 
     * @param {Echo.Component} updatedComponent the updated component
     */
    _processComponentLayoutDataUpdate: function(updatedComponent) {
        if (this.fullRefreshRequired) {
            // A full refresh indicates an update already exists which encompasses this update.
            return;
        }
        var parent = updatedComponent.parent;
        if (parent == null || this._isAncestorBeingAdded(parent)) {
            // An ancestor being added indicates an update already exists which encompasses this update.
            return;
        }
        var update = this._createComponentUpdate(parent);
        update._updateLayoutData(updatedComponent);
    },
    
    /**
     * Process a layout data update to a child component.
     * 
     * @param {Echo.Component} updatedComponent the updated component
     */
    _processComponentListenerUpdate: function(parent, listenerType) {
        if (this.fullRefreshRequired) {
            // A full refresh indicates an update already exists which encompasses this update.
            return;
        }
        if (this._isAncestorBeingAdded(parent)) {
            // An ancestor being added indicates an update already exists which encompasses this update.
            return;
        }
        var update = this._createComponentUpdate(parent);
        update._updateListener(listenerType);
    },
    
    /**
     * Processes a child removal from a component.
     * 
     * @param {Echo.Component} parent the parent component
     * @param {Echo.Component} child the removed child component
     */
    _processComponentRemove: function(parent, child) {
        if (this.fullRefreshRequired) {
            // A full refresh indicates an update already exists which encompasses this update.
            return;
        }
        if (this._isAncestorBeingAdded(parent)) {
            // An ancestor being added indicates an update already exists which encompasses this update.
            return;
        }
        var update = this._createComponentUpdate(parent);
        update._removeChild(child);
        
        var disposedIds = null;
        
        // Search updated components for descendants of removed component.
        // Any found descendants will be removed and added to this update's
        // list of removed components.
        for (var testParentId in this._componentUpdateMap) {
             var testUpdate = this._componentUpdateMap[testParentId];
             if (child.isAncestorOf(testUpdate.parent)) {
                 update._appendRemovedDescendants(testUpdate);
                 if (disposedIds == null) {
                     disposedIds = [];
                 }
                 disposedIds.push(testParentId);
             }
        }
        
        if (disposedIds != null) {
            for (var i = 0; i < disposedIds.length; ++i) {
                delete this._componentUpdateMap[disposedIds[i]];
            }
        }
    },
    
    /**
     * Processes a property update to a component.
     * 
     * @param {Echo.Component} component the updated component
     * @param {String} propertyName the updated property name
     * @param oldValue the previous value of the property
     * @param newValue the new value of the property
     */
    _processComponentPropertyUpdate: function(component, propertyName, oldValue, newValue) {
        if (this.fullRefreshRequired) {
            // A full refresh indicates an update already exists which encompasses this update.
            return;
        }
        if (this._isAncestorBeingAdded(component)) {
            // An ancestor being added indicates an update already exists which encompasses this update.
            return;
        }
        var update = this._createComponentUpdate(component);
        update._updateProperty(propertyName, oldValue, newValue);
    },
    
    /**
     * Processes an event requiring a full-refresh.
     */
    _processFullRefresh: function() {
        // Mark all components as having being removed from root.
        for (var i = 0; i < this.application.rootComponent.children.length; ++i) {
            this._processComponentRemove(this.application.rootComponent, this.application.rootComponent.children[i]);
        }

        // Flag full refresh as required, such that all future property updates bounce.
        this.fullRefreshRequired = true;
        
        // Retrieve root component update and mark as full refresh.
        var update = this._createComponentUpdate(this.application.rootComponent);
        update.fullRefresh = true;
        
        // Notify container.
        this._fireUpdate();
    },
    
    /**
     * Processes component update notification received from the application instance.
     * 
     * @param {Echo.Component} component the updated component
     * @param {String} propertyName the updated property name
     * @param oldValue the previous value of the property
     * @param newValue the new value of the property
     */
    _processComponentUpdate: function(parent, propertyName, oldValue, newValue) {
        if (propertyName == "children") {
            // Child added/removed.
            if (newValue == null) {
                // Process child removal.
                this._processComponentRemove(parent, oldValue);
            } else {
                // Process child addition.
                this._processComponentAdd(parent, newValue);
            }
        } else if (propertyName == "layoutData") {
            // Process a layout data update.
            this._processComponentLayoutDataUpdate(parent);
        } else if (propertyName == "listeners") {
            // Process listeners addition/removal.
            this._processComponentListenerUpdate(parent, oldValue || newValue);
        } else {
            // Process property update.
            this._processComponentPropertyUpdate(parent, propertyName, oldValue, newValue);
        }
        this._fireUpdate();
    },

    /**
     * Purges all updates from the manager.
     * Invoked after the client has repainted the screen.
     */
    purge: function() {
        this.fullRefreshRequired = false;
        this._componentUpdateMap = { };
        this._idMap = { };
        this._removedIdMap = { };
        this._hasUpdates = false;
        this._lastAncestorTestParentId = null;
    },
    
    /**
     * Removes a listener from receiving notification of update events.
     * 
     * @param {Function} l the listener to remove
     */
    removeUpdateListener: function(l) {
        this._listenerList.removeListener("update", l);
    },
    
    /**
     * Returns a string representation.
     * 
     * @return a string representation
     * @type String
     */
    toString: function() {
        var s = "[ UpdateManager ]\n";
        if (this.fullRefreshRequired) {
            s += "fullRefresh";
        } else {
            for (var key in this._componentUpdateMap) {
                s += this._componentUpdateMap[key];
            }
        }
        return s;
    }
});

// Built-in Component Object Definitions

/**
 * Abstract base class for button components.
 *
 * @sp {String} actionCommand the action command fired in action events 
 *     when the button is pushed
 * @sp {#Alignment} alignment the alignment of the button's content (only horizontal alignments are supported, any vertical
 *     component of the alignment value will not be rendered)
 * @sp {#FillImage} backgroundImage the background image
 * @sp {#Border} border the default button border
 * @sp {#Color} disabledBackground the disabled background color
 * @sp {#FillImage} disabledBackgroundImage the disabled background image
 * @sp {#Border} disabledBorder the disabled border
 * @sp {#Font} disabledFont the disabled font
 * @sp {#Color} disabledForeground the disabled foreground color
 * @sp {#ImageReference} disabledIcon the disabled icon
 * @sp {#Color} focusedBackground the focused background
 * @sp {#FillImage}focusedBackgroundImage the focused background image
 * @sp {#Border} focusedBorder the focused border
 * @sp {Boolean} focusedEnabled boolean flag indicating whether focus effects are enabled 
 * @sp {#Font} focusedFont the focused font
 * @sp {#Color} focusedForeground the focused foreground color
 * @sp {#ImageReference} focusedIcon the focused icon
 * @sp {#Extent} height the button height
 * @sp {#ImageReference} icon the button icon
 * @sp {#Extent} iconTextMargin the extent margin between the button's icon and text
 * @sp {#Insets} insets the inset padding margin between the button's border and its content
 * @sp {Boolean} lineWrap boolean flag indicating whether text within the button may be wrapped
 * @sp {#Color} pressedBackground the pressed background color
 * @sp {#FillImage} pressedBackgroundImage the pressed background image
 * @sp {#Border} pressedBorder the pressed border
 * @sp {Boolean} pressedEnabled boolean flag indicating whether pressed effects are enabled 
 * @sp {#Font} pressedFont the pressed font
 * @sp {#Font} pressedForeground the pressed foreground color
 * @sp {#ImageReference} pressedIcon the pressed icon
 * @sp {#Color} rolloverBackground the rollover background color
 * @sp {#FillImage} rolloverBackgroundImage the rollover background image
 * @sp {#Border} rolloverBorder the rollover border
 * @sp {Boolean} rolloverEnabled boolean flag indicating whether rollover effects are enabled
 * @sp {#Font} rolloverFont the rollover font
 * @sp {#Color} rolloverForeground the rollover foreground
 * @sp {#ImageReference} rolloverIcon the rollover icon
 * @sp {String} text the text of the button
 * @sp {#Alignment} textAlignment the alignment of the text
 * @sp {#Alignment} textPosition the position of the text relative to the icon
 * @sp {String} toolTipText the tool tip text
 * @sp {#Extent} width the width of the button
 * @event action An event fired when the button is pressed (clicked).  The <code>actionCommand</code> property of the pressed
 *        button is provided as a property.
 */
Echo.AbstractButton = Core.extend(Echo.Component, {

    $abstract: true,
    
    $load: function() {
        Echo.ComponentFactory.registerType("AbstractButton", this);
        Echo.ComponentFactory.registerType("AB", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "AbstractButton",

    /** @see Echo.Component#focusable */
    focusable: true,
    
    $virtual: {
        
        /**
         * Programmatically performs a button action.
         */
        doAction: function() {
            this.fireEvent({type: "action", source: this, actionCommand: this.get("actionCommand")});
        }
    }
});

/**
 * Button component: a stateless "push" button which is used to initiate an
 * action.  May not contain child components.
 */
Echo.Button = Core.extend(Echo.AbstractButton, {

    $load: function() {
        Echo.ComponentFactory.registerType("Button", this);
        Echo.ComponentFactory.registerType("B", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Button"
});

/**
 * An abstract base class for on/off toggle button components.
 *
 * @sp {#ImageReference} disabledStateIcon the disabled state icon to display when the toggle state is deselected
 * @sp {#ImageReference} disabledSelectedStateIcon the disabled state icon to display when thetoggle  state is selected
 * @sp {#ImageReference} pressedStateIcon the pressed state icon to display when the toggle state is deselected
 * @sp {#ImageReference} pressedSelectedStateIcon the pressed state icon to display when the toggle state is selected
 * @sp {#ImageReference} rolloverStateIcon the rollover state icon to display when the toggle state is deselected
 * @sp {#ImageReference} rolloverSelectedStateIcon the rollover state icon to display when the toggle state is selected
 * @sp {#ImageReference} selectedStateIcon the default state icon to display when the toggle state is deselected
 * @sp {#Alignment} stateAlignment the alignment of the state icon relative to the button's icon/text
 * @sp {#Alignment} statePosition the position (an alignment value) of the state icon relative to the button's icon/text
 * @sp {#ImageReference} stateIcon the default state icon to display when the toggle state is selected
 * @sp {Number} stateMargin the margin between the state icon and the button's icon/text
 */
Echo.ToggleButton = Core.extend(Echo.AbstractButton, {

    $load: function() {
        Echo.ComponentFactory.registerType("ToggleButton", this);
        Echo.ComponentFactory.registerType("TB", this);
    },

    $abstract: true,

    /** @see Echo.Component#componentType */
    componentType: "ToggleButton"
});

/**
 * CheckBox component: a simple on/off toggle button. May not contain child
 * components.
 */
Echo.CheckBox = Core.extend(Echo.ToggleButton, {

    $load: function() {
        Echo.ComponentFactory.registerType("CheckBox", this);
        Echo.ComponentFactory.registerType("CB", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "CheckBox"
});

/**
 * RadioButton component: a toggle button which allows a user to select one
 * option from a group of options. Radio buttons should be assigned to a unique
 * named group (by setting the <code>group</code> property). Only one radio
 * button in a group will be selected at a given time. May not contain child
 * components.
 * 
 * @sp {String} group a unique identifier used to group radio buttons together
 *     (set this property to a value generated by Echo.Application.generateUid()
 *     to guarantee uniqueness)
 */
Echo.RadioButton = Core.extend(Echo.ToggleButton, {

    $load: function() {
        Echo.ComponentFactory.registerType("RadioButton", this);
        Echo.ComponentFactory.registerType("RB", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "RadioButton"
});

/**
 * Abstract base class for selection list components (i.e., SelectFields and
 * ListBoxes).
 * 
 * @cp {Array} items the array of items contained in the list component. The
 *     value of the 'text' property or toString() value of the item will be
 *     displayed in the selection component.
 * @cp selectedId the values of the id property of the selected item, or an
 *     array of the id values when multiple items are selected
 * @cp selection the index of the selected item, or an array of the indices of
 *     selected items when multiple items are selected
 * 
 * @sp {#Border} border the default border
 * @sp {#Color} disabledBackground the disabled background color
 * @sp {#Border} disabledBorder the disabled border
 * @sp {#Font} disabledFont the disabled font
 * @sp {#Color} disabledForeground the disabled foreground color
 * @sp {#Extent} height the component height
 * @sp {#Insets} insets the inset margin between the border and the items of the
 *     list component
 * @sp {#Color} rolloverBackground the rollover background color
 * @sp {#Border} rolloverBorder the rollover border
 * @sp {#Font} rolloverFont the rollover font
 * @sp {#Color} rolloverForeground the rollover foreground color
 * @sp {#Extent} width the component width
 * @event action An event fired when an item is selected (clicked).
 */
Echo.AbstractListComponent = Core.extend(Echo.Component, {

    $abstract: true,

    $load: function() {
        Echo.ComponentFactory.registerType("AbstractListComponent", this);
        Echo.ComponentFactory.registerType("LC", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "AbstractListComponent",

    /** @see Echo.Component#focusable */
    focusable: true,
    
    $virtual: {
        
        /**
         * Programmatically performs a list select action.
         */
        doAction: function() {
            this.fireEvent({type: "action", source: this, actionCommand: this.get("actionCommand")});
        }
    }
});

/**
 * ListBox component: a selection component which displays selection items in a
 * list. May be configured to allow the selection of one item at a time, or to
 * allow the selection of multiple items at one time. Does not support child
 * components.
 * 
 * @sp {Number} selectionMode a value indicating the selection mode, one of the
 *     following values:
 *     <ul>
 *     <li><code>Echo.ListBox.SINGLE_SELECTION</code> (the default)</li>
 *     <li><code>Echo.ListBox.MULTIPLE_SELECTION</code></li>
 *     </ul>
 */
Echo.ListBox = Core.extend(Echo.AbstractListComponent, {

    $static: {

        /**
         * Constant for <code>selectionMode</code> property indicating single selection.
         * @type Number
         */
        SINGLE_SELECTION: 0,
        
        /**
         * Constant for <code>selectionMode</code> property indicating multiple selection.
         * @type Number
         */
        MULTIPLE_SELECTION: 2
    },

    $load: function() {
        Echo.ComponentFactory.registerType("ListBox", this);
        Echo.ComponentFactory.registerType("LB", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "ListBox"
});

/**
 * SelectField component: a selection component which display selection items in
 * a drop-down field. Allows the selection of only one item at a time. Does not
 * support child components.
 */
Echo.SelectField = Core.extend(Echo.AbstractListComponent, {

    $load: function() {
        Echo.ComponentFactory.registerType("SelectField", this);
        Echo.ComponentFactory.registerType("SF", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "SelectField"
});

/**
 * Column component: a layout container which renders its content in a single
 * vertical column of cells. May contain zero or more child components. Does not
 * support pane components as children.
 * 
 * @sp {#Border} border the border displayed around the entire column
 * @sp {#Extent} cellSpacing the extent margin between cells of the column
 * @sp {#Insets} insets the inset margin between the column border and its cells
 * 
 * @ldp {#Alignment} alignment the alignment of the child component within its
 *      cell
 * @ldp {#Color} background the background of the child component's cell
 * @ldp {#FillImage} backrgoundImage the background image of the child
 *      component's cell
 * @ldp {#Extent} height the height of the child component's cell
 * @ldp {#Insets} insets the insets margin of the child component's cell (this
 *      inset is added to any inset set on the container component)
 */
Echo.Column = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Column", this);
        Echo.ComponentFactory.registerType("C", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Column"
});

/**
 * Composite component: a generic composite component abstract base class. This
 * class is intended to be used as base class for composite components. Provides
 * no rendering properties (other than those specified in Component). May
 * contain at most one child component. May not contain a pane component as a
 * child.
 * 
 * This class provides no benefit if you are providing a custom
 * synchronization/rendering peer. In such cases, <code>Echo.Component</code>
 * itself should be derived instead of this class.
 */
Echo.Composite = Core.extend(Echo.Component, {

    $abstract: true,
    
    $load: function() {
        Echo.ComponentFactory.registerType("Composite", this);
        Echo.ComponentFactory.registerType("CM", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Composite"
});

/**
 * Panel component: a single child container. Provides a configurable border,
 * margin, background image, and dimensions. May contain at most one child. May
 * contain pane components, and may be used as a means to add pane components to
 * containers which do not allow pane components as children. In such a case it
 * may be necessary to manually set the height property of the Panel itself.
 * 
 * @sp {#Alignment} alignment the alignment of the child component within the panel
 * @sp {#FillImage} backgroundImage the background image
 * @sp {#Border} border the border surrounding the child component
 * @sp {#Extent} height the height of the panel
 * @sp {#FillImageBorder} imageBorder an image-based border surrounding the child component (overrides <code>border</code>
 *     property when set)
 * @sp {#Insets} insets the inset padding margin between the panel border and its content
 * @sp {#Extent} width the width of the panel
 */
Echo.Panel = Core.extend(Echo.Composite, {

    $load: function() {
        Echo.ComponentFactory.registerType("Panel", this);
        Echo.ComponentFactory.registerType("P", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Panel"
});

/**
 * ContentPane component: a high-level container/layout object which fills a
 * region and optionally provides the capability to add floating panes (e.g.
 * <code>WindowPane</code>s) above that content. A ContentPane is often
 * suitable for use as a base class to extend when creating a composite (pane)
 * component. May contain at most one non-floating pane component as a child.
 * May contain zero or more floating pane components as children.
 * 
 * @sp {#FillImage} backgroundImage the background image
 * @sp {#Extent} horizontalScroll the horizontal scroll position
 * @sp {#Insets} insets the inset margin of the content
 * @sp {Number} overflow the scrollbar behavior used when content overflows the
 *     boundaries of the pane, one of the following values:
 *     <ul>
 *     <li><code>OVERFLOW_AUTO</code> (the default)</li>
 *     <li><code>OVERFLOW_HIDDEN</code> hide content that overflows</li>
 *     <li><code>OVERFLOW_SCROLL</code> always display scrollbars</li>
 *     </ul>
 * @sp {#Extent} verticalScroll the vertical scroll position
 */
Echo.ContentPane = Core.extend(Echo.Component, {

    $static: {
    
        /**
         * Setting for <code>overflow</code> property that scrollbars should be displayed when content overflows.
         * @type Number
         */
        OVERFLOW_AUTO: 0,

        /** 
         * Setting for <code>overflow</code> property indicating that overflowing content should be hidden.
         * @type Number 
         */
        OVERFLOW_HIDDEN: 1,

        /** 
         * Setting for <code>overflow</code> property indicating that scrollbars should always be displayed.
         * @type Number 
         */
        OVERFLOW_SCROLL: 2
    },

    $load: function() {
        Echo.ComponentFactory.registerType("ContentPane", this);
        Echo.ComponentFactory.registerType("CP", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "ContentPane",
    
    /** @see Echo.Component#pane */
    pane: true
});

/**
 * Grid component: a layout container which displays children in a grid.
 * Individual child component cells may be configured to span multiple rows or
 * columns using layout data. May contain zero or more components as children.
 * May not contain panes as children.
 * 
 * @sp {#Border} border the border displayed around the grid, and between cells
 * @sp {#Extent} columnWidth an indexed property whose indices represent the
 *     width of each column of the grid
 * @sp {#Extent} height the overall height of the grid
 * @sp {#Insets} insets the default inset margin displayed in each cell
 * @sp {Number} orientation a value indicating whether the grid will be laid out
 *     horizontally and then vertically or vice-versa, one of the following
 *     values:
 *     <ul>
 *     <li><code>ORIENTATION_HORIZONTAL</code> (the default) lay children out
 *     horizontally, then vertically</li>
 *     <li><code>ORIENTATION_VERTICAL</code> lay children out vertically,
 *     then horizontally</li>
 *     </ul>
 * @sp {#Extent} rowWidth an indexed property whose indices represent the height
 *     of each row of the grid
 * @sp {Number} size the number of cells to render before wrapping to the next
 *     column/row (default 2)
 * @sp {#Extent} width the overall width of the grid
 * @ldp {#Alignment} alignment the alignment of the child component within its
 *      cell
 * @ldp {#Color} background the background of the child component's cell
 * @ldp {#FillImage} backrgoundImage the background image of the child
 *      component's cell
 * @ldp {Number} columnSpan the number of column the containing cell should span
 *      (a value of <code>SPAN_FILL</code> indicates that cell should fill all
 *      columns until the end of the grid is reached; this value may only be
 *      used in this property for horizontally oriented grids)
 * @ldp {#Insets} insets the insets margin of the child component's cell (this
 *      inset is added to any inset set on the container component)
 * @ldp {Number} rowSpan the number of rows the containing cell should span (a
 *      value of <code>SPAN_FILL</code> indicates that cell should fill all
 *      rows until the end of the grid is reached; this value may only be used
 *      in this property for vertically oriented grids)
 */
Echo.Grid = Core.extend(Echo.Component, {

    $static: {

        /**
         * Constant value for <code>orientation</code> property indicating cells 
         * should be laid out horizontally and then vertically.
         * <code>ORIENTATION_HORIZONTAL</code> is the default orientation setting.
         * @type Number
         */
        ORIENTATION_HORIZONTAL: 0,
    
        /**
         * Constant value for <code>orientation</code> property indicating cells 
         * should be laid out vertically and then horizontally. 
         * @type Number
         */
        ORIENTATION_VERTICAL: 1,

        /**
         * A constant value for the <code>columnSpan</code> and <code>rowSpan</code>
         * properties of <code>LayoutData</code> objects used by children of a
         * Grid indicating that a cell should fill all remaining cells.  
         * <p>
         * <strong>WARNING</strong>: This value may ONLY be used for spans in the
         * direction of the layout of the <code>Grid</code>, i.e., it may only be 
         * used for column-spans if the orientation is horizontal, and it may only
         * be used for row-spans if the orientation is vertical.
         * @type Number
         */
        SPAN_FILL: -1
    },

    $load: function() {
        Echo.ComponentFactory.registerType("Grid", this);
        Echo.ComponentFactory.registerType("G", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Grid"
});

/**
 * Label component: displays a text string, an icon, or both. May not contain
 * child components.
 * 
 * @sp {Boolean} formatWhitespace a boolean flag indicating whether whitespace
 *     formatting should be applied to the label
 * @sp {Boolean} lineWrap a boolean flag indicating whether long lines should be
 *     wrapped
 * @sp {#ImageReference} icon the icon/image to display in the label
 * @sp {#Extent} iconTextMargin an extent setting describing the distance
 *     between the label and icon
 * @sp {String} text the text to display in the label
 * @sp {#Alignment} textAlignment an alignment setting describing the alignment
 *     of the label's text
 * @sp {#Alignment} textPosition an alignment setting describing the position of
 *     the label's text relative to the icon
 */
Echo.Label = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Label", this);
        Echo.ComponentFactory.registerType("L", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Label"
});

/**
 * Row component: a layout container which renders its content in a single horizontal row of cells.
 * May have zero or more child components.  Does not support pane components as children.
 *
 * @sp {#Border} border the border displayed around the entire column
 * @sp {#Extent} cellSpacing the extent margin between cells of the column
 * @sp {#Insets} insets the inset margin between the column border and its cells
 *
 * @ldp {#Alignment} alignment the alignment of the child component within its cell
 * @ldp {#Color} background the background of the child component's cell
 * @ldp {#FillImage} backrgoundImage the background image of the child component's cell
 * @ldp {#Insets} insets the insets margin of the child component's cell 
 *      (this inset is added to any inset set on the container component)
 * @ldp {#Extent} width the width of the child component's cell
 */
Echo.Row = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Row", this);
        Echo.ComponentFactory.registerType("R", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Row"
});

/**
 * SplitPane component: a pane component which displays two components
 * horizontally or vertically adjacent to one another, optionally allowing the
 * user to apportion space between the two using a resize handle. May have at
 * most two child components. Supports pane components as children.
 * 
 * @sp {Boolean} autoPositioned flag indicating whether the pane should set the
 *     separator position automatically based on size of first child. This
 *     feature is only available on vertically oriented panes, where the first
 *     child contains non-pane content.
 * @sp {Number} orientation the orientation of the SplitPane, one of the
 *     following values:
 *     <ul>
 *     <li><code>ORIENTATION_HORIZONTAL_LEADING_TRAILING</code> (the default)</li>
 *     <li><code>ORIENTATION_HORIZONTAL_TRAILING_LEADING</code></li>
 *     <li><code>ORIENTATION_HORIZONTAL_LEFT_RIGHT</code></li>
 *     <li><code>ORIENTATION_HORIZONTAL_RIGHT_LEFT</code></li>
 *     <li><code>ORIENTATION_VERTICAL_TOP_BOTTOM</code></li>
 *     <li><code>ORIENTATION_VERTICAL_BOTTOM_TOP</code></li>
 *     </ul>
 * @sp {Boolean} resizable flag indicating whether the pane separator can be
 *     moved
 * @sp {#Color} separatorColor the separator color
 * @sp {#Extent} separatorHeight the height of the separator (this property is
 *     used to determine the size of the separator in vertical orientations)
 * @sp {#FillImage} separatorHorizontalImage a FillImage used to paint the
 *     separator for horizontal orientations
 * @sp {#FillImage} separatorHorizontalRolloverImage a FillImage used to paint
 *     the separator for horizontal orientations when the mouse is over it
 * @sp {#Extent} separatorPosition an extent specifying the position of the
 *     separator
 * @sp {#Color} separatorRolloverColor the rollover separator color
 * @sp {#FillImage} separatorVerticalImage a FillImage used to paint the
 *     separator for vertical orientations
 * @sp {#FillImage} separatorVerticalRolloverImage a FillImage used to paint the
 *     separator for vertical orientations when the mouse is over it
 * @sp {#Extent} separatorWidth the width of the separator (this property is
 *     used to determine the size of the separator in horizontal orientations)
 * @ldp {#Alignment} alignment the alignment of the child component within its
 *      subpane
 * @ldp {#Color} background the background of the child component's subpane
 * @ldp {#FillImage} backrgoundImage the background image of the child
 *      component's subpane
 * @ldp {#Insets} insets the insets margin of the child component's subpane
 * @ldp {#Extent} maximumSize the maximum size of the child component's subpane
 * @ldp {#Extent} minimumSize the minimum size of the child component's subpane
 * @ldp {Number} overflow the layout behavior to use when the child component is
 *      larger than its containing subpane, one of the following values:
 *      <ul>
 *      <li><code>OVERFLOW_AUTO</code> (the default)</li>
 *      <li><code>OVERFLOW_HIDDEN</code></li>
 *      <li><code>OVERFLOW_SCROLL</code></li>
 *      </ul>
 */
Echo.SplitPane = Core.extend(Echo.Component, {

    $static: {
    
        /**
         * Orientation property value indicating a leading / trailing layout.
         * @type Number
         */
        ORIENTATION_HORIZONTAL_LEADING_TRAILING: 0,

        /**
         * Orientation property value indicating a trailing / leading layout.
         * @type Number
         */
        ORIENTATION_HORIZONTAL_TRAILING_LEADING: 1,
        
        /**
         * Orientation property value indicating a left / right layout.
         * @type Number
         */
        ORIENTATION_HORIZONTAL_LEFT_RIGHT: 2,
        
        /**
         * Orientation property value indicating a right / left layout.
         * @type Number
         */
        ORIENTATION_HORIZONTAL_RIGHT_LEFT: 3,
        
        /**
         * Orientation property value indicating a top / bottom layout.
         * @type Number
         */
        ORIENTATION_VERTICAL_TOP_BOTTOM: 4,

        /**
         * Orientation property value indicating a bottom / top layout.
         * @type Number
         */
        ORIENTATION_VERTICAL_BOTTOM_TOP: 5,
        
        /**
         * Default separator position.
         * @type #Extent
         */
        DEFAULT_SEPARATOR_POSITION: "50%",
        
        /**
         * Default separator size for fixed SplitPanes.
         * @type #Extent
         */
        DEFAULT_SEPARATOR_SIZE_FIXED: 0,

        /**
         * Default separator size for resizable SplitPanes.
         * @type #Extent
         */
        DEFAULT_SEPARATOR_SIZE_RESIZABLE: 4,
        
        /** 
         * Default separator color.
         * @type #Color
         */
        DEFAULT_SEPARATOR_COLOR: "#3f3f4f",
        
        /** 
         * Setting for <code>overflow</code> property that scrollbars should be displayed when content overflows. 
         * @type Number
         */
        OVERFLOW_AUTO: 0,

        /** 
         * Setting for <code>overflow</code> property indicating that overflowing content should be hidden.
         * @type Number
         */
        OVERFLOW_HIDDEN: 1,

        /** 
         * Setting for <code>overflow</code> property indicating that scrollbars should always be displayed. 
         * @type Number
         */
        OVERFLOW_SCROLL: 2
    },

    $load: function() {
        Echo.ComponentFactory.registerType("SplitPane", this);
        Echo.ComponentFactory.registerType("SP", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "SplitPane",

    /** @see Echo.Component#pane */
    pane: true
});

/**
 * Abstract base class for text-entry components.
 * 
 * @sp {String} actionCommand the action command fired when the enter key is
 *     pressed within the text component
 * @sp {#Alignment} alignment an alignment setting describing the alignment of
 *     the text
 * @sp {#FillImage} backgroundImage the background image to display in the
 *     component
 * @sp {#Border} border the border to display around the component
 * @sp {#Color} disabledBackground the disabled background color
 * @sp {#Color} disabledBackgroundImage the disabled background image
 * @sp {#Border} disabledBorder the disabled border
 * @sp {#Font} disabledFont the disabled font
 * @sp {#Color} disabledForeground the disabled foreground color
 * @sp {#Extent} height the height of the component
 * @sp {#Extent} horizontalScroll the horizontal scrollbar position
 * @sp {#Insets} insets the inset margin between the border and the text content
 * @sp {Number} maximumLength the maximum number of characters which may be
 *     entered
 * @sp {Number} selectionStart the character index of the beginning of the selection
 * @sp {Number} selectionEnd the character index of the end of the selection
 * @sp {String} toolTipText the tool tip text
 * @sp {#Extent} verticalScroll the vertical scrollbar position
 * @sp {#Extent} width the width of the component
 * @event action An event fired when the enter/return key is pressed while the
 *        field is focused.
 */
Echo.TextComponent = Core.extend(Echo.Component, {

    $abstract: true,

    $load: function() {
        Echo.ComponentFactory.registerType("TextComponent", this);
        Echo.ComponentFactory.registerType("TC", this);
    },

    $virtual: {
        
        /**
         * Programmatically performs a text component action.
         */
        doAction: function() {
            this.fireEvent({type: "action", source: this, actionCommand: this.get("actionCommand")});
        },
        
        /**
         * Notifies listeners of a key down event.
         * 
         * @param keyCode the (standardized) key code
         */
        doKeyDown: function(keyCode) {
            var e = { type: "keyDown", source: this, keyCode: keyCode };
            this.fireEvent(e);
            return !e.veto;
        },
        
        /**
         * Notifies listeners of a key press event.
         * 
         * @param keyCode the (standardized) key code
         * @param charCode the charater code
         */
        doKeyPress: function(keyCode, charCode) {
            var e = { type: "keyPress", source: this, keyCode: keyCode, charCode: charCode };
            this.fireEvent(e);
            return !e.veto;
        }
    },

    /** @see Echo.Component#componentType */
    componentType: "TextComponent",

    /** @see Echo.Component#focusable */
    focusable: true
});

/**
 * TextArea component: a multiple-line text input field. May not contain child
 * components.
 */
Echo.TextArea = Core.extend(Echo.TextComponent, {

    $load: function() {
        Echo.ComponentFactory.registerType("TextArea", this);
        Echo.ComponentFactory.registerType("TA", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "TextArea"
});

/**
 * TextField component: a single-line text input field. May not contain child
 * components.
 */
Echo.TextField = Core.extend(Echo.TextComponent, {

    $load: function() {
        Echo.ComponentFactory.registerType("TextField", this);
        Echo.ComponentFactory.registerType("TF", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "TextField"
});

/**
 * PasswordField component: a single-line text input field which masks input.
 * May not contain child components.
 */
Echo.PasswordField = Core.extend(Echo.TextField, {

    $load: function() {
        Echo.ComponentFactory.registerType("PasswordField", this);
        Echo.ComponentFactory.registerType("PF", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "PasswordField"
});

/**
 * WindowPane component: displays content in a movable and/or resizable window.
 * May only be added to a <code>ContentPane</code>. May contain at most one
 * child component. May contain pane components as children.
 * 
 * @sp {#FillImage} backgroundImage the background image to display within the
 *     content area
 * @sp {#FillImageBorder} border the border frame containing the WindowPane
 * @sp {Boolean} closable flag indicating whether the window is closable
 * @sp {#ImageReference} closeIcon the close button icon
 * @sp {#Insets} closeIconInsets the inset margin around the close button icon
 * @sp {#ImageReference} closeRolloverIcon the close button rollover icon
 * @sp {#Extent} contentHeight the height of the content region of the window
 * @sp {#Extent} contentWidth the width of the content region of the window
 * @sp {#Insets} controlsInsets the inset margin around the controls area
 * @sp {#Extent} controlsSpacing the spacing between controls in the controls
 *     area
 * @sp {#Extent} height the outside height of the window, including its border
 * @sp {#ImageReference} icon the icon to display adjacent the window title
 * @sp {#Insets} iconInsets the inset margin around the icon
 * @sp {#Insets} insets the inset margin around the window content
 * @sp {Boolean} maximizeEnabled flag indicating whether maximize feature should
 *     be enabled
 * @sp {#ImageReference} maximizeIcon the minimize button icon
 * @sp {#Insets} maximizeIconInsets the inset margin around the maximize button
 *     icon
 * @sp {#ImageReference} maximizeRolloverIcon the maximize button rollover icon
 * @sp {#Extent} maximumHeight the maximum height of the window
 * @sp {#Extent} maximumWidth the maximum width of the window
 * @sp {Boolean} minimizeEnabled flag indicating whether maximize feature should
 *     be enabled
 * @sp {#ImageReference} minimizeIcon the minimize button icon
 * @sp {#Insets} minimizeIconInsets the inset margin around the minimize button
 *     icon
 * @sp {#ImageReference} minimizeRolloverIcon the minimize button rollover icon
 * @sp {#Extent} minimumHeight the minimum height of the window
 * @sp {#Extent} minimumWidth the minimum width of the window
 * @sp {Boolean} movable flag indicating whether the window is movable
 * @sp {#Extent} positionX the horizontal (x) position of the window
 * @sp {#Extent} positionY the vertical (y) position of the window
 * @sp {Boolean} resizable flag indicating whether the window is resizable
 * @sp {String} title the title of the window
 * @sp {#Color} titleBackground the background color to display in the title bar
 * @sp {#FillImage} titleBackgroundImage the background image to display in the
 *     title bar
 * @sp {#Font} titleFont the font in which to display the title text
 * @sp {#Color} titleForeground the foreground color of the title text
 * @sp {#Extent} titleHeight the height of the title bar
 * @sp {#Insets} titleInsets the inset margin of the title text
 * @sp {#Extent} width the outside width of the window, including its border
 * @event close An event fired when the close button is pressed.
 * @event maximize An event fired when the maximize button is pressed.
 * @event minimize An event fired when the minimize button is pressed.
 */
Echo.WindowPane = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("WindowPane", this);
        Echo.ComponentFactory.registerType("WP", this);
    },

    $static: {
        
        /** 
         * Default WindowPane border.
         * @type #FillImageBorder
         */
        DEFAULT_BORDER: { color: "#36537a", borderInsets: 20, contentInsets: 3 },
        
        /** 
         * Default WindowPane content background color.
         * @type #Color
         */
        DEFAULT_BACKGROUND: "#ffffff",
        
        /** 
         * Default WindowPane content background color.
         * @type #Color
         */
        DEFAULT_FOREGROUND: "#000000",
        
        /** 
         * Default insets around WindowPane controls.
         * @type #Insets
         */
        DEFAULT_CONTROLS_INSETS: 4,
        
        /** 
         * Default spacing between WindowPane controls.
         * @type #Extent
         */
        DEFAULT_CONTROLS_SPACING: 4,
        
        /** 
         * Default WindowPane height.
         * @type #Extent
         */
        DEFAULT_HEIGHT: "15em",
        
        /** 
         * Default WindowPane minimum width.
         * @type #Extent
         */
        DEFAULT_MINIMUM_WIDTH: 100,
        
        /** 
         * Default WindowPane minimum height.
         * @type #Extent
         */
        DEFAULT_MINIMUM_HEIGHT: 100,
        
        /** 
         * Default WindowPane title background color.
         * @type #Color
         */
        DEFAULT_TITLE_BACKGROUND: "#becafe",
        
        /** 
         * Default WindowPane title height.
         * @type #Extent
         */
        DEFAULT_TITLE_HEIGHT: 30,
        
        /** 
         * Default WindowPane title insets.
         * @type #Insets
         */
        DEFAULT_TITLE_INSETS: "5px 10px",
        
        /** 
         * Default WindowPane width.
         * @type #Extent
         */
        DEFAULT_WIDTH: "30em"
    },

    /** @see Echo.Component#componentType */
    componentType: "WindowPane",
    
    /** @see Echo.Component#modalSupport */
    modalSupport: true,
    
    /**
     * Render as floating pane in ContentPanes. 
     * @see Echo.ContentPane 
     */
    floatingPane: true,

    /** @see Echo.Component#pane */
    pane: true,
    
    /** @see Echo.Component#focusable */
    focusable: true,
    
    /** 
     * Object specifying state of window pane before it was maximized,
     * May contain x, y, width, height integer properties or be null.
     */
    _preMaximizedState: null,
    
    /**
     * Processes a user request to close the window.
     */
    userClose: function() {
        this.fireEvent({type: "close", source: this});
    },
    
    /**
     * Processes a user request to maximize the window.
     */
    userMaximize: function() {
        if (this.render("width") == "100%" && this.render("height") == "100%") {
            if (this._preMaximizedState) {
                this.set("width", this._preMaximizedState.width);
                this.set("height", this._preMaximizedState.height);
                this.set("positionX", this._preMaximizedState.x);
                this.set("positionY", this._preMaximizedState.y);
            }
        } else {
            this._preMaximizedState = { 
                    x: this.get("positionX"), y: this.get("positionY"),
                    width: this.get("width"), height: this.get("height") };
            this.set("width", "100%");
            this.set("height", "100%");
        }
        this.fireEvent({type: "maximize", source: this});
    },
    
    /**
     * Processes a user request to minimize the window.
     */
    userMinimize: function() {
        this.fireEvent({type: "minimize", source: this});
    }
});
/**
 * @namespace
 * Module for rendering state of application to DOM.
 * <ul>
 *  <li>Provides capability to process updates in Application UpdateManager,
 *   rendering state changes to the DOM.</li>
 *  <li>Provides component synchronization peer base class.</li>
 *  <li>Provides root component synchronization peer implementation.</li>
 *  <li>Provides rendering utilities for the core properties.</li>
 * </ul>
 * 
 * <h3>renderContext</h3>
 * 
 * <p>This object will add a <code>renderContext</code> property to all <code>Echo.Update.ComponentUpdate</code>
 * objects which are processed by it.
 */

/**
 * Application rendering namespace.
 * @namespace
 */
Echo.Render = {

    /**
     * Count of loaded/unloaded peers.  Used for testing purposes to ensure peers are not being leaked.
     * @type Number
     */
    _loadedPeerCount: 0,

    /**
     * Next sequentially assigned unique peer identifier.
     * @type Number
     */
    _nextPeerId: 0,
    
    /**
     * Mapping between component type names and instantiable peer classes.
     */
    _peers: {},
    
    /**
     * Map containing removed components.  Maps component ids to removed components.
     * Created and destroyed during each render.
     */
    _disposedComponents: null,
    
    /**
     * An array sorting implementation to organize an array by component depth.
     * @see Array#sort
     */
    _componentDepthArraySort: function(a, b) {
        return Echo.Render._getComponentDepth(a.parent) - Echo.Render._getComponentDepth(b.parent);
    },
    
    /**
     * Recursively invokes renderDisplay() method on a sub-hierarchy of the
     * component hierarchy.  If a peer does not provide a renderDisplay() implementation,
     * it is skipped (although its descendants will NOT be skipped).
     * 
     * @param {Echo.Component} the root component of the sub-hierarchy on which renderDisplay() should be invoked
     * @param {Boolean} includeSelf flag indicating whether renderDisplay() should be invoked on the
     *        specified component (if false, it will only be invoked on child components)
     */
    _doRenderDisplay: function(component, includeSelf) {
        // Ensure component is visible.
        var i, testComponent = component;
        var testParent = testComponent.parent;
        while (testParent) {
            if (testParent.peer.isChildVisible && !testParent.peer.isChildVisible(testComponent)) {
                // Do nothing for components that are not visible. 
                return;
            }
            testComponent = testParent;
            testParent = testParent.parent;
        }
        
        if (includeSelf) {
            Echo.Render._doRenderDisplayImpl(component);
        } else {
            if (component.peer.isChildVisible) {
                for (i = 0; i < component.children.length; ++i) {
                    if (component.peer.isChildVisible(component.children[i])) {
                        Echo.Render._doRenderDisplayImpl(component.children[i]);
                    }
                }
            } else {
                for (i = 0; i < component.children.length; ++i) {
                    Echo.Render._doRenderDisplayImpl(component.children[i]);
                }
            }
        }
    },
    
    /**
     * Recursive work method for _doRenderDisplay().  
     * 
     * @param {Echo.Component} component the component on which to invoke renderDisplay()
     */
    _doRenderDisplayImpl: function(component) {
        if (!component.peer) {
            // Do nothing for components that are not rendered. 
            return;
        }
        
        if (component.peer.renderDisplay) {
            component.peer.renderDisplay();
        }
        component.peer.displayed = true;
        
        var i;
        if (component.peer.isChildVisible) {
            for (i = 0; i < component.children.length; ++i) {
                if (component.peer.isChildVisible(component.children[i])) {
                    Echo.Render._doRenderDisplayImpl(component.children[i]);
                }
            }
        } else {
            for (i = 0; i < component.children.length; ++i) {
                Echo.Render._doRenderDisplayImpl(component.children[i]);
            }
        }
    },
    
    /**
     * Returns the depth of a specific component in the hierarchy.
     * The root component is at depth 0, its immediate children are
     * at depth 1, their children are at depth 2, and so on.
     *
     * @param {Echo.Component} component the component whose depth is to be calculated
     * @return the depth of the component
     * @type Number
     */
    _getComponentDepth: function(component) {
        var depth = -1;
        while (component != null) {
            component = component.parent;
            ++depth;
        }
        return depth;
    },
    
    /**
     * Creates a component synchronization peer for a component.
     * The peer will be stored in the "peer" property of the component.
     * The client will be stored in the "client" property of the component.
     * 
     * @param {Echo.Client} client the relevant Client
     * @param {Echo.Component} component the component
     */
    _loadPeer: function(client, component) {
        if (component.peer) {
            // If peer already loaded, do nothing.
            return;
        }
        
        var peerClass = Echo.Render._peers[component.componentType];
        
        if (!peerClass) {
            throw new Error("Peer not found for: " + component.componentType);
        }
        
        ++this._loadedPeerCount;        
        component.peer = new peerClass();
        component.peer._peerId = this._nextPeerId++;
        component.peer.component = component;
        component.peer.client = client;
    },
    
    /**
     * Notifies child components that the parent component has been drawn
     * or resized.  At this point the parent component is on the screen
     * (the parent element is part of the DOM hierarchy).
     * Child components (and their descendants) will be notified by having 
     * their renderDisplay() implementations invoked.
     * Note that the parent WILL NOT have its renderDisplay() method
     * invoked.
     * <p>
     * If your component requires virtual positioning (for IE6) you should invoke
     * this method after informing the virtual positioning system to recalculate
     * the size of your component.
     * 
     * @param {Echo.Component} parent the component whose size changed
     */
    notifyResize: function(parent) {
        Echo.Render._doRenderDisplay(parent, false);
    },
    
    /**
     * Invokes renderDispose() on all removed children and descendants found in the specified update.
     * 
     * @param {Echo.Update.ComponentUpdate} update the update
     */
    _processDispose: function(update) {
        var i, components = update.getRemovedDescendants();
        if (components) {
            for (i = 0; i < components.length; ++i) {
                Echo.Render._renderComponentDisposeImpl(update, components[i]);
            }
        }
        components = update.getRemovedChildren();
        if (components) {
            for (i = 0; i < components.length; ++i) {
                Echo.Render._renderComponentDisposeImpl(update, components[i]);
            }
        }
    },
    
    /**
     * Processes all pending updates in the client's application's update manager.
     * 
     * @param {Echo.Client} client the client
     */
    processUpdates: function(client) {
        var updateManager = client.application.updateManager;
        
        // Do nothing if no updates exist.
        if (!updateManager.hasUpdates()) {
            return;
        }
        
        // Create map to contain removed components (for peer unloading).
        Echo.Render._disposedComponents = {};
        
        // Retrieve updates, sorting by depth in hierarchy.  This will ensure that higher
        // level updates have a chance to execute first, in case they null out lower-level
        // updates if they require re-rendering their descendants.
        var updates = updateManager.getUpdates();
        updates.sort(Echo.Render._componentDepthArraySort);
        
        var peer, i, j;
    
        // Load peers for any new root components being updated.
        for (i = 0; i < updates.length; ++i) {
            updates[i].renderContext = {};
        
            peer = updates[i].parent.peer;
            if (peer == null && updates[i].parent.componentType == "Root") {
                Echo.Render._loadPeer(client, updates[i].parent);
            }
        }
    
        // Remove Phase: Invoke renderDispose on all updates.
        for (i = updates.length - 1; i >= 0; --i) {
            if (updates[i] == null) {
                // Skip removed updates.
                continue;
            }
            peer = updates[i].parent.peer;
            Echo.Render._processDispose(updates[i]);
        }
        
        // Profiling: Mark completion of remove phase. 
        if (Echo.Client.profilingTimer) {
            Echo.Client.profilingTimer.mark("rem");
        }
        
        // Update Phase: Invoke renderUpdate on all updates.
        for (i = 0; i < updates.length; ++i) {
            if (updates[i] == null) {
                // The update has been removed, skip it.
                continue;
            }
            
            // Obtain component synchronization peer.
            peer = updates[i].parent.peer;
            
            // Perform update by invoking peer's renderUpdate() method.
            var fullRender = peer.renderUpdate(updates[i]);
            
            // If the update required re-rendering descendants of the updated component,
            // null-out any pending updates to descendant components.
            if (fullRender) {
                for (j = i + 1; j < updates.length; ++j) {
                    if (updates[j] != null && updates[i].parent.isAncestorOf(updates[j].parent)) {
                        updates[j] = null;
                    }
                }
            }

            // Invoke _setPeerDisposedState() to ensure that peer is marked as non-disposed.
            // (A full-re-render may have invoked renderComponentDispose()).
            Echo.Render._setPeerDisposedState(updates[i].parent, false);
        }
        
        // Profiling: Mark completion of update phase.
        if (Echo.Client.profilingTimer) {
            Echo.Client.profilingTimer.mark("up");
        }
        
        // Display Phase: Invoke renderDisplay on all updates.
        // The "displayed" array holds component who have already had renderDisplay() invoked on themselves (and their descendants).
        // This is done to avoid invoking renderDisplay() multiple times on a single component during a single rendering.
        var displayed = [];
        for (i = 0; i < updates.length; ++i) {
            if (updates[i] == null) {
                // Skip removed updates.
                continue;
            }
            
            // Determine if component hierarchy has already had renderDisplay() invoked, skipping to next update if necessary.
            var cancelDisplay = false;
            for (j = 0; j < displayed.length; ++j) {
                if (displayed[j].isAncestorOf(updates[i].parent)) {
                    cancelDisplay = true;
                    break;
                }
            }
            if (cancelDisplay) {
                continue;
            }
            
            if (updates[i].renderContext.displayRequired) {
                // The renderContext has specified only certain child components should have their
                // renderDisplay() methods invoked.
                for (j = 0; j < updates[i].renderContext.displayRequired.length; ++j) {
                    displayed.push(updates[i].renderContext.displayRequired[j]);
                    Echo.Render._doRenderDisplay(updates[i].renderContext.displayRequired[j], true);
                }
            } else {
                displayed.push(updates[i].parent);
                Echo.Render._doRenderDisplay(updates[i].parent, true);
            }
        }
    
        // Profiling: Mark completion of display phase.
        if (Echo.Client.profilingTimer) {
            Echo.Client.profilingTimer.mark("disp");
        }
    
        // Unload peers for truly removed components, destroy mapping.
        for (var peerId in Echo.Render._disposedComponents) {
            var component = Echo.Render._disposedComponents[peerId];
            Echo.Render._unloadPeer(component);
        }

        // Clear disposed component list.
        Echo.Render._disposedComponents = null;
        
        // Inform UpdateManager that all updates have been completed.
        updateManager.purge();
        
        // Perform focus update.
        Echo.Render.updateFocus(client);
    },
    
    /**
     * Registers a component type name with an instantiable peer class.
     * Components of the specified type name will be assigned new instances of the peer class
     * when rendered for the first time.
     * 
     * @param {String} componentName the component type name
     * @param {Function} peerObject the peer class object
     */
    registerPeer: function(componentName, peerObject) {
        if (this._peers[componentName]) {
            throw new Error("Peer already registered: " + componentName);
        }
        this._peers[componentName] = peerObject;
    },
    
    /**
     * Renders a new component inside of a DOM element.
     * This method should be called by container components in order to render their children.
     * 
     * @param {Echo.Update.ComponentUpdate} update the relevant ComponentUpdate
     * @param {Echo.Component} component the component to add
     * @param {Element} parentElement the DOM element to which the rendered component should be added
     */
    renderComponentAdd: function(update, component, parentElement) {
        if (!component.parent || !component.parent.peer || !component.parent.peer.client) {
            throw new Error("Cannot find reference to the Client with which this component should be associated: " +
                    "cannot load peer.  This is due to the component's parent's peer not being associated with a Client. " +
                    "Component = " + component + ", Parent = " + component.parent + ", Parent Peer = " + 
                    (component.parent ? component.parent.peer : "N/A") + ", Parent Peer Client = " + 
                    ((component.parent && component.parent.peer) ? component.parent.peer.client : "N/A"));
        }
    
        Echo.Render._loadPeer(component.parent.peer.client, component);
        Echo.Render._setPeerDisposedState(component, false);
        component.peer.renderAdd(update, parentElement);
    },
    
    /**
     * Manually invokes renderDisplay on a component (and its descendants) that was added to the
     * hierarchy outside of processUpdates().  This method is only used in special cases,
     * e.g., by in the case of Application Rendered Components that need to render children.
     * 
     * @param {Echo.Component} parent the parent component of the sub-hierarchy on which renderDisplay() should
     *        be invoked (note that renderDisplay WILL be invoked on the parent as well 
     *        as its descendants)
     */
    renderComponentDisplay: function(parent) {
        this._doRenderDisplay(parent, true);
    },
    
    /**
     * Disposes of a component and its descendants.
     * This method should be invoked by any peer that will be updating a component in such
     * a fashion that it will be destroying the rendering of its children and re-rendering them.
     * It is not necessary to invoke this method on components that may not contain children.
     *
     * @param {Echo.Update.ComponentUpdate} update the <code>ComponentUpdate</code> for which this change is being performed
     * @param {Echo.Component} component the <code>Component</code> to be disposed
     */
    renderComponentDispose: function(update, component) {
        this._renderComponentDisposeImpl(update, component);
    },
    
    /**
     * Recursive implementation of renderComponentDispose.  Invokes
     * renderDispose() on all child peers, sets disposed state on each.
     * 
     * @param {Echo.Update.ComponentUpdate} update the <code>ComponentUpdate</code> for which this change is being performed
     * @param {Echo.Component} component the <code>Component</code> to be disposed
     */
    _renderComponentDisposeImpl: function(update, component) {
        if (!component.peer || component.peer.disposed) {
            return;
        }
        Echo.Render._setPeerDisposedState(component, true);
    
        component.peer.renderDispose(update);
        for (var i = 0; i < component.children.length; ++i) {
            Echo.Render._renderComponentDisposeImpl(update, component.children[i]);
        }
    },
    
    /**
     * Notifies a child component and its descendants that it is about to be removed from the DOM or otherwise hidden from view.
     * The <code>renderHide()</code> methods of the peers of the specified child component and its descendants will be invoked.
     * <strong>It is absolutely critical that this method be invoked before the component's rendered state is removed from the DOM 
     * hierarchy.</strong>
     * 
     * @param {Echo.Component} component the child component being hidden
     */
    renderComponentHide: function(component) {
        if (!component.peer || component.peer.disposed) {
            return;
        }
        
        if (component.peer.displayed) {
            if (component.peer.renderHide) {
                component.peer.renderHide();
            }
            component.peer.displayed = false;
            for (var i = 0; i < component.children.length; ++i) {
                Echo.Render.renderComponentHide(component.children[i]);
            }
        }
    },
    
    /**
     * Sets the peer disposed state of a component.
     * The peer disposed state indicates whether the renderDispose()
     * method of the component has been executed since it was last rendered.
     * 
     * @param {Echo.Component} component the component
     * @param {Boolean} disposed the disposed state, true indicating the component has
     *        been disposed
     */
    _setPeerDisposedState: function(component, disposed) {
        if (disposed) {
            component.peer.disposed = true;
            Echo.Render._disposedComponents[component.peer._peerId] = component;
        } else {
            component.peer.disposed = false;
            delete Echo.Render._disposedComponents[component.peer._peerId];
        }
    },
    
    /**
     * Destroys a component synchronization peer for a specific components.
     * The peer will be removed from the "peer" property of the component.
     * The client will be removed from the "client" property of the component.
     * The peer to component association will be removed.
     * 
     * @param {Echo.Component} component the component
     */
    _unloadPeer: function(component) {
        component.peer.client = null;
        component.peer.component = null;
        component.peer = null;
        --this._loadedPeerCount;        
    },

    /**
     * Focuses the currently focused component of the application.  
     *
     * This method may be necessary to invoke manually by component renderers
     * that use animation and may be hiding the focused component (such that
     * the client browser will not focus it) when processUpdates() completes.
     * 
     * @param {Echo.Client} client the client 
     */
    updateFocus: function(client) {
        var focusedComponent = client.application.getFocusedComponent();
        if (focusedComponent && focusedComponent.peer) {
            if (!focusedComponent.peer.renderFocus) {
                throw new Error("Cannot focus component: " + focusedComponent + 
                        ", peer does not provide renderFocus() implementation."); 
            }
            focusedComponent.peer.renderFocus();
        }
    }
};

/**
 * Component synchronization peer. 
 * @class
 */
Echo.Render.ComponentSync = Core.extend({ 

    $static: {
    
        /**
         * Focus flag indicating up arrow keypress events should be handled by focus manager when
         * the component is focused.
         * @type Number
         */
        FOCUS_PERMIT_ARROW_UP: 0x1,

        /**
         * Focus flag indicating down arrow keypress events should be handled by focus manager when
         * the component is focused.
         * @type Number
         */
        FOCUS_PERMIT_ARROW_DOWN: 0x2, 

        /**
         * Focus flag indicating left arrow keypress events should be handled by focus manager when
         * the component is focused.
         * @type Number
         */
        FOCUS_PERMIT_ARROW_LEFT: 0x4,
        
        /**
         * Focus flag indicating right arrow keypress events should be handled by focus manager when
         * the component is focused.
         * @type Number
         */
        FOCUS_PERMIT_ARROW_RIGHT: 0x8, 

        /**
         * Focus flag indicating all arrow keypress events should be handled by focus manager when
         * the component is focused.
         * @type Number
         */
        FOCUS_PERMIT_ARROW_ALL: 0xf,
        
        /**
         * Dimension value for <code>getPreferredSize()</code> indicating height should be calculated.
         * @type Number
         */
        SIZE_HEIGHT: 0x1,
        
        /**
         * Dimension value for <code>getPreferredSize()</code> indicating width should be calculated.
         * @type Number
         */
        SIZE_WIDTH: 0x2
    },
    
    /**
     * Unique peer identifier, for internal use only.
     * Using component renderId is inadequate, as two unique component instances may have same id across
     * add-remove-add operations.
     * @type Number
     */
    _peerId: null,

    /**
     * The client supported by this peer.
     * @type Echo.Client
     */
    client: null,

    /**
     * The component instance supported by this peer.  
     * Each peer instance will support a single component instance.
     * @type Echo.Component
     */
    component: null,
    
    /**
     * Flag indicating whether component is displayed or hidden.  Initially false until <code>renderDisplay()</code> has been
     * invoked, then will be set to true.  Will again be set false after invocation of <code>renderHide()</code>.
     */
    displayed: false,
    
    /**
     * Flag indicating that the component has been disposed, i.e., the peer's <code>renderDispose()</code> method 
     * has run since the last time <code>renderAdd()</code> was last invoked.
     * @type Boolean
     */
    disposed: false,

    /**
     * Creates a new component synchronization peer.
     */
    $construct: function() { },
    
    $abstract: {

        /**
         * Renders the component to the DOM.
         * The supplied update will refer to a ancestor component of the supported component
         * being updated.
         *
         * @param {Echo.Update.ComponentUpdate} update the update being rendered
         * @param {Element} parentElement the parent DOM element to which the component should be rendered.
         */
        renderAdd: function(update, parentElement) { },

        /**
         * Invoked when the rendered component is about to be removed from the DOM.
         * This method should dispose of any client resources in use by the component, e.g.,
         * unregistering event listeners and removing any DOM elements that are not children of
         * the parent component's DOM element.
         * The DOM should NOT be modified to remove the element(s) representing this component
         * for performance as well as aesthetic reasons (e.g., in the case where a parent component
         * might be using an animated transition effect to remove the component.
         * The supplied update will refer to a ancestor component of the supported component
         * being updated.
         *
         * A component may be re-added to the screen after being disposed, e.g., in the case
         * where a parent component does not possess a 'partial update' capability and removes
         * a child component hierarchy and then re-renders it.  A synchronization peer should
         * allow for the fact that its renderAdd() method may be invoked at some point in time
         * after renderDispose() has been invoked.
         *        
         * @param {Echo.Update.ComponentUpdate} update the update being rendered
         */
        renderDispose: function(update) { },
        
        /**
         * Renders an update to a component, e.g., children added/removed, properties updated.
         * The supplied update will refer specifically to an update of the supported component.
         * 
         * The provided update will contain a <code>renderContext</code> object property.
         * The following properties of <code>renderContext</code> may be configured by the
         * implementation, if desired:
         *  
         * <ul>
         *  <li><code>displayRequired</code>: an array of child component objects whose synchronization peers should have their
         *  renderDisplay() methods invoked once the update cycle is complete.  The default value of null indicates the peers
         *  of all descendant components and the updated component itself will have their renderDisplay() methods invoked.
         *  Specifying an empty array will cause NO components to have their renderDisplay() methods invoked.
         *  This property is generally used on container components (or application-rendered components) which may have property
         *  updates that need not cause renderDisplay() to be invoked on their entire descendant tree for performance reasons.
         * </ul> 
         *
         * @param {Echo.Update.ComponentUpdate} update the update being rendered
         * @return true if this invocation has re-rendered all child components, false otherwise
         * @type Boolean
         */
        renderUpdate: function(update) { }
    },
    
    $virtual: {
    
        /**
         * (Optional) Processes a key down event received by the client's key listeners.  
         * Invoked by client based on current focused component of application.
         * 
         * @function
         * @param e the key event, containing (processed) keyCode property
         * @return true if higher-level containers should be allowed to process the key event as well
         * @type Boolean
         */
        clientKeyDown: null,

        /**
         * (Optional) Processes a key press event received by the client's key listeners.  
         * Invoked by client based on current focused component of application.
         * 
         * @function
         * @param e the key event, containing (processed) charCode and keyCode properties
         * @return true if higher-level containers should be allowed to process the key event as well
         * @type Boolean
         */
        clientKeyPress: null,
        
        /**
         * (Optional) Processes a key up event received by the client's key listeners.  
         * Invoked by client based on current focused component of application.
         * 
         * @function
         * @param e the key event, containing (processed) charCode and keyCode properties
         * @return true if higher-level containers should be allowed to process the key event as well
         * @type Boolean
         */
        clientKeyUp: null,
        
        /**
         * Returns the focus flags for the component, one or more of the following values, ORed together.
         * <ul>
         *  <li><code>FOCUS_PERMIT_ARROW_UP</code>: indicates that the container may change focus from the current component if
         *   the up arrow key is pressed.</li>
         *  <li><code>FOCUS_PERMIT_ARROW_DOWN</code>: indicates that the container may change focus from the current component if
         *   the down arrow key is pressed.</li>
         *  <li><code>FOCUS_PERMIT_ARROW_LEFT</code>: indicates that the container may change focus from the current component if
         *   the left arrow key is pressed.</li>
         *  <li><code>FOCUS_PERMIT_ARROW_RIGHT</code>: indicates that the container may change focus from the current component if
         *   the right arrow key is pressed.</li>
         *  <li><code>FOCUS_PERMIT_ARROW_ALL</code>: indicates that the container may change focus from the current component if
         *   any arrow key is pressed (this is a shorthand for up, left, down, and right ORed together).</li>
         * </ul>
         * 
         * @function
         * @return the focus flags
         * @type Number
         */
        getFocusFlags: null,
        
        /**
         * (Optional) Returns the preferred rendered size of the component in pixels.  Certain parent
         * components may query this method during <code>renderDisplay()</code> to determine
         * the space provided to the child component.  If implemented, this method should return
         * an object containing height and/or width properties specifying integer pixel values.
         * 
         * @function
         * @param dimension the dimension to be calculated, one of the following values, or null
         *        to specify that all dimensions should be calculated:
         *        <ul>
         *         <li><code>SIZE_WIDTH</code></li>
         *         <li><code>SIZE_HEIGHT</code></li>
         *        </ul>
         * @return the preferred rendered size of the component
         */
        getPreferredSize: null,
        
        /**
         * (Optional) Determines if the specified child component is currently displayed.  Implementations
         * should return true if the specified child component is on-screen and should have its <code>renderDisplay()</code>
         * method invoked when required, or false if the component is off-screen.
         * 
         * @function
         * @param component the child component
         * @return true if the component should have its renderDisplay() method invoked
         * @type Boolean
         */
        isChildVisible: null,
        
        /**
         * (Optional) Invoked when component is rendered focused.
         * 
         * @function
         */
        renderFocus: null,
        
        /**
         * (Optional) Invoked when a parent/ancestor component is hiding the content of this component, possibly removing it from
         * the DOM.  An parent/ancestor DOM element will automatically be removed/hidden, but the component may need to take action 
         * to remove any rendered items not contained within that element.
         * The renderDisplay() method will be invoked the when/if the component is displayed again.
         * This method may be invoked on components which are already in a hidden state.
         * This method will not necessarily be invoked prior to disposal.
         * 
         * @function
         */
        renderHide: null,
        
        /**
         * (Optional) Invoked when the component has been added (or-readded) to the hierarchy and first appears
         * on screen, and when ancestors of the component (or the containing window) have
         * resized.
         * 
         * @function
         */
        renderDisplay: null
    }
});

/**
 * Root component synchronization peer.
 * The root component is not managed by the server, but rather is an existing
 * element within which the Echo application is rendered.
 * This is a very special case in that there is no renderAdd() method.
 */
Echo.Render.RootSync = Core.extend(Echo.Render.ComponentSync, { 

    $load: function() {
        Echo.Render.registerPeer("Root", this);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        throw new Error("Unsupported operation: renderAdd().");
    },
    
    /**
     * Removes all content from root container and adds current content.
     * 
     * @param {Echo.Update.ComponentUpdate} update the causing update 
     */
    _renderContent: function(update) {
        Echo.Render.renderComponentDispose(update, update.parent);
        Core.Web.DOM.removeAllChildren(this.client.domainElement);
        for (var i = 0; i < update.parent.children.length; ++i) {
            Echo.Render.renderComponentAdd(update, update.parent.children[i], this.client.domainElement);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) { },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var property, fullRender = false;

        if (update.fullRefresh || update.hasAddedChildren() || update.hasRemovedChildren()) {
            Echo.Sync.renderComponentDefaults(this.component, this.client.domainElement);
            var title = this.component.render("title");
            if (title) {
                document.title = title;
            }
            this._renderContent(update);
            fullRender = true;
        } else {
            this.client.domainElement.dir = this.client.application.getLayoutDirection().isLeftToRight() ? "ltr" : "rtl";
            if (update.hasUpdatedProperties()) {
                property = update.getUpdatedProperty("title");
                if (property) {
                    document.title = property.newValue;
                }
                property = update.getUpdatedProperty("background");
                if (property) {
                    Echo.Sync.Color.renderClear(property.newValue, this.client.domainElement, "backgroundColor");
                }
                property = update.getUpdatedProperty("foreground");
                if (property) {
                    Echo.Sync.Color.renderClear(property.newValue, this.client.domainElement, "foreground");
                }
                property = update.getUpdatedProperty("font");
                if (property) {
                    Echo.Sync.Font.renderClear(property.newValue, this.client.domainElement);
                }
                Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this.client.domainElement);
            }
        }
        
        return fullRender;
    }
});
/**
 * @fileoverview
 * <ul> 
 *  <li>Provides property rendering utilities for core properties.</li>
 *  <li>Provides TriCellTable rendering utility (used by buttons and labels).</li>
 *  <li>Provides a floating pane z-index management system.</li> 
 * </ul>
 */

/**
 * @namespace
 */
Echo.Sync = { 

    /**
     * Retrieves an "effect-specific" property from a component (e.g., a rollover background) if it
     * is available, or otherwise returns the default (non-effect) property value.
     * 
     * @param {Echo.Component} component the component to query
     * @param {String} defaultPropertyName the name of the default (non-effect) property, e.g., "background"
     * @param {String} effectPropertyName the name of the effect property, e.g., "rolloverBackground"
     * @param {Boolean} effectState flag indicating whether the effect is enabled (if the effect is not enabled,
     *        the default (non-effect) value will always be returned)
     * @param defaultDefaultPropertyValue (optional) the default (non-effect) property value (this value will be returned
     *        if no other value can be determined for the property)
     * @param defaultEffectPropertyValue (optional) the default effect property value (this value will be returned if the
     *        effectState is true and no value has been specifically set for the effect property) 
     */
    getEffectProperty: function(component, defaultPropertyName, effectPropertyName, effectState,
            defaultDefaultPropertyValue, effectDefaultPropertyValue) {
        var property;
        if (effectState) {
            property = component.render(effectPropertyName, effectDefaultPropertyValue);
        }
        if (!property) {
            property = component.render(defaultPropertyName, defaultDefaultPropertyValue);
        }
        return property;
    },
    
    /**
     * Renders component foreground, background, font, and layout direction properties
     * (if each is provided) to the specified element.  This is a performance/convenience method
     * which combines capabilities found in Echo.Sync.Color/Font/LayoutDirection.
     * 
     * @param {Echo.Component} component the component
     * @param {Element} element the target element
     */
    renderComponentDefaults: function(component, element) {
        var color;
        if ((color = component.render("foreground"))) {
            element.style.color = color;
        }
        if ((color = component.render("background"))) {
            element.style.backgroundColor = color;
        }
        var font = component.render("font");
        if (font) {
            Echo.Sync.Font.render(font, element);
        }
        if (component.getLayoutDirection()) {
            element.dir = component.getLayoutDirection().isLeftToRight() ? "ltr" : "rtl";
        }
    }
};

/**
 * Provides tools for rendering alignment properties.
 * @class
 */
Echo.Sync.Alignment = {

    _HORIZONTALS: { left: true, center: true, right: true, leading: true, trailing: true },
    _VERTICALS: { top: true, middle: true, bottom: true },

    /**
     * Returns the render-able horizontal component of an alignment property.  This method
     * translates leading/trailing horizontal values to left/right based on the specified layout
     * direction provider.  If a provider is no given, leading defaults to left and trailing to
     * right.
     * 
     * @param {#Alignment} alignment the alignment
     * @return the rendered horizontal component, i.e., "left", "center", "right", or null
     * @type String
     */
    getRenderedHorizontal: function(alignment, layoutDirectionProvider) {
        if (alignment == null) {
            return null;
        }
    
        var layoutDirection = layoutDirectionProvider ? 
                layoutDirectionProvider.getRenderLayoutDirection() : Echo.LayoutDirection.LTR;
         
        var horizontal = typeof(alignment) == "object" ? alignment.horizontal : alignment; 
                
        switch (horizontal) {
        case "leading":
            return layoutDirection.isLeftToRight() ? "left" : "right";
        case "trailing":
            return layoutDirection.isLeftToRight() ? "right" : "left";
        default:
            return horizontal in this._HORIZONTALS ? horizontal : null;
        }
    },
    
    /**
     * Returns the horizontal component of an alignment property.
     * 
     * @param {#Alignment} the alignment
     * @return the horizontal component, i.e., "left", "center", "right", "leading", "trailing", or null
     * @type String
     */
    getHorizontal: function(alignment) {
        if (alignment == null) {
            return null;
        }
        if (typeof(alignment == "string")) {
            return alignment in this._HORIZONTALS ? alignment : null;
        } else {
            return alignment.horizontal;
        }
    },

    /**
     * Returns the vertical component of an alignment property.
     * 
     * @param {#Alignment} the alignment
     * @return the vertical component, i.e., "top", "middle", "bottom", or null 
     * @type String
     */
    getVertical: function(alignment) {
        if (alignment == null) {
            return null;
        }
        if (typeof(alignment == "string")) {
            return alignment in this._VERTICALS ? alignment : null;
        } else {
            return alignment.vertical;
        }
    },

    /**
     * Renders an alignment property to an element.
     * 
     * @param {#Alignment} alignment the alignment
     * @param {Element} the target element
     * @param {Boolean} renderToElement flag indicating whether the alignment state should be rendered to the element using
     *        attributes (true) or CSS (false)
     * @param layoutDirectionProvider an (optional) object providing a getRenderLayoutDirection() method to determine if the
     *        element has a layout direction of left-to-right or right-to-left
     */
    render: function(alignment, element, renderToElement, layoutDirectionProvider) {
        if (alignment == null) {
            return;
        }
        
        var horizontal = Echo.Sync.Alignment.getRenderedHorizontal(alignment, layoutDirectionProvider);
        var vertical = typeof(alignment) == "object" ? alignment.vertical : alignment;
    
        var horizontalValue;
        switch (horizontal) {
        case "left":   horizontalValue = "left";   break;
        case "center": horizontalValue = "center"; break;
        case "right":  horizontalValue = "right";  break;
        default:       horizontalValue = "";       break;
        }
        var verticalValue;
        switch (vertical) {
        case "top":    verticalValue = "top";      break;
        case "middle": verticalValue = "middle";   break;
        case "bottom": verticalValue = "bottom";   break;
        default:       verticalValue = "";         break;
        }
        
        if (renderToElement) {
            element.align = horizontalValue;
            element.vAlign = verticalValue;
        } else {
            element.style.textAlign = horizontalValue;
            element.style.verticalAlign = verticalValue;
        }
    }
};

/**
 * Provides tools for rendering border properties.
 * @class
 */
Echo.Sync.Border = {

    /**
     * Regular expression to validate/parse a CSS border expression, e.g., "1px solid #abcdef".
     * Supports omission of any term, or empty strings.
     * @type RegExp
     */
    _PARSER_PX: new RegExp("^(-?\\d+px)?(?:^|$|(?= )) ?(none|hidden|dotted|dashed|solid|" + 
            "double|groove|ridge|inset|outset)?(?:^|$|(?= )) ?(#[0-9a-fA-F]{6})?$"),

    /**
     * Regular expression to validate/parse a pixel-based CSS border expression, e.g., "1px solid #abcdef".
     * Supports omission of any term, or empty strings.
     * @type RegExp
     */
    _PARSER: new RegExp("^(-?\\d+(?:px|pt|pc|cm|mm|in|em|ex))?(?:^|$|(?= )) ?(none|hidden|dotted|dashed|solid|" +
            "double|groove|ridge|inset|outset)?(?:^|$|(?= )) ?(#[0-9a-fA-F]{6})?$"),
            
    /** 
     * Regular expression to test whether an extent string is a properly formatted integer pixel value.
     * @type RegExp 
     */
    _TEST_EXTENT_PX: /^-?\d+px$/,
    
    /**
     * Creates a border property from a size, style, and color.
     * 
     * @param {#Extent} size the border size
     * @param {String} the border style
     * @param {#Color} the border color
     * @return a border object
     * @type #Border
     */
    compose: function(size, style, color) {
        if (typeof size == "number") {
            size += "px";
        }
        var out = [];
        if (size) {
            out.push(size);
        }
        if (style) {
            out.push(style);
        }
        if (color) {
            out.push(color);
        }
        return out.join(" ");
    },
    
    /** 
     * Determines if a border is multisided.
     * 
     * @param {#Border} border the border to analyze
     * @return true if the border is multisided
     * @type Boolean
     */
    isMultisided: function(border) {
        return (border && (border.top || border.bottom || border.left || border.right)) ? true : false;
    },
    
    /**
     * Parses a border into size, style, and color components.
     * 
     * @param {#Border} border the border to parse
     * @return an object containing size, style, and color properties of the border
     */
    parse: function(border) {
        if (!border) {
            // Return an empty object if border evaluates false.
            return { };
        }
        if (typeof(border) == "string") {
            // Parse the border.
            var parts = this._PARSER.exec(border);
            return { size: parts[1], style: parts[2], color: parts[3] }; 
        } else {
            // Parse an individual border side.
            return Echo.Sync.Border.parse(border.top || border.right || border.bottom || border.left);
        }
    },

    /**
     * Renders a border to a DOM element.
     * 
     * @param {#Border} border the border to render
     * @param {Element} the target DOM element
     * @param {String} styleAttribute the CSS style attribute name (defaults to "border" if omitted)
     */
    render: function(border, element, styleAttribute) {
        if (!border) {
            return;
        }
        styleAttribute = styleAttribute ? styleAttribute : "border";
        if (typeof(border) == "string") {
            if (this._PARSER_PX.test(border)) {
                element.style[styleAttribute] = border;
            } else {
                var elements = this._PARSER.exec(border);
                if (elements == null) {
                    throw new Error("Invalid border: \"" + border + "\"");
                }
                this.render(Echo.Sync.Extent.toPixels(elements[1]) + "px " + elements[2] + " " + elements[3], 
                        element, styleAttribute);
            }
        } else {
            this.render(border.top, element, styleAttribute + "Top");
            if (border.right !== null) {
                this.render(border.right || border.top, element, styleAttribute + "Right");
            }
            if (border.bottom !== null) {
                this.render(border.bottom || border.top, element, styleAttribute + "Bottom");
            }
            if (border.left !== null) {
                this.render(border.left || border.right || border.top, element, styleAttribute + "Left");
            }
            
        }
    },
    
    /**
     * Renders a border to a DOM element, clearing an existing border if the border value is null.
     * 
     * @param {#Border} border the border to render
     * @param {Element} the target DOM element
     * @param {String} styleAttribute the CSS style attribute name (defaults to "border" if omitted)
     */
    renderClear: function(border, element) {
        if (border) {
            if (border instanceof Object) {
                element.style.border = "";
            }
            this.render(border, element);
        } else {
            element.style.border = "";
        }
    },

    /**
     * Determines the size of a particular side of the border in pixels.
     * 
     * @param {#Border} border the border
     * @param {String} sideName, the border side name, "left", "right", "bottom", or "top" (defaults to "top" if omitted)
     * @return the border size in pixels
     * @type Number
     */
    getPixelSize: function(border, sideName) {
        if (!border) {
            return 0;
        }
        
        if (typeof(border) == "string") {
            var extent = this._PARSER.exec(border)[1];
            if (extent == null) {
                return 0;
            } else if (this._TEST_EXTENT_PX.test(extent)) {
                return parseInt(extent, 10);
            } else {
                return Echo.Sync.Extent.toPixels(extent);
            }
        } else if (typeof(border) == "object") {
            // Retrieve value for individual side.
            // Specified side is queried first, followed by alternatives.
            while (true) {
                var side = this.getPixelSize(border[sideName]);
                if (side == null) {
                    switch (sideName) {
                    case "left": 
                        // If left side specified but value null, try again with right.
                        sideName = "right"; 
                        continue;
                    case "right":
                    case "bottom": 
                        // If bottom or right side specified, try again with top.
                        sideName = "top";
                        continue; 
                    }
                }
                return side;
            }
        }
    }
};

/**
 * Provides tools for rendering color properties.
 * @class
 */
Echo.Sync.Color = {

    /**
     * Adjusts the value of the color's RGB values by the
     * specified amounts, returning a new Color.
     * The original color is unchanged.
     * 
     * @param color the color to adjust (a 24 bit hex value, e.g., #1a2b3c)
     * @param r the amount to adjust the red value of the color (-255 to 255)
     * @param g the amount to adjust the green value of the color (-255 to 255)
     * @param b the amount to adjust the blue value of the color (-255 to 255)
     * @return the adjusted color (a 24 bit hex value)
     */
    adjust: function(value, r, g, b) {
        var colorInt = parseInt(value.substring(1), 16);
        var red = Math.floor(colorInt / 0x10000) + r;
        var green = Math.floor(colorInt / 0x100) % 0x100 + g;
        var blue = colorInt % 0x100 + b;
        return this.toHex(red, green, blue);
    },
    
    /**
     * Blends two colors together.
     * 
     * @param {#Color} value1 the first color
     * @param {#Color} value2 the second color
     * @param {Number} ratio the blend ratio, where 0 represents the first color, 1 the second color, and 0.5 an equal blend
     *        between the first and second colors
     * @return the blended color
     * @type #Color
     */
    blend: function(value1, value2, ratio) {
        ratio = ratio < 0 ? 0 : (ratio > 1 ? 1 : ratio);
        var colorInt1 = parseInt(value1.substring(1), 16);
        var colorInt2 = parseInt(value2.substring(1), 16);
        var red = Math.round(Math.floor(colorInt1 / 0x10000) * (1 - ratio) + Math.floor(colorInt2 / 0x10000) * ratio);
        var green = Math.round(Math.floor(colorInt1 / 0x100) % 0x100 * (1 - ratio) + 
                Math.floor(colorInt2 / 0x100) % 0x100 * ratio);
        var blue = Math.round((colorInt1 % 0x100) * (1 - ratio) + (colorInt2 % 0x100) * ratio);
        return this.toHex(red, green, blue);
    },

    /**
     * Renders a color to an element.
     * 
     * @param {#Color} color the color
     * @param {#Element} element the target element
     * @param {String} styleAttribute the name of the style attribute, e.g., "color", "backgroundColor" 
     */
    render: function(color, element, styleAttribute) {
        if (color) {
            element.style[styleAttribute] = color;
        }
    },
    
    /**
     * Renders a color to an element, clearing any existing value.
     * 
     * @param {#Color} color the color
     * @param {#Element} element the target element
     * @param {String} styleAttribute the name of the style attribute, e.g., "color", "backgroundColor" 
     */
    renderClear: function(color, element, styleAttribute) {
        element.style[styleAttribute] = color ? color : "";
    },
    
    /**
     * Renders the "foreground" and "background" color properties of a component to an element's "color" and
     * "backgroundColor" properties.
     * 
     * @param {Echo.Component} component the component
     * @param {Element} the target element 
     */
    renderFB: function(component, element) { 
        var color;
        if ((color = component.render("foreground"))) {
            element.style.color = color;
        }
        if ((color = component.render("background"))) {
            element.style.backgroundColor = color;
        }
    },
    
    /**
     * Converts red/green/blue integer values to a 6 digit hexadecimal string, preceded by a sharp, e.g. #1a2b3c.
     * 
     * @param {Number} red the red value, 0-255
     * @param {Number} green the green value, 0-255
     * @param {Number} blue the blue value, 0-255
     * @return the hex string
     * @type String
     */
    toHex: function(red, green, blue) {
        if (red < 0) {
            red = 0;
        } else if (red > 255) {
            red = 255;
        }
        if (green < 0) {
            green = 0;
        } else if (green > 255) {
            green = 255;
        }
        if (blue < 0) {
            blue = 0;
        } else if (blue > 255) {
            blue = 255;
        }

        return "#" + (red < 16 ? "0" : "") + red.toString(16) +
                (green < 16 ? "0" : "") + green.toString(16) +
                (blue < 16 ? "0" : "") + blue.toString(16); 
    }
};

/**
 * Provides tools for rendering extent (dimension) properties.
 * @class
 */
Echo.Sync.Extent = { 

    /**
     * Regular expression to parse an extent value, e.g., "12px" into its value and unit components.
     * @type RegExp
     */
    _PARSER: /^(-?\d+(?:\.\d+)?)(.+)?$/,

    /**
     * Regular expression to determine if an extent value is already formatted to pixel units.
     * @type RegExp
     */
    _FORMATTED_INT_PIXEL_TEST: /^(-?\d+px *)$/,
    
    /**
     * Regular expression to determine if an extent value is already formatted to pixel units.
     * @type RegExp
     */
    _FORMATTED_DECIMAL_PIXEL_TEST: /^(-?\d+(.\d+)?px *)$/,
    
    /**
     * Determines if an extent has percent units.
     * 
     * @param {#Extent} extent the Extent
     * @return true if the extent has percent units
     * @type Boolean
     */
    isPercent: function(extent) {
        if (extent == null || typeof(extent) == "number") {
            return false;
        } else {
            var parts = this._PARSER.exec(extent);
            if (!parts) {
                return false;
            }
            return parts[2] == "%";
        }
    },
    
    /**
     * Renders an extent value to an element.
     *
     * @param {#Extent} extent the Extent
     * @param {Element} element the target element
     * @param {String} styleAttribute the style attribute name, e.g., "padding-left", or "width"
     * @param {Boolean} horizontal flag indicating whether the value is being rendered horizontally
     * @param {Boolean} allowPercent flag indicating whether percent values should be rendered
     */
    render: function(extent, element, styleAttribute, horizontal, allowPercent) {
        var cssValue = Echo.Sync.Extent.toCssValue(extent, horizontal, allowPercent);
        if (cssValue !== "") {
            element.style[styleAttribute] = cssValue;
        }
    },

    /**
     * Returns a CSS representation of an extent value.
     * 
     * @param {#Extent} extent the Extent
     * @param {Boolean} horizontal flag indicating whether the value is being rendered horizontally
     * @param {Boolean} allowPercent flag indicating whether percent values should be rendered
     * @return the rendered CSS value or the empty string ("") if no value could be determined (null will never be returned)
     * @type String
     */
    toCssValue: function(extent, horizontal, allowPercent) {
        switch(typeof(extent)) {
        case "number":
            return Math.round(extent) + "px";
        case "string":
            if (this._FORMATTED_INT_PIXEL_TEST.test(extent)) {
                return extent;
            } else if (this._FORMATTED_DECIMAL_PIXEL_TEST.test(extent)) {
                return Math.round(parseFloat(extent)) + "px";
            } else {
                if (this.isPercent(extent)) {
                    return allowPercent ? extent : "";
                } else {
                    var pixels = this.toPixels(extent, horizontal);
                    return pixels == null ? "" : this.toPixels(extent, horizontal) + "px";
                }
            }
            break;
        }
        return "";
    },

    /**
     * Converts an extent value to pixels.
     * 
     * @param {#Extent} extent the Extent
     * @param {Boolean} horizontal flag indicating whether the value is being rendered horizontally
     * @return the pixel value
     * @type Number
     */
    toPixels: function(extent, horizontal) {
        if (extent == null) {
            return 0;
        } else if (typeof(extent) == "number") {
            return Math.round(extent);
        } else {
            return Math.round(Core.Web.Measure.extentToPixels(extent, horizontal));
        }
    }
};

/**
 * Provides tools for rendering fill image (background image) properties.
 * @class
 */
Echo.Sync.FillImage = { 

    /** Mapping between repeat property values and rendered CSS repeat values. */
    _REPEAT_VALUES: {
        "0": "no-repeat",
        "x": "repeat-x",
        "y": "repeat-y",
        "xy": "repeat",
        "no-repeat": "no-repeat",
        "repeat-x": "repeat-x",
        "repeat-y": "repeat-y",
        "repeat": "repeat"
    },

    /**
     * Flag indicating that the Internet Explorer 6-specific PNG alpha filter should be used to render PNG alpha (transparency).
     * @type Number
     */
    FLAG_ENABLE_IE_PNG_ALPHA_FILTER: 0x1,
    
    /**
     * Determines the background-position CSS attribute of a FillImage.
     * 
     * @param {#FillImage} fillImage the FillImage
     * @return the appropriate CSS background-position attribute, or null if it is not specified
     * @type String
     */
    getPosition: function(fillImage) {
        if (fillImage.x || fillImage.y) {
            var x, y;
            if (Echo.Sync.Extent.isPercent(fillImage.x)) {
                x = fillImage.x;
            } else {
                x = Echo.Sync.Extent.toPixels(fillImage.x, true) + "px";
            }
            if (Echo.Sync.Extent.isPercent(fillImage.y)) {
                y = fillImage.y;
            } else {
                y = Echo.Sync.Extent.toPixels(fillImage.y, false) + "px";
            }
            return x + " " + y;
        } else {
            return null;
        }
    },
    
    /**
     * Determines the background-repeat CSS attribute of a FillImage.
     * 
     * @param {#FillImage} fillImage the FillImage
     * @return the appropriate CSS background-repeat attribute, or null if it is not specified/invalid
     * @type String
     */
    getRepeat: function(fillImage) {
        if (this._REPEAT_VALUES[fillImage.repeat]) {
            return this._REPEAT_VALUES[fillImage.repeat]; 
        } else {
            return null;
        }
    },
    
    /**
     * Returns the URL of a FillImage.
     * 
     * @param {#FillImage} fillImage the FillImage
     * @return the URL
     * @type String
     */
    getUrl: function(fillImage) {
        if (fillImage == null) {
            return null;
        }
        return typeof(fillImage) == "object" ? fillImage.url : fillImage;
    },
    
    /**
     * Renders a FillImage to an element.
     * 
     * @param {#FillImage} fillImage the FillImage (may be null)
     * @param {Element} element the target element
     * @param {Number} flags (optional) the rendering flags, one or more of the following values:
     *        <ul>
     *         <li><code>FLAG_ENABLE_IE_PNG_ALPHA_FILTER</code></li>
     *        <ul>
     */
    render: function(fillImage, element, flags) {
        if (fillImage == null) {
            // No image specified, do nothing.
            return;
        }
        
        var isObject = typeof(fillImage) == "object";
        var url = isObject ? fillImage.url : fillImage;

        if (Core.Web.Env.QUIRK_IE_SECURE_ITEMS && document.location.protocol == "https:") {
            if (url.substring(0, 5) != "http:" && url.substring(0, 6) != "https:") {
                // Use full URL, see http://support.microsoft.com/kb/925014 and
                // http://weblogs.asp.net/rchartier/archive/2008/03/12/ie7-this-page-contains-both-secure-and-nonsecure-items.aspx
                url = document.location.protocol + "//" + document.location.hostname + 
                        (document.location.port ? (":" + document.location.port) : "") + url;
            }
        }
        if (Core.Web.Env.PROPRIETARY_IE_PNG_ALPHA_FILTER_REQUIRED &&
                flags && (flags & this.FLAG_ENABLE_IE_PNG_ALPHA_FILTER)) {
            // IE6 PNG workaround required.
            element.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + url + "', sizingMethod='scale')";
        } else {
            // IE6 PNG workaround not required.
            element.style.backgroundImage = "url(" + url + ")";
        }
        
        if (isObject) {
            var position = Echo.Sync.FillImage.getPosition(fillImage);
            element.style.backgroundPosition = position ? position : "";
            element.style.backgroundRepeat = this._REPEAT_VALUES[fillImage.repeat] ? this._REPEAT_VALUES[fillImage.repeat]: ""; 
        }
    },
    
    /**
     * Renders a FillImage to an element, clearing any existing value.
     * 
     * @param {#FillImage} fillImage the FillImage (may be null)
     * @param {Element} element the target element
     * @param {Number} flags (optional) the rendering flags, one or more of the following values:
     *        <ul>
     *         <li><code>FLAG_ENABLE_IE_PNG_ALPHA_FILTER</code></li>
     *        <ul>
     */
    renderClear: function(fillImage, element, flags) {
        if (fillImage) {
            this.render(fillImage, element, flags);
        } else {
            if (Core.Web.Env.PROPRIETARY_IE_PNG_ALPHA_FILTER_REQUIRED) {
                element.style.filter = "";
            }
            element.style.backgroundImage = "";
            element.style.backgroundPosition = "";
            element.style.backgroundRepeat = "";
        }
    }
};

/**
 * Provides tools for rendering fill image border properties (borders composed of eight graphic images).
 * 
 * A relative-positioned DIV may be added to the created FillImageBorder container DIV.
 * Note that you should ALWAYS set the "zoom" CSS property to 1 to workaround "hasLayout" bugs in Internet Explorer's
 * rendering engine.  Use the following code to set this property on any relative positioned DIVs you create:
 * <code>if (Core.Web.Env.QUIRK_IE_HAS_LAYOUT) { div.style.zoom = 1; }</code>.
 * See http://msdn.microsoft.com/en-us/library/bb250481.aspx 
 * 
 * @class
 */
Echo.Sync.FillImageBorder = {
    
    /**
     * Mapping between child node indices of container element and fill image property names of a FillImageBorder.
     * @type Array
     */
    _NAMES: ["top", "topRight", "right", "bottomRight", "bottom", "bottomLeft", "left", "topLeft"],
    
    /**
     * Two dimensional mapping array representing which FillImageBorder side configurations have which elements.
     * First index represents FillImageBorder configuration, from 0-15, with bitwise 1=top, 2=right, 4=bottom 8=left
     * flags ORed together.  Second index represents border side in order top, top-right, right, 
     * bottom-right, bottom, bottom-left, left.  Value is 1 when side/corner element exists for this configuration, 0 otherwise.
     * @type Array
     */
    _MAP: [
    //   0  1  2  3  4  5  6  7
    //   T TR  R BR  B BL  L  TL
        [0, 0, 0, 0, 0, 0, 0, 0], // ----
        [1, 0, 0, 0, 0, 0, 0, 0], // ---t
        [0, 0, 1, 0, 0, 0, 0, 0], // --r-
        [1, 1, 1, 0, 0, 0, 0, 0], // --rt
        [0, 0, 0, 0, 1, 0, 0, 0], // -b--
        [1, 0, 0, 0, 1, 0, 0, 0], // -b-t
        [0, 0, 1, 1, 1, 0, 0, 0], // -br-
        [1, 1, 1, 1, 1, 0, 0, 0], // -brt
        [0, 0, 0, 0, 0, 0, 1, 0], // l---
        [1, 0, 0, 0, 0, 0, 1, 1], // l--t
        [0, 0, 1, 0, 0, 0, 1, 0], // l-r-
        [1, 1, 1, 0, 0, 0, 1, 1], // l-rt
        [0, 0, 0, 0, 1, 1, 1, 0], // lb--
        [1, 0, 0, 0, 1, 1, 1, 1], // lb-t
        [0, 0, 1, 1, 1, 1, 1, 0], // lbr-
        [1, 1, 1, 1, 1, 1, 1, 1]  // lbrt
    ],

    /**
     * Prototype storage.  Indices of this array store lazily-created DOM hierarchies for various FillImageBorder
     * side configurations.  Valid indices of this array are form 0-15, representing the following values ORed
     * together to describe possible configurations of sides:
     * <ul>
     *  <li><code>1</code>: bit indicating the top border should be rendered</li> 
     *  <li><code>2</code>: bit indicating the right border should be rendered</li> 
     *  <li><code>4</code>: bit indicating the bottom border should be rendered</li> 
     *  <li><code>8</code>: bit indicating the left border should be rendered</li> 
     * </li>
     */
    _PROTOTYPES: [],
    
    /**
     * Generates a segment of a rendered FillImageBorder DOM and adds it to its parent.
     * 
     * @param {Element} parent the parent element
     * @param {String} css the CSS text add to the rendered element
     */
    _createSegment: function(parent, css) {
        var child = document.createElement("div");
        child.style.cssText = "font-size:1px;line-height:0;position:absolute;" + css;
        parent.appendChild(child);
    },
    
    /**
     * Creates a prototype rendered DOM element hierarchy to display a fill image border.
     * The values returned by this method are stored and cloned for performance.
     * This method will be invoked at most 16 times, once per key (0-15).
     * 
     * @param key the fill image border key, any combination of the following values ORed together:
     *        <ul>
     *         <li><code>1</code>: bit indicating the top border should be rendered</li> 
     *         <li><code>2</code>: bit indicating the right border should be rendered</li> 
     *         <li><code>4</code>: bit indicating the bottom border should be rendered</li> 
     *         <li><code>8</code>: bit indicating the left border should be rendered</li> 
     *        </li>
     * @return the created border prototype
     */
    _createPrototype: function(key) {
        var div = document.createElement("div");
        if (Core.Web.Env.QUIRK_IE_HAS_LAYOUT) {
            div.style.zoom = 1;
        }
        
        if (key & 0x1) { // Top
            this._createSegment(div, "top:0;");
            if (key & 0x2) { // Right
                this._createSegment(div, "top:0;right:0;");
            }
        }
        if (key & 0x2) { // Right
            this._createSegment(div, "right:0;");
            if (key & 0x4) { // Bottom
                this._createSegment(div, "bottom:0;right:0;");
            }
        }
        if (key & 0x4) { // Bottom
            this._createSegment(div, "bottom:0;");
            if (key & 0x8) { // Left
                this._createSegment(div, "bottom:0;left:0;");
            }
        }
        if (key & 0x8) { // Left
            this._createSegment(div, "left:0;");
            if (key & 0x1) { // Top
                this._createSegment(div, "top:0;left:0;");
            }
        }
        return div;
    },
    
    /***
     * Rerturns the array of border DIV elements, in  the following order:
     * top, top-right, right, bottom-right, bottom, bottom-left, left, top-left.
     * The array will have a value of null for any position that is not rendered due to the border having a zero dimension on 
     * that side.
     * 
     * @param {Element} containerDiv the container element generated by <code>renderContainer()</code>
     * @return the array of border DIV elements
     * @type Array
     */
    getBorder: function(containerDiv) {
        var border = [];
        var child = containerDiv.firstChild;
        while (child) {
            if (child.__FIB_segment != null) {
                border[child.__FIB_segment] = child;
            }
            child = child.nextSibling;
        }
        return border;
    },
    
    /**
     * Returns the content element (to which children may be added) of a FillImageBorder container element created with
     * <code>renderContainer()</code>.
     * 
     * @param {Element} containerDiv the container element generated by <code>renderContainer()</code>
     * @return the content element to which child nodes may be added
     * @type Element
     */
    getContainerContent: function(containerDiv) {
        if (!containerDiv.__FIB_hasContent) {
            return null;
        }
        var child = containerDiv.firstChild;
        while (child) {
            if (child.__FIB_content) {
                return child;
            }
            child = child.nextSibling;
        }
        return null;
    },
    
    /**
     * Creates a DOM hierarchy representing a FillImageBorder.
     * The provided childElement will be added to it, if specified.
     * The outer container DIV element of the rendered DOM hierarchy is returned.  Width and height values may be configured
     * on this returned value.
     * 
     * The <code>renderContainerDisplay()</code> method should be invoked by the <code>renderDisplay()</code> method of any
     * synchronization peer making use of a rendered FillImageBorder container in order to support Internet Explorer 6 browsers
     * (the rendered border uses virtual positioning to appear properly in IE6).
     * 
     * @param {#FillImageBorder} fillImageBorder the FillImageBorder to be rendered.
     * @param configuration (optional) configuration options, an object containing one or more of the following properties:
     *        <ul>
     *         <li><code>update</code>: the containerDiv to update (normally null, which will result in a new one being
     *          created; note that it is less efficient to update a container than to create a new one; currently does not 
     *          support adding content)</li>
     *         <li><code>content</code>: flag indicating that a content element should be created/managed (implied by child)</li>
     *         <li><code>child</code>: a content element to added inside the border (implies content)</li>
     *         <li><code>absolute</code>: boolean flag indicating whether the DIV shold be absolutely (true) or relatively
     *         (false) positioned</li>
     *        </ul>
     * @return the outer container DIV element of the rendered DOM hierarchy
     * @type Element
     */
    renderContainer: function(fillImageBorder, configuration) {
        fillImageBorder = fillImageBorder || {};
        configuration = configuration || {};
        
        // Load pixel border insets.
        var bi = Echo.Sync.Insets.toPixels(fillImageBorder.borderInsets);
        
        // Create bitset "key" based on which sides of border are present.
        var key = (bi.left && 0x8) | (bi.bottom && 0x4) | (bi.right && 0x2) | (bi.top && 0x1);
        var map = this._MAP[key];
        var prototypeDiv = this._PROTOTYPES[key] ? this._PROTOTYPES[key] : this._PROTOTYPES[key] = this._createPrototype(key); 
        var div, child, childClone, firstChild, i, content = null, border = [], insertBefore = null, testChild, insets;
        
        if (configuration.update) {
            // Updating existing FillImageBorder container DIV: load element specified in update property.
            div = configuration.update;

            // Remove current fill image border children, store references to important elements.
            child = div.firstChild;
            while (child) {
                testChild = child;
                child = child.nextSibling;
                if (testChild.__FIB_segment != null) {
                    // Mark position where children should be inserted.
                    insertBefore = child;
                    div.removeChild(testChild);
                }
                if (testChild.__FIB_content) {
                    // Store content child.
                    content = testChild;
                }
            }
            
            // Add children from prototype.
            child = prototypeDiv.firstChild;
            while (child) {
                childClone = child.cloneNode(true);
                if (!firstChild) {
                    // Store reference to first added child.
                    firstChild = childClone;
                }
                
                // Insert child.
                if (insertBefore) {
                    div.insertBefore(childClone, insertBefore);
                } else {
                    div.appendChild(childClone);
                }
                child = child.nextSibling;
            }
        } else {
            // Creating new FillImageBorder container DIV: clone the prototype.
            div = prototypeDiv.cloneNode(true);
            firstChild = div.firstChild;

            // Create and append content container if required.
            if (configuration.content || configuration.child) {
                content = document.createElement("div");
                content.__FIB_content = true;
                if (configuration.child) {
                    content.appendChild(configuration.child);
                }
                div.__FIB_hasContent = true;
                div.appendChild(content);
            }
            
            // Set positioning based on configuration.
            if (configuration.absolute) {
                div.__FIB_absolute = true;
                div.style.position = "absolute";
            } else {
                div.style.position = "relative";
                if (content) {
                    content.style.position = "relative";
                    if (Core.Web.Env.QUIRK_IE_HAS_LAYOUT) {
                        content.style.zoom = 1;
                    }
                }
            }
        }
        div.__key = key;
        
        // Render FillImageBorder.
        child = firstChild;
        for (i = 0; i < 8; ++i) {
            if (!map[i]) {
                // Loaded map indicates no border element in this position: skip.
                continue;
            }
            // Set identifier on segment element.
            child.__FIB_segment = i;
            
            // Store segment element in array for convenient access later.
            border[i] = child;
            
            if (fillImageBorder.color) {
                child.style.backgroundColor = fillImageBorder.color; 
            }
            if (i === 0 || i === 1 || i === 7) { // 0,1,7 = top
                child.style.height = bi.top + "px";
            } else if (i >= 3 && i <= 5) { // 3,4,5 = bottom
                child.style.height = bi.bottom + "px";
            }
            if (i >= 1 && i <= 3) { // 1,2,3 = right
                child.style.width = bi.right + "px";
            } else if (i >= 5) { // 5,6,7 = left
                child.style.width = bi.left + "px";
            }
            Echo.Sync.FillImage.render(fillImageBorder[this._NAMES[i]], child, Echo.Sync.FillImage.FLAG_ENABLE_IE_PNG_ALPHA_FILTER);
            child = child.nextSibling;
        }

        // Set left/right, top/bottom positions of border sides (where elements exist).
        if (bi.top) {
            border[0].style.left = bi.left + "px";
            border[0].style.right = bi.right + "px";
        }
        if (bi.right) {
            border[2].style.top = bi.top + "px";
            border[2].style.bottom = bi.bottom + "px";
        }
        if (bi.bottom) {
            border[4].style.left = bi.left + "px";
            border[4].style.right = bi.right + "px";
        }
        if (bi.left) {
            border[6].style.top = bi.top + "px";
            border[6].style.bottom = bi.bottom + "px";
        }
        
        if (div.__FIB_absolute) {
            if (content) {
                // Set content positioning.
                var ci = Echo.Sync.Insets.toPixels(fillImageBorder.contentInsets);
                content.style.position = "absolute"; 
                content.style.overflow = "auto";
                content.style.top = ci.top + "px";
                content.style.right = ci.right + "px";
                content.style.bottom = ci.bottom + "px";
                content.style.left = ci.left + "px";
            }
        } else {
            if (content) {
                // Set content positioning.
                Echo.Sync.Insets.render(fillImageBorder.contentInsets, content, "padding");
            }
            if (!configuration.update) {
                div.style.position = "relative";
                if (content) {
                    content.style.position = "relative";
                }
            }
        }
        
        return div;
    },
    
    /**
     * Performs renderDisplay() operations on a FillImageBorder container DOM hierarchy.
     * This method should be invoked the renderDisplay() method of a synchronization peer on each FillImageBorder container
     * which it is using.  It is required for IE6 virtual positioning support.
     * 
     * @param {Element} containerDiv the container element generated by <code>renderContainer()</code>
     */
    renderContainerDisplay: function(containerDiv) {
        var content;
        if (Core.Web.VirtualPosition.enabled) {
            if (containerDiv.__FIB_absolute) {
                Core.Web.VirtualPosition.redraw(containerDiv);
                if ((content = this.getContainerContent(containerDiv))) {
                    Core.Web.VirtualPosition.redraw(content);
                }
            }
            var border = this.getBorder(containerDiv);
            for (var i = 0; i < 8; i += 2) {
                if (border[i]) {
                    Core.Web.VirtualPosition.redraw(border[i]);
                }
            }
        }
    }
};

/**
 * Provides tools for rendering font properties.
 * @class
 */
Echo.Sync.Font = { 

    /**
     * Renders a Font property to an element.
     * 
     * @param {#Font} font the font
     * @param {Element} element the target element
     */
    render: function(font, element) {
        if (!font) {
            return;
        }
        if (font.typeface) {
            if (font.typeface instanceof Array) {
                element.style.fontFamily = font.typeface.join(",");
            } else {
                element.style.fontFamily = font.typeface;
            }
        }
        if (font.size) {
            element.style.fontSize = Echo.Sync.Extent.toCssValue(font.size);
        }

        if (font.bold) {
            element.style.fontWeight = "bold";
        }
        if (font.italic) {
            element.style.fontStyle = "italic";
        }
        if (font.underline) {
            element.style.textDecoration = "underline";
        } else if (font.overline) {
            element.style.textDecoration = "overline";
        } else if (font.lineThrough) {
            element.style.textDecoration = "line-through";
        }
    },
    
    /**
     * Renders a Font property to an element, clearing any previously set font first.
     * 
     * @param {#Font} font the font
     * @param {Element} element the target element
     */
    renderClear: function(font, element) {
        if (font) {
            this.render(font, element);
            if (!font.typeface) {
                element.style.fontFamily = "";
            }
            if (!font.underline) {
                element.style.textDecoration = "";
            }
            if (!font.bold) {
                element.style.fontWeight = "";
            }
            if (!font.size) {
                element.style.fontSize = "";
            }
            if (!font.italic) {
                element.style.fontStyle = "";
            }
        } else {
            element.style.fontFamily = "";
            element.style.fontSize = "";
            element.style.fontWeight = "";
            element.style.fontStyle = "";
            element.style.textDecoration = "";
        }
    }
};

/**
 * Provides tools for rendering image properties.
 * @class
 */
Echo.Sync.ImageReference = {

    /**
     * Returns the URL of an image reference object.
     * 
     * @param {#ImageReference} imageReference the image reference (may be null)
     * @return the URL
     * @type String
     */
    getUrl: function(imageReference) {
        return imageReference ? (typeof(imageReference) == "string" ? imageReference : imageReference.url) : null;
    },

    /**
     * Renders an image reference object to an IMG element.
     * 
     * @param {#ImageReference} imageReference the image reference
     * @param {Element} imgElement the IMG element.
     */
    renderImg: function(imageReference, imgElement) {
        if (!imageReference) {
            return;
        }
        
        if (typeof(imageReference) == "string") {
            imgElement.src = imageReference;
        } else {
            imgElement.src = imageReference.url;
            if (imageReference.width) {
                imgElement.style.width = Echo.Sync.Extent.toCssValue(imageReference.width, true);
            }
            if (imageReference.height) {
                imgElement.style.height = Echo.Sync.Extent.toCssValue(imageReference.height, false);
            }
        }
    }
};

/**
 * Provides tools for rendering insets/margin/padding properties.
 * @class
 */
Echo.Sync.Insets = {

    /**
     * Regular expression to test extents which are entirely presented in pixels
     * and may thus be directly added to CSS.
     * @type RegExp
     */
    _FORMATTED_PIXEL_INSETS: /^(-?\d+px *){1,4}$/,

    /** toPixels() return value when insets are 0/null. */
    _ZERO: { top: 0, right: 0, bottom: 0, left: 0 },
    
    /**
     * Mapping between number of inset values provided and arrays which represent the
     * inset value index for the top, right, bottom, and left value. 
     */
    _INDEX_MAPS: {
        1: [0, 0, 0, 0], 
        2: [0, 1, 0, 1], 
        3: [0, 1, 2, 1], 
        4: [0, 1, 2, 3] 
    },

    /**
     * Renders an insets property to an element.
     * 
     * @param {#Insets} insets the insets property
     * @param {Element} element the target element
     * @param {String} styleAttribute the style attribute name, e.g., "padding" or "margin" 
     */
    render: function(insets, element, styleAttribute) {
        switch(typeof(insets)) {
        case "number":
            element.style[styleAttribute] = Math.round(insets) + "px";
            break;
        case "string":
            if (this._FORMATTED_PIXEL_INSETS.test(insets)) {
                element.style[styleAttribute] = insets;
            } else {
                var pixelInsets = this.toPixels(insets);
                element.style[styleAttribute] = pixelInsets.top + "px " + pixelInsets.right + "px " +
                        pixelInsets.bottom + "px " + pixelInsets.left + "px";
            }
            break;
        }
    },
    
    /**
     * Renders an insets property to an element as absolute position coordinates (i.e., top/right/bottom/left values).
     * 
     * @param {#Instes} insets the insets property
     * @param {Element} element the target element
     */
    renderPosition: function(insets, element) {
        var insetsPx = this.toPixels(insets);
        element.style.top = insetsPx.top + "px";
        element.style.right = insetsPx.right + "px";
        element.style.bottom = insetsPx.bottom + "px";
        element.style.left = insetsPx.left + "px";
    },
    
    /**
     * Generates a CSS value for an insets property.
     * 
     * @param {#Insets} insets the insets property
     * @return the CSS value
     * @type String
     */
    toCssValue: function(insets) {
        switch(typeof(insets)) {
        case "number":
            return insets + "px";
        case "string":
            if (this._FORMATTED_PIXEL_INSETS.test(insets)) {
                return insets;
            } else {
                var pixelInsets = this.toPixels(insets);
                return pixelInsets.top + "px " + pixelInsets.right + "px " +
                        pixelInsets.bottom + "px " + pixelInsets.left + "px";
            }
            break;
        }
        return "";
    },
    
    /**
     * Returns an object representing the pixel dimensions of a insets property.
     * 
     * @param {#Insets} insets the insets property
     * @return an object containing top, bottom, left, and right values representing the pixel sizes of the insets property
     */
    toPixels: function(insets) {
        if (insets == null) {
            return this._ZERO;
        } else if (typeof(insets) == "number") {
            insets = Math.round(insets);
            return { top: insets, right: insets, bottom: insets, left: insets };
        }
        
        insets = insets.split(" ");
        var map = this._INDEX_MAPS[insets.length];
        return {
            top: Echo.Sync.Extent.toPixels(insets[map[0]], false),
            right: Echo.Sync.Extent.toPixels(insets[map[1]], true),
            bottom: Echo.Sync.Extent.toPixels(insets[map[2]], false),
            left: Echo.Sync.Extent.toPixels(insets[map[3]], true)
        };
    }
};

/**
 * Provides tools for rendering layout direction properties. 
 */
Echo.Sync.LayoutDirection = {

    /**
     * Renders a layout direction property to an element.
     * 
     * @param {Echo.LayoutDirection} layoutDirection the layoutDirection property (may be null)
     * @param {Element} element the target element
     */
    render: function(layoutDirection, element) {
        if (layoutDirection) {
            element.dir = layoutDirection.isLeftToRight() ? "ltr" : "rtl";
        }
    }
};

/**
 * Renders a table with two or three cells, suitable for laying out buttons, labels, 
 * and similar components.
 */
Echo.Sync.TriCellTable = Core.extend({

    $static: {
        
        /** 
         * Orientation flag indicating inverted (trailing-leading or bottom-top) orientation.
         * @type Number 
         */
        INVERTED: 1,
        
        /** 
         * Orientation flag indicating vertical (top-bottom or bottom-top) orientation. 
         * @type Number 
         */
        VERTICAL: 2,
        
        /** 
         * Orientation value indicating horizontal orientation, leading first, trailing second. 
         * @type Number 
         */
        LEADING_TRAILING: 0,
        
        /** 
         * Orientation value indicating horizontal orientation, trailing first, leading second.
         * @type Number 
         */
        TRAILING_LEADING: 1, // INVERTED
        
        /** 
         * Orientation value indicating vertical orientation, top first, bottom second. 
         * @type Number 
         */
        TOP_BOTTOM: 2,       // VERTICAL
        
        /** 
         * Orientation value indicating vertical orientation, bottom first, top second.
         * @type Number 
         */
        BOTTOM_TOP: 3,       // VERTICAL | INVERTED
        
        /**
         * Creates a prototype DOM element hierarchy for a TriCellTable, which may
         * be cloned for purposes of performance enhancement.
         * 
         * @return the prototype DOM element hierarchy
         * @type Element
         */
        _createTablePrototype: function() {
            var table = document.createElement("table");
            table.style.borderCollapse = "collapse";
            table.style.padding = "0";
            
            var tbody = document.createElement("tbody");
            table.appendChild(tbody);
            
            return table;
        },
        
        /**
         * Returns the inverted orientation value which should be used for a component (the opposite of that which
         * would be returned by getOrientation().
         * The rendered layout direction of the component will be factored when determining horizontal orientations.
         * 
         * @param {Echo.Component} component the component
         * @param {String} propertyName the alignment property name
         * @param {#Alignment} defaultValue default alignment value to use if component does not have specified property
         * @return the (inverted) orientation
         * @type Number
         */
        getInvertedOrientation: function(component, propertyName, defaultValue) {
            return this.getOrientation(component, propertyName, defaultValue) ^ this.INVERTED;
        },

        /**
         * Determines the orientation value which should be used to a component.
         * The rendered layout direction of the component will be factored when determining horizontal orientations.
         * 
         * @param {Echo.Component} component the component
         * @param {String} propertyName the alignment property name
         * @param {#Alignment} defaultValue default alignment value to use if component does not have specified property
         * @return the orientation
         * @type Number
         */
        getOrientation: function(component, propertyName, defaultValue) {
            var position = component.render(propertyName, defaultValue);
            var orientation;
            if (position) {
                switch (Echo.Sync.Alignment.getRenderedHorizontal(position, component)) {
                case "left":   return this.LEADING_TRAILING;
                case "right":  return this.TRAILING_LEADING;
                }
                switch (Echo.Sync.Alignment.getVertical(position, component)) {
                case "top":    return this.TOP_BOTTOM;
                case "bottom": return this.BOTTOM_TOP;
                }
            }
            return component.getRenderLayoutDirection().isLeftToRight() ? this.TRAILING_LEADING : this.LEADING_TRAILING; 
        }
    },
    
    $load: function() {
        this._tablePrototype = this._createTablePrototype(); 
    },
    
    /**
     * The rendered TABLE element.
     * @type Element
     */
    tableElement: null,
    
    /**
     * The rendered TBODY element.
     * @type Element
     */
    tbodyElement: null,

    /**
     * Creates a new <code>TriCellTable</code>
     * 
     * @param {Number} orientation0_1 the orientation of element 0 with respect to element 1, one of 
     *        the following values:
     *        <ul>
     *        <li>LEADING_TRAILING (element 0 is leading element 1)</li>
     *        <li>TRAILING_LEADING (element 1 is leading element 0)</li>
     *        <li>TOP_BOTTOM (element 0 is above element 1)</li>
     *        <li>BOTTOM_TOP (element 1 is above element 0)</li>
     *        </ul>
     * @param {Number} margin0_1 the margin size between element 0 and element 1
     * @param {Number} orientation01_2 (omitted for two-cell tables)
     *        the orientation of Elements 0 and 1 with 
     *        respect to Element 2, one of the following values:
     *        <ul>
     *        <li>LEADING_TRAILING (elements 0 and 1 are leading element 2)</li>
     *        <li>TRAILING_LEADING (element 2 is trailing elements 0 and 1)</li>
     *        <li>TOP_BOTTOM (elements 0 and 1 are above element 2)</li>
     *        <li>BOTTOM_TOP (element 2 is above elements 0 and 1)</li>
     *        </ul>
     * @param {Number} margin01_2 (omitted for two-cell tables)
     *        the margin size between the combination
     *        of elements 0 and 1 and element 2
     */
    $construct: function(orientation0_1, margin0_1, orientation01_2, margin01_2) {
        this.tableElement = Echo.Sync.TriCellTable._tablePrototype.cloneNode(true);
        this.tbodyElement = this.tableElement.firstChild;
        
        if (orientation01_2 == null) {
            this._configure2(orientation0_1, margin0_1);
        } else {
            this._configure3(orientation0_1, margin0_1, orientation01_2, margin01_2);
        }
    },
    
    /**
     * Appends a TD element to a TR element, if TD element is not null.
     * 
     * @param {Element} tr the table row (TR) element
     * @param {Element} td the table cell (TD) element
     */
    _addColumn: function(tr, td) {
        if (td != null) {
            tr.appendChild(td);
        }
    },
    
    /**
     * If the TD element is not null, creates a TR row element and appends the TD element to it;
     * then appends the TR element to the table body.
     * 
     * @param {Element} td the table cell element
     */
    _addRow: function(td) {
        if (td == null) {
            return;
        }
        var tr = document.createElement("tr");
        tr.appendChild(td);
        this.tbodyElement.appendChild(tr);
    },
    
    /**
     * Adds a spacer DIV to the specified parent element.
     * 
     * @param {Element} parentElement the parent element to which the spacer DIV should be added
     * @param {Number} size the pixel size of the spacer
     * @param {Boolean} vertical boolean flag indicating the orientation of the spacer, 
     *        true for vertical spacers, false for horizontal
     */
    _addSpacer: function(parentElement, size, vertical) {
        var divElement = document.createElement("div");
        if (vertical) {
            divElement.style.cssText = "width:1px;height:" + size + "px;font-size:1px;line-height:0;";
        } else {
            divElement.style.cssText = "width:" + size + "px;height:1px;font-size:1px;line-height:0;";
        }
        parentElement.appendChild(divElement);
    },
    
    /**
     * Configures a two-celled TriCellTable.
     * 
     * @param {Number} orientation0_1 the orientation of element 0 with respect to element 1
     * @param {Number} margin0_1 the margin size between element 0 and element 1
     */
    _configure2: function(orientation0_1, margin0_1) {
        this.tdElements = [document.createElement("td"), document.createElement("td")];
        this.tdElements[0].style.padding = "0";
        this.tdElements[1].style.padding = "0";
        this.marginTdElements = [];
        
        if (margin0_1) {
            this.marginTdElements[0] = document.createElement("td");
            this.marginTdElements[0].style.padding = "0";
            if ((orientation0_1 & Echo.Sync.TriCellTable.VERTICAL) === 0) {
                this.marginTdElements[0].style.width = margin0_1 + "px";
                this._addSpacer(this.marginTdElements[0], margin0_1, false);
            } else {
                this.marginTdElements[0].style.height = margin0_1 + "px";
                this._addSpacer(this.marginTdElements[0], margin0_1, true);
            }
        }
        
        if (orientation0_1 & Echo.Sync.TriCellTable.VERTICAL) {
            // Vertically oriented.
            if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                // Inverted (bottom to top).
                this._addRow(this.tdElements[1]);
                this._addRow(this.marginTdElements[0]);
                this._addRow(this.tdElements[0]);
            } else {
                // Normal (top to bottom).
                this._addRow(this.tdElements[0]);
                this._addRow(this.marginTdElements[0]);
                this._addRow(this.tdElements[1]);
            }
        } else {
            // Horizontally oriented.
            var tr = document.createElement("tr");
            if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                // Trailing to leading.
                this._addColumn(tr, this.tdElements[1]);
                this._addColumn(tr, this.marginTdElements[0]);
                this._addColumn(tr, this.tdElements[0]);
            } else {
                // Leading to trailing.
                this._addColumn(tr, this.tdElements[0]);
                this._addColumn(tr, this.marginTdElements[0]);
                this._addColumn(tr, this.tdElements[1]);
            }
            this.tbodyElement.appendChild(tr);
        }
    },
    
    /**
     * Configures a two-celled TriCellTable.
     * 
     * @param {Number} orientation0_1 the orientation of element 0 with respect to element 1
     * @param {Number} margin0_1 the margin size between element 0 and element 1
     * @param {Number} orientation01_2 the orientation of Elements 0 and 1 with respect to Element 2
     * @param {Number} margin01_2 the margin size between the combination of elements 0 and 1 and element 2
     */
    _configure3: function(orientation0_1, margin0_1, orientation01_2, margin01_2) {
        this.tdElements = [];
        for (var i = 0; i < 3; ++i) {
            this.tdElements[i] = document.createElement("td");
            this.tdElements[i].style.padding = "0";
        }
        this.marginTdElements = [];
        
        if (margin0_1 || margin01_2 != null) {
            if (margin0_1 && margin0_1 > 0) {
                this.marginTdElements[0] = document.createElement("td");
                if (orientation0_1 & Echo.Sync.TriCellTable.VERTICAL) {
                    this.marginTdElements[0].style.height = margin0_1 + "px";
                    this._addSpacer(this.marginTdElements[0], margin0_1, true);
                } else {
                    this.marginTdElements[0].style.width = margin0_1 + "px";
                    this._addSpacer(this.marginTdElements[0], margin0_1, false);
                }
            }
            if (margin01_2 != null && margin01_2 > 0) {
                this.marginTdElements[1] = document.createElement("td");
                if (orientation0_1 & Echo.Sync.TriCellTable.VERTICAL) {
                    this.marginTdElements[1].style.height = margin01_2 + "px";
                    this._addSpacer(this.marginTdElements[1], margin01_2, true);
                } else {
                    this.marginTdElements[1].style.width = margin01_2 + "px";
                    this._addSpacer(this.marginTdElements[1], margin01_2, false);
                }
            }
        }
        
        if (orientation0_1 & Echo.Sync.TriCellTable.VERTICAL) {
            // Vertically oriented 0/1.
            if (orientation01_2 & Echo.Sync.TriCellTable.VERTICAL) {
                // Vertically oriented 01/2
                
                if (orientation01_2 & Echo.Sync.TriCellTable.INVERTED) {
                    // 2 before 01: render #2 and margin at beginning of TABLE.
                    this._addRow(this.tdElements[2]);
                    this._addRow(this.marginTdElements[1]);
                }
                
                // Render 01
                if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                    // Inverted (bottom to top)
                    this._addRow(this.tdElements[1]);
                    this._addRow(this.marginTdElements[0]);
                    this._addRow(this.tdElements[0]);
                } else {
                    // Normal (top to bottom)
                    this._addRow(this.tdElements[0]);
                    this._addRow(this.marginTdElements[0]);
                    this._addRow(this.tdElements[1]);
                }
    
                if (!(orientation01_2 & Echo.Sync.TriCellTable.INVERTED)) {
                    // 01 before 2: render #2 and margin at end of TABLE.
                    this._addRow(this.marginTdElements[1]);
                    this._addRow(this.tdElements[2]);
                }
            } else {
                // Horizontally oriented 01/2
                
                // Determine and apply row span based on presence of margin between 0 and 1.
                var rows = (margin0_1 && margin0_1 > 0) ? 3 : 2;
                this.tdElements[2].rowSpan = rows;
                if (this.marginTdElements[1]) {
                    this.marginTdElements[1].rowSpan = rows;
                }
                
                var tr = document.createElement("tr");
                if (orientation01_2 & Echo.Sync.TriCellTable.INVERTED) {
                    this._addColumn(tr, this.tdElements[2]);
                    this._addColumn(tr, this.marginTdElements[1]);
                    if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                        this._addColumn(tr, this.tdElements[1]);
                    } else {
                        this._addColumn(tr, this.tdElements[0]);
                    }
                } else {
                    if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                        this._addColumn(tr, this.tdElements[1]);
                    } else {
                        this._addColumn(tr, this.tdElements[0]);
                    }
                    this._addColumn(tr, this.marginTdElements[1]);
                    this._addColumn(tr, this.tdElements[2]);
                }
                this.tbodyElement.appendChild(tr);
                
                this._addRow(this.marginTdElements[0]);
                if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                    this._addRow(this.tdElements[0]);
                } else {
                    this._addRow(this.tdElements[1]);
                }
            }
        } else {
            // horizontally oriented 0/1
            if (orientation01_2 & Echo.Sync.TriCellTable.VERTICAL) {
                // vertically oriented 01/2
    
                // determine and apply column span based on presence of margin between 0 and 1
                var columns = margin0_1 ? 3 : 2;
                this.tdElements[2].setAttribute("colspan", columns);
                if (this.marginTdElements[1] != null) {
                    this.marginTdElements[1].setAttribute("colspan", columns);
                }
                
                if (orientation01_2 & Echo.Sync.TriCellTable.INVERTED) {
                    // 2 before 01: render #2 and margin at beginning of TR.
                    this._addRow(this.tdElements[2]);
                    this._addRow(this.marginTdElements[1]);
                }
                
                // Render 01
                tr = document.createElement("tr");
                if ((orientation0_1 & Echo.Sync.TriCellTable.INVERTED) === 0) {
                    // normal (left to right)
                    this._addColumn(tr, this.tdElements[0]);
                    this._addColumn(tr, this.marginTdElements[0]);
                    this._addColumn(tr, this.tdElements[1]);
                } else {
                    // inverted (right to left)
                    this._addColumn(tr, this.tdElements[1]);
                    this._addColumn(tr, this.marginTdElements[0]);
                    this._addColumn(tr, this.tdElements[0]);
                }
                this.tbodyElement.appendChild(tr);
                
                if (!(orientation01_2 & Echo.Sync.TriCellTable.INVERTED)) {
                    // 01 before 2: render margin and #2 at end of TR.
                    this._addRow(this.marginTdElements[1]);
                    this._addRow(this.tdElements[2]);
                }
            } else {
                // horizontally oriented 01/2
                tr = document.createElement("tr");
                if (orientation01_2 & Echo.Sync.TriCellTable.INVERTED) {
                    // 2 before 01: render #2 and margin at beginning of TR.
                    this._addColumn(tr, this.tdElements[2]);
                    this._addColumn(tr, this.marginTdElements[1]);
                }
                
                // Render 01
                if (orientation0_1 & Echo.Sync.TriCellTable.INVERTED) {
                    // inverted (right to left)
                    this._addColumn(tr, this.tdElements[1]);
                    this._addColumn(tr, this.marginTdElements[0]);
                    this._addColumn(tr, this.tdElements[0]);
                } else {
                    // normal (left to right)
                    this._addColumn(tr, this.tdElements[0]);
                    this._addColumn(tr, this.marginTdElements[0]);
                    this._addColumn(tr, this.tdElements[1]);
                }
                
                if (!(orientation01_2 & Echo.Sync.TriCellTable.INVERTED)) {
                    this._addColumn(tr, this.marginTdElements[1]);
                    this._addColumn(tr, this.tdElements[2]);
                }
                
                this.tbodyElement.appendChild(tr);        
            }
        }
    }
});
/**
 * Component rendering peer: Label.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.Label = Core.extend(Echo.Render.ComponentSync, { 

    $static: {
    
       /** 
        * Default spacing between label icon/text. 
        * @type #Extent
        */
       _defaultIconTextMargin: 5
    },
    
    $load: function() {
        Echo.Render.registerPeer("Label", this);
    },
    
    /**
     * The text node or element representing the label.
     * @type Node
     */
    _node: null,
    
    /**
     * Formats the whitespace in the given text for use in HTML.
     * 
     * @param text {String} the text to format
     * @param parentElement the element to append the text to
     */
    _formatWhitespace: function(text, parentElement) {
        // switch between spaces and non-breaking spaces to preserve line wrapping
        text = text.replace(/\t/g, " \u00a0 \u00a0");
        text = text.replace(/ {2}/g, " \u00a0");
        var lines = text.split('\n');
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (i > 0) {
                parentElement.appendChild(document.createElement("br"));
            }
            if (line.length > 0) {
                parentElement.appendChild(document.createTextNode(line));
            }
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._containerElement = parentElement;
        var icon = this.component.render("icon"),
            text = this.component.render("text"),
            foreground = this.component.render("foreground"),
            background = this.component.render("background"),
            toolTip = this.component.render("toolTipText"),
            img;
    
        if (text != null) {
            var lineWrap = this.component.render("lineWrap", true);
            var formatWhitespace = this.component.render("formatWhitespace", false) &&
                    (text.indexOf(' ') != -1 || text.indexOf('\n') != -1 || text.indexOf('\t') != -1);
            
            if (icon) {
                // Text and icon.
                var iconTextMargin = this.component.render("iconTextMargin", 
                        Echo.Sync.Label._defaultIconTextMargin);
                var orientation = Echo.Sync.TriCellTable.getOrientation(this.component, "textPosition");
                var tct = new Echo.Sync.TriCellTable(orientation, Echo.Sync.Extent.toPixels(iconTextMargin));
                img = document.createElement("img");
                Echo.Sync.ImageReference.renderImg(icon, img);
                if (formatWhitespace) {
                    this._formatWhitespace(text, tct.tdElements[0]);
                } else {
                    tct.tdElements[0].appendChild(document.createTextNode(text));
                }
                if (!lineWrap) {
                    tct.tdElements[0].style.whiteSpace = "nowrap";
                }
                tct.tdElements[1].appendChild(img);
                this._node = tct.tableElement;
                this._node.id = this.component.renderId;
                Echo.Sync.renderComponentDefaults(this.component, this._node);
            } else {
                // Text without icon.
                var font = this.component.render("font");
                if (!this.client.designMode && !toolTip && !font && lineWrap && !foreground && !background && 
                        !formatWhitespace && !this.component.getLayoutDirection()) {
                    this._node = document.createTextNode(text);
                } else {
                    this._node = document.createElement("span");
                    this._node.id = this.component.renderId;
                    if (formatWhitespace) {
                        this._formatWhitespace(text, this._node);
                    } else {
                        this._node.appendChild(document.createTextNode(text));
                    }
                    if (!lineWrap) {
                        this._node.style.whiteSpace = "nowrap";
                    }
                    Echo.Sync.renderComponentDefaults(this.component, this._node);
                }
            }
        } else if (icon) {
            img = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(icon, img);
            this._node = document.createElement("span");
            this._node.id = this.component.renderId;
            this._node.appendChild(img);
            Echo.Sync.Color.render(this.component.render("background"), this._node, "backgroundColor");
        } else {
            // Neither icon nor text, render blank.
            if (this.client.designMode) {
                this._node = document.createElement("span");
                this._node.id = this.component.renderId;
            } else {
                this._node = null;
            }
        }
    
        if (this._node) {
            if (toolTip) {
                this._node.title = toolTip;
            }
            parentElement.appendChild(this._node);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._containerElement = null;
        this._node = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (this._node) {
            this._node.parentNode.removeChild(this._node);
        }
        // Note: this.renderDispose() is not invoked (it does nothing).
        this.renderAdd(update, this._containerElement);
        return false; // Child elements not supported: safe to return false.
    }
});
/**
 * Abstract base class for Echo clients.
 * @namespace
 */
Echo.Client = Core.extend({
    
    $static: {

        /**
         * Default client configuration, copied into client configuration.
         */
        DEFAULT_CONFIGURATION: {
            "StopError.Message": "This application has been stopped due to an error.",
            "WaitIndicator.Text": "Please wait...",
            "Action.Continue": "Continue",
            "Action.Restart": "Restart Application"
        },
        
        /**
         * Style property value for <code>displayError</code> indicating a critical error.
         * @type Number
         */
        STYLE_CRITICAL: 0,

        /**
         * Style property value for <code>displayError</code> indicating a message.
         * @type Number
         */
        STYLE_MESSAGE: 1,
    
        /**
         * Global array containing all active client instances in the current browser window.
         * @type Array
         */
        _activeClients: [],

        /**
         * Global listener to respond to resizing of browser window.
         * Invokes _windowResizeListener() method on all active clients.
         * 
         * @param e the DOM resize event
         */
        _globalWindowResizeListener: function(e) {
            for (var i = 0; i < Echo.Client._activeClients.length; ++i) {
                Echo.Client._activeClients[i]._windowResizeListener(e);
            }
        }
    },
    
    $load: function() {
        // Register resize listener on containing window one time.
        Core.Web.DOM.addEventListener(window, "resize", this._globalWindowResizeListener, false);
    },
    
    /**
     * Application-configurable properties.
     * Initialized at construction, this value should never be set, only individual properties of the configuration may
     * be modified.
     * @type Object
     */
    configuration: null,
    
    /**
     * Flag indicating the user interface should be rendered in design-mode, where all rendered component elements are
     * assigned an id.
     * @type Boolean
     */
    designMode: false,
    
    /**
     * The root DOM element in which the application is contained.
     * @type Element
     */
    domainElement: null,
    
    /**
     * The application being managed by this client.
     * @type Echo.Application
     */
    application: null,
    
    /**
     * Id of last issued input restriction id (incremented to deliver unique identifiers). 
     * @type Number
     */
    _lastInputRestrictionId: 0,
    
    /**
     * Number of currently registered input restrictions.
     * @type Number
     */
    _inputRestrictionCount: 0,
    
    /** 
     * Echo.Component renderId-to-restriction listener mapping.
     */
    _inputRestrictionListeners: null,
    
    /**
     * Id (String) map containing input restrictions.
     * Values are booleans, true indicating property updates are NOT restricted, and false
     * indicated all updates are restricted.
     */
    _inputRescriptionMap: null,
    
    /**
     * The renderId of the compoennt which was focused during the last received <code>keyDown</code> event.
     */
    _keyFocusedComponentId: null,
    
    /**
     * Last received keycode from <code>keydown</code> event.  Used for firing cross-browser <Code>keypress</code> events.
     * @type Number
     */
    _lastKeyCode: null,
    
    /**
     * Method reference to this._processKey().
     * @type Function
     */
    _processKeyRef: null,
    
    /**
     * Flag indicating wait indicator is active.
     * @type Boolean
     */
    _waitIndicatorActive: false, 
    
    /**
     * Method reference to this._processApplicationFocus().
     * @type Function
     */
    _processApplicationFocusRef: null,
    
    /**
     * The parent client.
     * @type Echo.Client
     */
    parent: null,
    
    /**
     * Wait indicator.
     * @type Echo.Client.WaitIndicator
     */
    _waitIndicator: null,
    
    /**
     * Restriction time before raising wait indicator, in milliseconds.
     * @type Number
     */
    _preWaitIndicatorDelay: 500,
    
    /**
     * Runnable that will trigger initialization of wait indicator.
     * @type Core.Web.Scheduler.Runnable
     */
    _waitIndicatorRunnable: null,

    /**
     * Creates a new Client instance.  Derived classes must invoke.
     */
    $construct: function() { 
        this.configuration = { };
        for (var x in Echo.Client.DEFAULT_CONFIGURATION) {
            this.configuration[x] = Echo.Client.DEFAULT_CONFIGURATION[x];
        }
        
        this._inputRestrictionMap = { };
        this._processKeyRef = Core.method(this, this._processKey);
        this._processApplicationFocusRef = Core.method(this, this._processApplicationFocus);
        this._waitIndicator = new Echo.Client.DefaultWaitIndicator();
        this._waitIndicatorRunnable = new Core.Web.Scheduler.MethodRunnable(Core.method(this, this._waitIndicatorActivate), 
                this._preWaitIndicatorDelay, false);
    },
    
    $abstract: true,
    
    $virtual: {

        /**
         * Returns the URL of a resource based on package name / 
         * resource name information.
         * Derived implementations should generally override this
         * method, and delegate to superclass if they are unable
         * to provide a resource for a specific URL.
         * Default implementation delegates to parent client
         * (if one is present) or otherwise returns null.
         * 
         * @param {String} packageName the package name in which the resource is contained
         * @param {String} resourceName the resource name
         * @return the full URL
         * @type String
         */
        getResourceUrl: function(packageName, resourceName) {
            if (this.parent) {
                return this.parent.getResourceUrl(packageName, resourceName);
            } else {
                return null;
            }
        },

        /**
         * Determines if the specified component and containing application is ready to receive input.
         * This method should be overridden by client implementations as needed, returning the value
         * from this implementation if the client has no other reason to disallow input.
         * 
         * @param {Echo.Component} component optional parameter indicating the component to query (if omitted, only the
         *        application's readiness state will be investigated)
         * @return true if the application/component are ready to receive input
         * @type Boolean
         */
        verifyInput: function(component) {
            // Check for input restrictions.
            if (this._inputRestrictionCount !== 0) {
                return false;
            }
        
            if (component) {
                return component.isActive();
            } else {
                return this.application.isActive();
            }
        },
        
        /**
         * Default dispose implementation.
         * Invokes configure(null, null) to deconfigure the client.  Disables wait indicator. 
         */
        dispose: function() {
            // Deconfigure.
            this.configure(null, null);

            // Disable wait indicator.
            this._setWaitVisible(false);
        }
    },
    
    /**
     * Registers an element (which is not a descendant of <code>domainElement</code>) that will contain rendered components.
     * The client will register event listeners to this element, such that it can provide notification of client-level events
     * to component synchronization peers when they occur within this element and its descendants.
     * Any component adding an element outside of the <code>domainElement</code> should invoke this method with said element.
     * Any object invoking this method <strong>MUST</strong> invoke <code>removeElement</code> when the element will no longer
     * be used.
     * This method should only be invoked <strong>once per element</code>, and only on the <strong>root element</code> of any 
     * element hierarchy added outside of the <code>domainElement</code>.
     * 
     * The common use case for this method is when adding elements directly to the <code>BODY</code> element of the DOM.
     * 
     * @param element the element to register
     * @see #removeElement
     */
    addElement: function(element) {
        Core.Web.Event.add(element, "keypress", this._processKeyRef, false);
        Core.Web.Event.add(element, "keydown", this._processKeyRef, false);
        Core.Web.Event.add(element, "keyup", this._processKeyRef, false);
    },
    
    /**
     * Configures/Deconfigures the client.  This method must be invoked
     * with the supported application/containing domain element before
     * the client is used, and invoked with null values before it is
     * disposed (in order to clean up resources).
     * 
     * @param {Echo.Application} application the application the client will support (if configuring)
     *        or null (if deconfiguring)
     * @param {Element} domainElement the DOM element into which the client will be rendered (if configuring),
     *        or null (if deconfiguring)
     */
    configure: function(application, domainElement) {
        if (this.application) {
            // Deconfigure current application if one is configured.
            Core.Arrays.remove(Echo.Client._activeClients, this);
            this.removeElement(this.domainElement);
            this.application.removeListener("focus", this._processApplicationFocusRef);
            this.application.doDispose();
            this.application.client = null;
        }
        
        // Update state.
        this.application = application;
        this.domainElement = domainElement;
        
        if (this.application) {
            // Configure new application if being set.
            this.application.client = this;
            this.application.doInit();
            this.application.addListener("focus", this._processApplicationFocusRef);
            this.addElement(this.domainElement);
            Echo.Client._activeClients.push(this);
        }
    },
    
    /**
     * Registers a new input restriction.  Input will be restricted until this and all other
     * input restrictions are removed.
     *
     * @return a handle identifier for the input restriction, which will be used to unregister
     *         the restriction by invoking removeInputRestriction()
     */
    createInputRestriction: function() {
        this._setWaitVisible(true);
        var id = (++this._lastInputRestrictionId).toString();
        ++this._inputRestrictionCount;
        this._inputRestrictionMap[id] = true;
        return id;
    },
    
    /**
     * Displays an error message, locking the state of the client.  The client is unlocked when the user presses an
     * (optionally configurable) action button.
     * 
     * @param {String} message the message to display
     * @param {String} detail optional details about the message (e.g., client-side exception)
     * @param {String} actionText optional text for an action button
     * @param {Function} actionFunction optional function to execute when action button is clicked
     * @param {Number} style the style in which to display the error, one of the following values:
     *        <ul>
     *         <li><code>STYLE_CRITICAL</code>: used to display a critical error (the default)</li>
     *         <li><code>STYLE_MESSAGE</code>: used to display a message to the user</li>
     *        </ul>
     */
    displayError: function(parentElement, message, detail, actionText, actionFunction, style) {
        parentElement = parentElement || document.body;
        
        // Create restriction.
        var restriction = this.createInputRestriction();

        // Disable wait indicator.
        this._setWaitVisible(false);

        // Darken screen.
        var blackoutDiv = document.createElement("div");
        blackoutDiv.style.cssText = "position:absolute;z-index:32766;width:100%;height:100%;background-color:#000000;opacity:0.75";
        if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
            blackoutDiv.style.filter = "alpha(opacity=75)";
        }
        parentElement.appendChild(blackoutDiv);
        
        // Render error message.
        var div = document.createElement("div");
        div.style.cssText = "position:absolute;z-index:32767;width:100%;height:100%;overflow:hidden;";
        parentElement.appendChild(div);
        
        var contentDiv = document.createElement("div");
        contentDiv.style.cssText = "color:#ffffff;padding:20px 40px 0px;" + 
              (style === Echo.Client.STYLE_MESSAGE ? "border-bottom:4px solid #1f1faf;background-color:#1f1f5f" :
              "border-bottom:4px solid #af1f1f;background-color:#5f1f1f");
        
        if (message) {
            var messageDiv = document.createElement("div");
            messageDiv.style.cssText = "font-weight: bold; margin-bottom:20px;";
            messageDiv.appendChild(document.createTextNode(message));
            contentDiv.appendChild(messageDiv);
        }
        
        if (detail) {
            var detailDiv = document.createElement("div");
            detailDiv.style.cssText = "max-height:10em;overflow:auto;margin-bottom:20px;";
            detailDiv.appendChild(document.createTextNode(detail));
            contentDiv.appendChild(detailDiv);
        }
        
        div.appendChild(contentDiv);

        if (actionText) {
            var actionDiv = document.createElement("div");
            actionDiv.tabIndex = "0";
            actionDiv.style.cssText = "margin-bottom:20px;cursor:pointer;font-weight:bold;padding:2px 10px;" +
                    (style === Echo.Client.STYLE_MESSAGE ? "border: 1px outset #2f2faf;background-color:#2f2faf;" :
                    "border: 1px outset #af2f2f;background-color:#af2f2f;");
            actionDiv.appendChild(document.createTextNode(actionText));
            contentDiv.appendChild(actionDiv);
            var listener = Core.method(this, function(e) {
                if (e.type != "keypress" || e.keyCode == 13) { 
                    try {
                        // Remove error elements.
                        Core.Web.DOM.removeEventListener(actionDiv, "click", listener, false);
                        Core.Web.DOM.removeEventListener(actionDiv, "keypress", listener, false);
                        div.parentNode.removeChild(div);
                        blackoutDiv.parentNode.removeChild(blackoutDiv);

                        // Remove restriction.
                        this.removeInputRestriction(restriction);
                    } finally {
                        if (actionFunction) {
                            actionFunction();
                        }
                    }
                }
            });
            
            Core.Web.DOM.addEventListener(actionDiv, "click", listener, false);
            Core.Web.DOM.addEventListener(actionDiv, "keypress", listener, false);
            Core.Web.DOM.focusElement(actionDiv);
        }
    },
    
    /**
     * Loads required libraries and then executes a function, adding input restrictions while the libraries are being loaded.
     *
     * @param {Array} requiredLibraries the URLs of the libraries which must be loaded before the function can execute
     * @param {Function} f the function to execute
     */
    exec: function(requiredLibraries, f) {
        var restriction = this.createInputRestriction();
        Core.Web.Library.exec(requiredLibraries, Core.method(this, function(e) {
            if (e && !e.success) {
                this.fail("Cannot install library: " + e.url + " Exception: " + e.ex);
                return;
            }
            this.removeInputRestriction(restriction);
            f();
        }));
    },
    
    /**
     * Handles an application failure.
     * If the "StopError.URI" property of the <code>configuration</code> is set, the window is redirected to that URI.
     * If it is not set, an error message is displayed over the domain element, and further input is refused.  A restart
     * button is provided to reload the document.
     * 
     * @param {String} detail the error details 
     */
    fail: function(detail) {
        var element = this.domainElement;
        try {
            // Attempt to dispose.
            this.dispose();
        } finally {
            if (this.configuration["StopError.URI"]) {
                // Redirect.
                window.location.href = this.configuration["StopError.URI"];
            } else {
                // Display error.
                this.displayError(element, this.configuration["StopError.Message"], detail, this.configuration["Action.Restart"], 
                        function() {
                    window.location.reload();
                });
            }
        }
    },
    
    /**
     * Force various browsers to redraw the screen correctly.  This method is used to workaround the blank screen bug in 
     * Internet Explorer and the CSS positioning bug in Opera. 
     */
    forceRedraw: function() {
        if (this.parent) {
            this.parent.forceRedraw();
        } else if (Core.Web.Env.QUIRK_IE_BLANK_SCREEN) {
            if (this.domainElement && this.domainElement.offsetHeight === 0) {
                // Force IE browser to re-render entire document if the height of the application's domain element measures zero.
                // This is a workaround for an Internet Explorer bug where the browser's rendering engine fundamentally fails and 
                // simply displays a blank screen (commonly referred to on bug-tracker/forum as the "blank screen of death").
                // This bug appears to be most prevalent in IE7. 
                var displayState = document.documentElement.style.display || "";
                document.documentElement.style.display = "none";
                document.documentElement.style.display = displayState;
            }
        }
    },
    
    /**
     * Returns the configured wait indicator.
     *
     * @return the wait indicator
     * @type Echo.Client.WaitIndicator
     */
    getWaitIndicator: function() {
        return this._waitIndicator;
    },
    
    /**
     * Listener for application change of component focus:
     * invokes focus() method on focused component's peer.
     * 
     * @param e the event
     */
    _processApplicationFocus: function(e) {
        var focusedComponent = this.application.getFocusedComponent();
        if (focusedComponent && focusedComponent.peer && focusedComponent.peer.renderFocus) {
            focusedComponent.peer.renderFocus();
        }
    },
    
    /**
     * Event handler for <code>keydown</code>, <code>keypress</code> events, and <code>keyup</code> events.
     * Notifies focsued component (and its ancestry) of event via <code>clientKeyDown</code>, <code>clientKeyPress</code>,
     * and <code>clientKeyUp</code> methods respectively.
     * 
     * @param e the event
     */
    _processKey: function(e) {
        var up = e.type == "keyup",
            press = e.type == "keypress",
            component = this.application.getFocusedComponent(),
            bubble = true,
            keyEvent = null,
            keyCode;
        
        // Determine key code.
        if (press) {
            // If key event is a keypress, retrieve keycode from previous keydown event.
            keyCode = this._lastKeyCode;
        } else {
            // If key event is not a keypress, translate value from event and additionally store in _lastKeyCode property.
            keyCode = this._lastKeyCode = Core.Web.Key.translateKeyCode(e.keyCode);
        }
        
        if (!up) {
            if (keyCode == 8) {
                // Prevent backspace from navigating to previous page.
                var nodeName = e.target.nodeName ? e.target.nodeName.toLowerCase() : null;
                if (nodeName != "input" && nodeName != "textarea") {
                    Core.Web.DOM.preventEventDefault(e);
                }
            } else if (!press && keyCode == 9) {
                // Process tab keydown event: focus next component in application, prevent default browser action.
                this.application.focusNext(e.shiftKey);
                Core.Web.DOM.preventEventDefault(e);
            }
        
            if (press && Core.Web.Env.QUIRK_KEY_PRESS_FIRED_FOR_SPECIAL_KEYS && !e.charCode) {
                // Do nothing in the event no char code is provided for a keypress.
                return true;
            }
        }
            
        if (!component) {
            // No component is focused, take no action.
            return true;
        }

        if (up || press) {
            if (this._keyFocusedComponentId != component.renderId) {
                // Focus has changed: do not fire clientKeyUp/clientKeyPress events.
                return true;
            }
        } else {
            // Store render id of focused component for keyDown events, such that it can be ensured that keyUp/keyPress events
            // will only be fired if that component remains focused when those events are received. 
            this._keyFocusedComponentId = component.renderId;
        }
        
        // Determine event method which should be invoked.
        var eventMethod = press ? "clientKeyPress" : (up ? "clientKeyUp" : "clientKeyDown");
        
        // Fire event to component and ancestry.
        while (component && bubble) {
            if (component.peer && component.peer[eventMethod]) {
                if (!keyEvent) {
                    // Lazy-create key event.
                    keyEvent = { type: e.type, source: this, keyCode: keyCode, domEvent: e };
                    if (press) {
                        keyEvent.charCode = Core.Web.Env.QUIRK_KEY_CODE_IS_CHAR_CODE ? e.keyCode : e.charCode;
                    }
                }
                // Fire event to clientKeyXXX() method.  Continue bubbling event only if clientKeyXXX() method returns true.
                bubble = component.peer[eventMethod](keyEvent);
            }
            component = component.parent;
        }        
        
        return true;
    },
    
    /**
     * Processes updates to the component hierarchy.
     * Invokes <code>Echo.Render.processUpdates()</code>.
     */
    processUpdates: function() {
        var ir = null;
        try {
            ir = this.createInputRestriction();
            Echo.Render.processUpdates(this);
            this.removeInputRestriction(ir);
            this.forceRedraw();
        } catch (ex) {
            if (ex.lineNumber) {
                // Display reported line number and adjusted line number (used if script was loaded dynamically).
                Core.Debug.consoleWrite("Reported Line #: " + ex.lineNumber);
                Core.Debug.consoleWrite("Evaluated Line #: " + (ex.lineNumber - Core.Web.Library.evalLine) + 
                        " (if evaluated script)");
            }
            if (ex.stack) {
                // Display stack trace if available (Mozilla browsers).
                Core.Debug.consoleWrite("Exception: " + ex + ", Stack Trace: " + ex.stack);
            }
            this.fail("Exception during Client.processUpdates(): " + ex.message);
            throw (ex);
        }
    },
    
    /**
     * Registers a listener to be notified when all input restrictions have been removed.
     * 
     * @param {Echo.Component} component the component for which the restriction listener is being registered
     * @param {Function} l the method to notify when all input restrictions have been cleared 
     */
    registerRestrictionListener: function(component, l) {
        if (!this._inputRestrictionListeners) {
            this._inputRestrictionListeners = { };
        }
        this._inputRestrictionListeners[component.renderId] = l;
    },
    
    /**
     * Removes an input restriction.
     *
     * @param {String} id the id (handle) of the input restriction to remove
     */
    removeInputRestriction: function(id) {
        if (this._inputRestrictionMap[id] === undefined) {
            return;
        }
        delete this._inputRestrictionMap[id];
        --this._inputRestrictionCount;
        
        if (this._inputRestrictionCount === 0) {
            // Last input restriction removed.

            // Disable wait indicator.
            this._setWaitVisible(false);
            
            if (this._inputRestrictionListeners) {
                // Copy restriction listeners to intermediate map, so that listeners can register new
                // listeners that will be invoked the next time all input restrictions are removed.
                var listeners = this._inputRestrictionListeners;
                this._inputRestrictionListeners = null;
               
                // Notify input restriction listeners.
                for (var x in listeners) {
                    listeners[x]();
                }
            }
        }
    },
    
    /**
     * Shows/hides wait indicator.
     * 
     * @param {Boolean} visible the new visibility state of the wait indicator
     */
    _setWaitVisible: function(visible) {
        if (visible) {
            if (!this._waitIndicatorActive) {
                this._waitIndicatorActive = true;
                
                // Schedule runnable to display wait indicator.
                Core.Web.Scheduler.add(this._waitIndicatorRunnable);
            }
        } else {
            if (this._waitIndicatorActive) {
                this._waitIndicatorActive = false;

                // Remove wait indicator from scheduling (if wait indicator has not been presented yet, it will not be).
                Core.Web.Scheduler.remove(this._waitIndicatorRunnable);
                
                // Deactivate if already displayed.
                this._waitIndicator.deactivate(this);
                this.forceRedraw();
            }
        }
    },
    
    /**
     * Sets the wait indicator that will be displayed when a client-server action takes longer than
     * a specified period of time.
     * 
     * @param {Echo.Client.WaitIndicator} waitIndicator the new wait indicator 
     */
    setWaitIndicator: function(waitIndicator) {
        if (this._waitIndicator) {
            this._setWaitVisible(false);
            if (this._waitIndicator.dispose) {
                this._waitIndicator.dispose(this);
            }
        }
        this._waitIndicator = waitIndicator;
    },
    
    /**
     * Unregisters an element (which is not a descendant of <code>domainElement</code>) that will contain rendered components.
     * 
     * @param element the element to unregister
     * @see #addElement
     */
    removeElement: function(element) {
        Core.Web.Event.remove(element, "keypress", this._processKeyRef, false);
        Core.Web.Event.remove(element, "keydown", this._processKeyRef, false);
        Core.Web.Event.remove(element, "keyup", this._processKeyRef, false);
    },
    
    /**
     * Activates the wait indicator.
     */
    _waitIndicatorActivate: function() {
        this._waitIndicator.activate(this);
    },

    /**
     * Instance listener to respond to resizing of browser window.
     * 
     * @param e the DOM resize event
     */
    _windowResizeListener: function(e) {
        if (this.application.rootComponent.peer) {
            Echo.Render.notifyResize(this.application.rootComponent);
        }
    }
});

/**
 * Provides a debugging tool for measuring performance of the Echo3 client engine.
 * This is generally best used to measure performance before/after modifications. 
 */
Echo.Client.Timer = Core.extend({

    /** Array of times. */
    _times: null,
    
    /** Array of labels. */
    _labels: null,
    
    /**
     * Creates a new debug timer.
     * 
     * @constructor
     */
    $construct: function() {
        this._times = [new Date().getTime()];
        this._labels = ["Start"];
    },
    
    /**
     * Marks the time required to complete a task.  This method should be invoked
     * when a task is completed with the 'label' specifying a description of the task.
     * 
     * @param {String} label a description of the completed task.
     */
    mark: function(label) {
        this._times.push(new Date().getTime());
        this._labels.push(label);
    },
    
    /**
     * Returns a String representation of the timer results, showing how long
     * each task required to complete (and included a total time).
     * 
     * @return the timer results
     * @type String
     */
    toString: function() {
        var out = "";
        for (var i = 1; i < this._times.length; ++i) {
            var time = this._times[i] - this._times[i - 1];
            out += this._labels[i] + ":" + time + " ";
        }
        out += "TOT:" + (this._times[this._times.length - 1] - this._times[0]) + "ms";
        return out;
    }
});

/**
 * Abstract base class for "Wait Indicators" which are displayed when the
 * application is not available (e.g., due to in-progress client/server
 * activity. A single wait indicator will be used by the application.
 */
Echo.Client.WaitIndicator = Core.extend({

    $abstract: {
        
        /**
         * Wait indicator activation method. Invoked when the wait indicator
         * should be activated. The implementation should add the wait indicator
         * to the DOM and begin any animation (if applicable).
         * 
         * @param {Echo.Client} the client
         */
        activate: function(client) { },
        
        /**
         * Wait indicator deactivation method. Invoked when the wait indicator
         * should be deactivated. The implementation should remove the wait
         * indicator from the DOM, cancel any animations, and dispose of any
         * resources.
         * 
         * @param {Echo.Client} the client
         */
        deactivate: function(client) { }
    },
    
    $virtual: {
        
        /**
         * Disposes of the wait indicator.
         * 
         * @param {Echo.Client} the client
         */
        dispose: null
    }
});

/**
 * Default wait indicator implementation.
 */
Echo.Client.DefaultWaitIndicator = Core.extend(Echo.Client.WaitIndicator, {
    
    /** Creates a new DefaultWaitIndicator. */
    $construct: function() {
        this._divElement = document.createElement("div");
        this._divElement.style.cssText = "display: none;z-index:32000;position:absolute;top:30px;right:30px;" +
                 "width:200px;padding:20px;border:1px outset #abcdef;background-color:#abcdef;color:#000000;text-align:center;";
        this._textNode = document.createTextNode("");
        this._divElement.appendChild(this._textNode);
        this._fadeRunnable = new Core.Web.Scheduler.MethodRunnable(Core.method(this, this._tick), 50, true);
        document.body.appendChild(this._divElement);
    },
    
    /** @see Echo.Client.WaitIndicator#activate */
    activate: function(client) {
        if (client.configuration["WaitIndicator.Background"]) {
            this._divElement.style.backgroundColor = client.configuration["WaitIndicator.Background"];
            this._divElement.style.borderColor = client.configuration["WaitIndicator.Background"];
        }
        if (client.configuration["WaitIndicator.Foreground"]) {
            this._divElement.style.color = client.configuration["WaitIndicator.Foreground"];
        }
        this._textNode.nodeValue = client.configuration["WaitIndicator.Text"];
        this._divElement.style.display = "block";
        Core.Web.Scheduler.add(this._fadeRunnable);
        this._opacity = 0;
    },
    
    /** @see Echo.Client.WaitIndicator#deactivate */
    deactivate: function(client) {
        this._divElement.style.display = "none";
        Core.Web.Scheduler.remove(this._fadeRunnable);
    },
    
    /** @see Echo.Client.WaitIndicator#dispose */
    dispose: function(client) {
        if (this._divElement && this._divElement.parentNode) {
            this._divElement.parentNode.removeChild(this._divElement);
        }
        this._divElement = null;
        this._textNode = null;
    },
    
    /**
     * Runnable-invoked method to animate (fade in/out) wait indicator.
     */
    _tick: function() {
        ++this._opacity;
        // Formula explained:
        // this._opacity starts at 0 and is incremented forever.
        // First operation is to modulo by 40 then subtract 20, result ranges from -20 to 20.
        // Next take the absolute value, result ranges from 20 to 0 to 20.
        // Divide this value by 30, so the range goes from 2/3 to 0 to 2/3.
        // Subtract that value from 1, so the range goes from 1/3 to 1 and back.
        var opacityValue = 1 - (Math.abs((this._opacity % 40) - 20) / 30);
        if (!Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
            this._divElement.style.opacity = opacityValue;
        }
    }
});
/**
 * Tools for serializing components, stylesheets, and property instances to and from XML.
 * @namespace
 */
Echo.Serial = { 

    /**
     * Map between property class names and property translators.
     * Property translators stored in this map will be used when an object
     * provides a "className" property.
     */
    _translatorMap: { },
    
    /**
     * Array describing mapping between object constructors and property translators.
     * Even indices of the map contain constructors, and the subsequent odd indices
     * contain the property translator suitable for the constructor at the previous
     * index.  This array is iterated to determine the appropriate property translator.
     * This array is only used for a very small number of non-primitive 
     * property types which are provided by JavaScript itself, e.g., Date.
     */
    _translatorTypeData: [ ],
    
    /**
     * Adds a property translator for a specific class name.
     *
     * @param {String} className the class name
     * @param {Echo.Serial.PropertyTranslator} translator the property translator singleton (static class)
     */
    addPropertyTranslator: function(className, translator) {
        this._translatorMap[className] = translator;
    },
    
    /**
     * Adds a property translator for a specific constructor.
     *
     * @param {Function} type the constructor
     * @param {Echo.Serial.PropertyTranslator} translator the property translator singleton (static class) 
     */
    addPropertyTranslatorByType: function(type, translator) {
        this._translatorTypeData.push(type, translator);
    },
    
    /**
     * Retrieves a property translator for a specific class name.
     *
     * @param {String} className the class name
     * @return {Echo.Serial.PropertyTranslator} the property translator
     */
    getPropertyTranslator: function(className) {
        return this._translatorMap[className];
    },
    
    /**
     * Retrieves a property translator for a specific constructor.
     *
     * @param {Function} type the constructor
     * @return {Echo.Serial.PropertyTranslator} the property translator
     */
    getPropertyTranslatorByType: function(type) {
        for (var i = 0; i < this._translatorTypeData.length; i += 2) {
            if (this._translatorTypeData[i] == type) {
                return this._translatorTypeData[i + 1];
            } 
        }
        return null;
    },
    
    /**
     * Deserializes an XML representation of a component into a component instance.
     * Any child components will be added to the created component instance.
     * Events properties will be registered with the client by invoking the
     * "addComponentListener()" method on the provided 'client', passing in
     * the properties 'component' (the component instance) and 'event' (the event
     * type as a string).
     * 
     * @param {Echo.Client} client the containing client
     * @param {Element} cElement the 'c' DOM element to deserialize
     * @param propertyMap (optional) a mapping between property identifiers and property values for referenced properties 
     *        (properties which were rendered elsewhere in the document and are potentially referenced by multiple components)
     * @param styleMap (optional) a mapping between style identifiers and style values for referenced styles (styles which were 
     *        rendered elsewhere in the document and are potentially referenced by multiple components)
     * @return the instantiated component
     */
    loadComponent: function(client, cElement, propertyMap, styleMap) {
        if (!cElement.nodeName == "c") {
            throw new Error("Element is not a component.");
        }
        var type = cElement.getAttribute("t");
        var id = cElement.getAttribute("i");
    
        var component = Echo.ComponentFactory.newInstance(type, id);
        var styleData = component.getLocalStyleData();
        
        var element = cElement.firstChild;
        while (element) {
            if (element.nodeType == 1) {
                switch (element.nodeName) {
                case "c": // Child component
                    var childComponent = this.loadComponent(client, element, propertyMap, styleMap);
                    component.add(childComponent);
                    break;
                case "p": // Property
                    this.loadProperty(client, element, component, styleData, propertyMap);
                    break;
                case "s": // Style name
                    component.setStyleName(element.firstChild ? element.firstChild.nodeValue : null);
                    break;
                case "sr": // Style reference
                    component.setStyle(styleMap ? styleMap[element.firstChild.nodeValue] : null);
                    break;
                case "e": // Event
                    this._loadComponentEvent(client, element, component);
                    break;
                case "en": // Enabled state
                    component.setEnabled(element.firstChild.nodeValue == "true");
                    break;
                case "locale": // Locale
                    component.setLocale(element.firstChild ? element.firstChild.nodeValue : null);
                    break;
                case "dir": // Layout direction
                    component.setLayoutDirection(element.firstChild ?
                            (element.firstChild.nodeValue == "rtl" ? Echo.LayoutDirection.RTL : Echo.LayoutDirection.LTR) : null);
                    break;
                case "f": // Focus
                    if (element.getAttribute("n")) {
                        component.focusNextId = element.getAttribute("n");
                    }
                    if (element.getAttribute("p")) {
                        component.focusPreviousId = element.getAttribute("p");
                    }
                }
            }
            element = element.nextSibling;
        }
        
        return component;
    },
    
    /**
     * Processes an event registration directive element.
     * 
     * @param {Echo.Client} client the client
     * @param {Element} eventElement the event element
     * @param {Echo.Component} the component
     */
    _loadComponentEvent: function(client, eventElement, component) {
        if (client.addComponentListener) {
            var eventType = eventElement.getAttribute("t");
            client.addComponentListener(component, eventType);
        }
    },
    
    /**
     * Deserializes an XML representation of a property into an instance,
     * and assigns it to the specified object.
     * 
     * @param {Echo.Client} client the containing client
     * @param {Element} pElement the property element to parse
     * @param object the object on which the properties should be set (this object
     *        must contain set() and setIndex() methods
     * @param styleData (optional) an associative array on which properties can
     *        be directly set
     * @param propertyMap (optional) a mapping between property identifiers and property values for referenced properties 
     *        (properties which were rendered elsewhere in the document and are potentially referenced by multiple components)
     * @param styleMap (optional) a mapping between style identifiers and style values for referenced styles (styles which were 
     *        rendered elsewhere in the document and are potentially referenced by multiple components)
     */
    loadProperty: function(client, pElement, object, styleData, propertyMap) {
        var name = pElement.getAttribute("n");
        var type = pElement.getAttribute("t");
        var index = pElement.getAttribute("x");
        var value;
        
        if (type) {
            // Invoke custom property processor.
            var translator = Echo.Serial._translatorMap[type];
            if (!translator) {
                throw new Error("Translator not available for property type: " + type);
            }
            value = translator.toProperty(client, pElement);
        } else {
            if (propertyMap) {
                var propertyReference = pElement.getAttribute("r");
                if (propertyReference) {
                    value = propertyMap[propertyReference];
                } else {
                    value = Echo.Serial.String.toProperty(client, pElement);
                }
            } else {
                value = Echo.Serial.String.toProperty(client, pElement);
            }
        }
        
        if (name) {
            if (styleData) {
                if (index == null) {
                    styleData[name] = value;
                } else {
                    var indexValues = styleData[name];
                    if (!indexValues) {
                        indexValues = [];
                        styleData[name] = indexValues;
                    }
                    indexValues[index] = value;
                }
            } else {
                // Property has property name: invoke set(Index).
                if (index == null) {
                    object.set(name, value);
                } else {
                    object.setIndex(name, index, value);
                }
            }
        } else {
            // Property has method name: invoke method.
            var propertyMethod = pElement.getAttribute("m");
            if (index == null) {
                object[propertyMethod](value);
            } else {
                object[propertyMethod](index, value);
            }
        }
    },
    
    /**
     * Deserializes an XML representation of a style sheet into a
     * StyleSheet instance.
     * 
     * @param {Echo.Client} client the client instance
     * @param {Element} ssElement the "ss" element representing the root of the style sheet
     * @param propertyMap the (optional) property map containing referenced property information
     */
    loadStyleSheet: function(client, ssElement, propertyMap) {
        var styleSheet = new Echo.StyleSheet();
        
        var ssChild = ssElement.firstChild;
        while (ssChild) {
            if (ssChild.nodeType == 1) {
                if (ssChild.nodeName == "s") {
                    var style = {};
                    var sChild = ssChild.firstChild;
                    while (sChild) {
                        if (sChild.nodeType == 1) {
                            if (sChild.nodeName == "p") {
                                this.loadProperty(client, sChild, null, style, propertyMap);
                            }
                        }
                        sChild = sChild.nextSibling;
                    }
                    styleSheet.setStyle(ssChild.getAttribute("n") || "", ssChild.getAttribute("t"), style);
                }
            }
            ssChild = ssChild.nextSibling;
        }
        return styleSheet;
    },
    
    /**
     * Serializes a property value into an XML representation.
     * 
     * @param {Echo.Client} client the client instance
     * @param {Element} pElement the "p" element representing the property
     * @param value the value to render to the "p" element
     */
    storeProperty: function(client, pElement, value) {
        if (value == null) {
            // Set no value to indicate null.
        } else if (typeof (value) == "object") {
            var translator = null;
            if (value.className) {
                translator = this._translatorMap[value.className];
            } else {
                translator = this.getPropertyTranslatorByType(value.constructor);
            }
            
            if (!translator || !translator.toXml) {
                // If appropriate translator does not exist, or translator does not support to-XML translation,
                // simply ignore the property.
                return;
            }
            translator.toXml(client, pElement, value);
        } else {
            // call toString here, IE will otherwise convert boolean values to integers
            pElement.appendChild(pElement.ownerDocument.createTextNode(value.toString()));
        }
    }
};

/**
 * Abstract base class for property translators.
 */
Echo.Serial.PropertyTranslator = Core.extend({

    $abstract: true,
    
    $static: {
    
        /**
         * Converts an XML property value to a property instance.
         * 
         *  @param {Echo.Client} client the client
         *  @param {Element} the "p" DOM element describing the property value
         *  @return the generated property instance
         */
        toProperty: function(client, pElement) {
            return null;
        },
    
        /**
         * Optional: converts a property instance to an XML property element.
         * 
         * @param {Echo.Client} client the client
         * @param {Element} pElement the "p" DOM element in which the property value should be stored
         * @param value the property instance
         */
        toXml: null
    }
});

/**
 * Null Property Translator Singleton.
 */
Echo.Serial.Null = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            return null;
        }
    },

    $load: function() {
        Echo.Serial.addPropertyTranslator("0", this);
    }
});

/**
 * Boolean Property Translator Singleton.
 */
Echo.Serial.Boolean = Core.extend(Echo.Serial.PropertyTranslator, {
        
    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            return pElement.firstChild.data == "true";
        }
    },

    $load: function() {
        Echo.Serial.addPropertyTranslator("b", this);
    }
});

/**
 * Integer Property Translator Singleton.
 */
Echo.Serial.Integer = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            return parseInt(pElement.firstChild.data, 10);
        }
    },

    $load: function() {
        Echo.Serial.addPropertyTranslator("i", this);
    }
});

/**
 * Number Property Translator Singleton.
 */
Echo.Serial.Number = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            return parseFloat(pElement.firstChild.data);
        }
    },

    $load: function() {
        Echo.Serial.addPropertyTranslator("n", this);
    }
});

/**
 * String Property Translator Singleton.
 */
Echo.Serial.String = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var textNode = pElement.firstChild;
            if (!textNode) {
                return "";
            }
            var text = textNode.data;
            while (textNode.nextSibling) {
                textNode = textNode.nextSibling;
                text += textNode.data;
            }
            return text;
        }
    },

    $load: function() {
        Echo.Serial.addPropertyTranslator("s", this);
    }
});

/**
 * Date Property Translator Singleton.
 */
Echo.Serial.Date = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        _expr: /(\d{4})\.(\d{2}).(\d{2})/,

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var value = Echo.Serial.String.toProperty(client, pElement);
            var result = this._expr.exec(value);
            if (!result) {
                return null;
            }
            return new Date(result[1], parseInt(result[2], 10) - 1, result[3]);
        },
        
        /** @see Echo.Serial.PropertyTranslator#toXml */
        toXml: function(client, pElement, value) {
            pElement.appendChild(pElement.ownerDocument.createTextNode(
                    value.getFullYear() + "." + (value.getMonth() + 1) + "." + value.getDate()));
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("d", this);
        Echo.Serial.addPropertyTranslatorByType(Date, this);
    }
});

/**
 * Map (Associative Array) Property Translator Singleton.
 */
Echo.Serial.Map = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var mapObject = {};
            var element = pElement.firstChild;
            while (element) {
                if (element.nodeType != 1) {
                    continue;
                }
        
                Echo.Serial.loadProperty(client, element, null, mapObject, null);
                element = element.nextSibling;
            }
            return mapObject;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("m", this);
    }
});

/**
 * Alignment Property Translator Singleton.
 */
Echo.Serial.Alignment = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        _HORIZONTAL_MAP: {
            "leading": "leading",
            "trailing": "trailing",
            "left": "left",
            "center": "center",
            "right": "right"
        },
        
        _VERTICAL_MAP: {
            "top": "top",
            "center": "middle",
            "bottom": "bottom"
        },
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var element = Core.Web.DOM.getChildElementByTagName(pElement, "a");
            var h = this._HORIZONTAL_MAP[element.getAttribute("h")];
            var v = this._VERTICAL_MAP[element.getAttribute("v")];
            
            if (h) {
                if (v) {
                    return { horizontal: h, vertical: v };
                }
                return h;
            }
            if (v) {
                return v;
            }
            return null;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Alignment", this);
        Echo.Serial.addPropertyTranslator("AL", this);
    }
});

/**
 * Border Property Translator Singleton.
 */
Echo.Serial.Border = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
    	    if (pElement.firstChild.nodeType == 3) { // Text content
    	        return pElement.firstChild.data;
    	    } else if (pElement.getAttribute("v")) {
                return pElement.getAttribute("v");
            } else {
                var element = Core.Web.DOM.getChildElementByTagName(pElement, "b");
                var border = {};
                
                var value = element.getAttribute("t");
                if (value) {
                    border.top = value;
                    value = element.getAttribute("r");
                    if (value) {
                        border.right = value;
                        value = element.getAttribute("b");
                        if (value) {
                            border.bottom = value;
                            value = element.getAttribute("l");
                            if (value) {
                                border.left = value;
                            }
                        }
                    }
                } else {
                    throw new Error("Invalid multi-sided border: no sides set.");
                }
                return border;
            }
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Border", this);
        Echo.Serial.addPropertyTranslator("BO", this);
    }
});

/**
 * FillImage Property Translator Singleton.
 */
Echo.Serial.FillImage = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {

        /**
         * Parses a &lt;fi&gt; fill image element.
         * 
         * @param {Echo.Client} client the client
         * @param {Element} fiElement the fill image element
         * @return the parsed fill image
         * @type #FillImage
         */
        parseElement: function(client, fiElement) {
            var url = fiElement.getAttribute("u");
            if (client.decompressUrl) {
                url = client.decompressUrl(url);
            }
            var repeat = fiElement.getAttribute("r");
            var x = fiElement.getAttribute("x");
            var y = fiElement.getAttribute("y");
            
            if (repeat || x || y) {
                return { url: url, repeat: repeat, x: x, y: y };
            } else {
                return url;
            }
        },

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var element = Core.Web.DOM.getChildElementByTagName(pElement, "fi");
            return this.parseElement(client, element);
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("FillImage", this);
        Echo.Serial.addPropertyTranslator("FI", this);
    }
});

/**
 * FillImageBorder Property Translator Singleton.
 */
Echo.Serial.FillImageBorder = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** 
         * (Array) mapping between border indices and property names.
         * @type Array 
         */
        _NAMES: [ "topLeft", "top", "topRight", "left", "right", "bottomLeft", "bottom", "bottomRight" ],
        
        /**
         * Parses a &lt;fbi&gt; fill image border element.
         * 
         * @param {Echo.Client} client the client
         * @param {Element} fibElement the fill image border element
         * @return the parsed fill image border
         * @type #FillImageBorder
         */
        _parseElement: function(client, fibElement) {
            var fillImageBorder = { 
                contentInsets: fibElement.getAttribute("ci") ? fibElement.getAttribute("ci") : null,
                borderInsets: fibElement.getAttribute("bi") ? fibElement.getAttribute("bi") : null,
                color: fibElement.getAttribute("bc")
            };
            
            var element = fibElement.firstChild;
            var i = 0;
            while(element) {
                if (element.nodeType == 1) {
                    if (element.nodeName == "fi") {
                        fillImageBorder[this._NAMES[i]] = Echo.Serial.FillImage.parseElement(client, element);
                        ++i;
                    } else if (element.nodeName == "null-fi") {
                        ++i;
                    }
                }
                element = element.nextSibling;
            }
            if (!(i === 0 || i == 8)) {
                throw new Error("Invalid FillImageBorder image count: " + i);
            }
        
            return fillImageBorder;
        },
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var element = Core.Web.DOM.getChildElementByTagName(pElement, "fib");
            return Echo.Serial.FillImageBorder._parseElement(client, element);
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("FillImageBorder", this);
        Echo.Serial.addPropertyTranslator("FIB", this);
    }
});

/**
 * Font Property Translator Singleton.
 */
Echo.Serial.Font = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var element = Core.Web.DOM.getChildElementByTagName(pElement, "f");
            var tfElements = Core.Web.DOM.getChildElementsByTagName(element, "tf");
            
            var font = { };
            
            if (tfElements.length > 1) {
                font.typeface = [];
                for (var i = 0; i < tfElements.length; ++i) {
                    font.typeface[i] = tfElements[i].firstChild.data;
                }
            } else if (tfElements.length == 1) {
                font.typeface = tfElements[0].firstChild.data;
            }
            
            var size = element.getAttribute("sz");
            if (size) {
                font.size = size;
            }
            
            if (element.getAttribute("bo")) { font.bold        = true; }
            if (element.getAttribute("it")) { font.italic      = true; }
            if (element.getAttribute("un")) { font.underline   = true; }
            if (element.getAttribute("ov")) { font.overline    = true; }
            if (element.getAttribute("lt")) { font.lineThrough = true; }
            
            return font;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Font", this);
        Echo.Serial.addPropertyTranslator("F", this);
    }
});

/**
 * ImageReference Property Translator Singleton.
 */
Echo.Serial.ImageReference = Core.extend(Echo.Serial.PropertyTranslator, {

    $static: {
    
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var url;
    	    if (pElement.firstChild.nodeType == 1) {
    	    	var iElement = pElement.firstChild;
    	        url = iElement.firstChild.data;
    	        if (client.decompressUrl) {
    	            url = client.decompressUrl(url);
    	        }
    	        var width = iElement.getAttribute("w");
    	        width = width ? width : null;
    	        var height = iElement.getAttribute("h");
    	        height = height ? height : null;
    	        
    	        if (width || height) {
    	            return { url: url, width: width, height: height };
    	        } else {
    	            return url;
    	        }
    	    } else {
    	     url = pElement.firstChild.data;
    	    	return client.decompressUrl ? client.decompressUrl(url) : url;
    	    }
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("ImageReference", this);
        Echo.Serial.addPropertyTranslator("I", this);
    }
});

/**
 * LayoutData Property Translator Singleton.
 */
Echo.Serial.LayoutData = Core.extend(Echo.Serial.PropertyTranslator, {
        
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var layoutData = {};
            var element = pElement.firstChild;
            while (element) {
                if (element.nodeType == 1) {
                    if (element.nodeName == "p") {
                        Echo.Serial.loadProperty(client, element, null, layoutData);
                    }
                }
                element = element.nextSibling;
            }
            return layoutData;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("LayoutData", this);
        Echo.Serial.addPropertyTranslator("L", this);
    }
});
/**
 * @fileoverview
 * Freestanding Client Implementation.
 * Provides capability to develop server-independent applications.
 * Requires Core, Core.Web, Application, Render, Serial, Client.
 */
 
/**
 * FreeClient implementation.
 * The init() and dispose() lifecycle methods must be called before the client is used,
 * and when the client will no longer be used, respectively.
 * @namespace
 */ 
Echo.FreeClient = Core.extend(Echo.Client, {

    /** 
     * Method reference to <code>_processUpdate()</code> 
     * @type Function
     */
    _processUpdateRef: null,
    
    /** 
     * Method reference to <code>_doRender()</code> 
     * @type Function
     */
    _doRenderRef: null,
    
    /** Resource package name to base URL mapping for resource paths. */
    _resourcePaths: null,
    
    /** 
     * Flag indicating that a runnable has been enqueued to invoke _doRender(). 
     * @type Boolean
     */
    _renderPending: false,

    /**
     * Creates a new FreeClient.
     *
     * @param {Echo.Application} application the application which the client will contain
     * @param {Element} domainElement the HTML element in which the client will be rendered
     */
    $construct: function(application, domainElement) {
        Echo.Client.call(this);
        this._doRenderRef = Core.method(this, this._doRender);
        this._processUpdateRef = Core.method(this, this._processUpdate);
        this.configure(application, domainElement);
        this._processUpdate();
    },
    
    /**
     * Associates a resource package name with a base URL.
     * Later inquiries to <code>getResourceUrl()</code> with the specified package name will return
     * URLs with the specified <code>baseUrl</code> prepended to the resource name provided in the
     * call to <code>getResourceUrl()</code>.
     *
     * @param {String} packageName the resource package name
     * @param {String} baseUrl the base URL to prepend to resources in the specified package
     */
    addResourcePath: function(packageName, baseUrl) {
        if (!this._resourcePaths) {
            this._resourcePaths = { };
        }
        this._resourcePaths[packageName] = baseUrl;
    },

    /**
     * Disposes of the FreeClient.
     * This method must be invoked when the client will no longer be used, in order to clean up resources.
     */
    dispose: function() {
        this.application.updateManager.removeUpdateListener(this._processUpdateRef);
        Echo.Render.renderComponentDispose(null, this.application.rootComponent);
        Echo.Client.prototype.dispose.call(this);
    },
    
    /**
     * Performs rendering operations by invoking Echo.Render.processUpdates().
     * Invoked in separate execution context (scheduled).
     */
    _doRender: function() {
        if (this.application) {
            // Only execute updates in the event client has not been deconfigured, which can
            // occur before auto-update fires if other operations were scheduled for immediate
            // execution.
            this.processUpdates();
            this._renderPending = false;
        }
    },
    
    /** @see Echo.Client#getResoruceUrl */
    getResourceUrl: function(packageName, resourceName) {
        if (this._resourcePaths && this._resourcePaths[packageName]) {
            return this._resourcePaths[packageName] + resourceName;
        } else {
            return Echo.Client.prototype.getResourceUrl.call(this, packageName, resourceName);
        }
    },
    
    /**
     * Initializes the FreeClient.
     * This method must be invoked before the client is initially used.
     */
    init: function() {
        Core.Web.init();
        this.application.updateManager.addUpdateListener(this._processUpdateRef);
    },
    
    /**
     * Loads an XML style sheet into the client application from a URL.
     * 
     * @param {String} url the URL from which the StyleSheet should be fetched.
     */
    loadStyleSheet: function(url) {
        var conn = new Core.Web.HttpConnection(url, "GET");
        conn.addResponseListener(Core.method(this, this._processStyleSheet));
        conn.connect();
    },
    
    /**
     * Event listener invoked when a StyleSheet fetched via loadStyleSheet() has been retrieved.
     * 
     * @param e the HttpConnection response event
     */
    _processStyleSheet: function(e) {
        if (!e.valid) {
            throw new Error("Received invalid response from StyleSheet HTTP request.");
        }
        
        var ssElement =  e.source.getResponseXml().documentElement;
        var styleSheet = Echo.Serial.loadStyleSheet(this, ssElement);
        this.application.setStyleSheet(styleSheet);
    },

    /** Schedules doRender() to run in next execution context. */  
    _processUpdate: function(e) {
        if (!this._renderPending) {
            this._renderPending = true;
            Core.Web.Scheduler.run(this._doRenderRef);
        }
    }
});
/**
 * @fileoverview
 * Application rendered component module.
 * Requires Core, Core.Web, Application, Render, Serial, Client, FreeClient.
 */

/**
 * Namespace for application-rendered component support.
 * @namespace
 */
Echo.Arc = { };

/**
 * Application class.
 */
Echo.Arc.Application = Core.extend(Echo.Application, {
    
    /**
     * The containing <code>Echo.Arc.ComponentSync</code> instance.
     */
    arcSync: null,
    
    /** @see Echo.Application#isActive */
    isActive: function() {
        if (!this.arcSync.component.isActive()) {
            return false;
        } else {
            return Echo.Application.prototype.isActive.call(this);
        }
    }
});

/**
 * Client for application-rendered components.
 * These clients are automatically created and destroyed by the
 * ArcClient component synchronization peer.
 */
Echo.Arc.Client = Core.extend(Echo.FreeClient, {
    
    /**
     * The synchronization peer for the application-rendered component.
     * @type Echo.Arc.ComponentSync
     */
    arcSync: null,
    
    /** @see Echo.Client#verifyInput */
    verifyInput: function(component, flags) {
        if (!this.arcSync.client.verifyInput(this.arcSync.component, flags)) {
            return false;
        }
        return Echo.FreeClient.prototype.verifyInput.call(this, component, flags);
    }
});

/**
 * Component synchronization peer for application rendered components.
 * Application rendered component peers should extend this peer.
 * The super-implementations of the renderAdd(), renderDispose(),
 * renderDisplay(), and renderUpdate() methods must be invoked.
 */
Echo.Arc.ComponentSync = Core.extend(Echo.Render.ComponentSync, {

    /**
     * The embedded application.
     * @type Echo.Application
     */
    arcApplication: null,
    
    /**
     * The embedded client.
     * @type Echo.Client
     */
    arcClient: null,

    /**
     * The base component that will serve as the rendered form of this synchronization peer's supported component.
     * @type Echo.Component
     */
    baseComponent: null,
    
    /**
     * Default domain element.  A DIV element which is created/returned if 
     */
    _defaultDomainElement: null,
    
    _applicationFocusRef: null,
    
    $abstract: {
    
        /**
         * Creates the base component that will be added to the root
         * of the rendering application.  This component should probably be a
         * ContentPane or other container.
         * This method must be overridden by ARC implementations.
         * 
         * @type Echo.Component
         */
        createComponent: function() { }
    },
    
    $virtual: {
        
        /**
         * Returns the element in which the client should be rendered.
         * Default implementation creates/returns a DIV.
         * May be overridden.  This implementation does not need to be invoked by overriding implementation. 
         * 
         * @type Element
         */
        getDomainElement: function() { 
            if (!this._defaultDomainElement) {
                this._defaultDomainElement = document.createElement("div");
            }
            return this._defaultDomainElement;
        },

        /**
         * Listener for application focus change events.
         * Registered to both the rendered application and the containing component's application.
         */
        _processApplicationFocus: function(e) {
            if (e.source == this.component.application) {
                if (e.newValue != this.component) {
                    // Set focus of rendered application to null when containing application's focus moves
                    // away from the application rendered component.
                    this.arcApplication.setFocusedComponent(null);
                }
            } else if (e.source == this.arcApplication && e.newValue) {
                // Set focus of containing application to the application rendered component when a component contained
                // within the rendered application is focused.
                this.component.application.setFocusedComponent(this.component);
            }
        },
     
        /**
         * Default renderAdd() implementation: appends the element returned by getDomainElement() to the parent.
         * May be overridden.  This implementation does not need to be invoked by overriding implementation. 
         * 
         * @see Echo.Render.ComponentSync#renderAdd
         */
        renderAdd: function(update, parentElement) {
            var element = this.getDomainElement();
            parentElement.appendChild(element);
        },
    
        /**
         * renderDisplay() implementation: must be invoked by overriding method.
         * 
         * This method will create a new client and application instance if one does
         * not exist (i.e., if this method is being called for the first time after
         * renderAdd()).
         * 
         * When the application is created, the component returned by createComponent() 
         * will be added to the root component of the application.  The application will
         * be installed in the DOM at the element returned by the getDomainElement().
         * 
         * @see Echo.Render.ComponentSync#renderDisplay
         */
        renderDisplay: function() {
            if (this.arcApplication) {
                if (!this.baseComponent.peer) {
                    // Do nothing in the event application peers have not been instantiated.
                    return;
                }
                Echo.Render.renderComponentDisplay(this.baseComponent);
            } else {
                this.arcApplication = new Echo.Arc.Application();
                this.arcApplication.arcSync = this;
                this.arcApplication.setStyleSheet(this.client.application.getStyleSheet());
                this.baseComponent = this.createComponent();
                if (!this.baseComponent) {
                    throw new Error("Invalid base component: null");
                }
                this.arcApplication.rootComponent.add(this.baseComponent);
                this.arcClient = new Echo.Arc.Client(this.arcApplication, this.getDomainElement());
                this.arcClient.arcSync = this;
                this.arcClient.parent = this.client;
                this.arcClient.init();
                
                // Register application focus listeners for both containing application and rendered application.
                this._applicationFocusRef = Core.method(this, this._processApplicationFocus);
                this.arcApplication.addListener("focus", this._applicationFocusRef);
                this.client.application.addListener("focus", this._applicationFocusRef);
            }
        },
        
        /**
         * renderDispose() implementation: must be invoked by overriding method.
         * 
         * @see Echo.Render.ComponentSync#renderDispose
         */
        renderDispose: function(update) {
            if (this._applicationFocusRef) {
                // Unregister application focus listeners for both containing application and rendered application.
                this.arcApplication.removeListener("focus", this._applicationFocusRef);
                this.client.application.removeListener("focus", this._applicationFocusRef);
                this._applicationFocusRef = null;
            }
            if (this.arcClient) {
                this.arcClient.dispose();
                this.arcClient = null;
            }
            if (this.arcApplication) {
                this.arcApplication.arcSync = null;
                this.arcApplication = null;
                this.baseComponent = null;
            }
            this._defaultDomainElement = null;
        },
        
        /**
         * renderHide() implementation: must be invoked by overriding method.
         * 
         * @see Echo.Render.ComponentSync#renderHide
         */
        renderHide: function() {
            if (this.arcApplication) {
                if (!this.baseComponent.peer) {
                    // Do nothing in the event application peers have not been instantiated.
                    return;
                }
                Echo.Render.renderComponentHide(this.baseComponent);
            }
        },
        
        /**
         * Default implementation disposes of the existing client and application 
         * and creates a new one.  All application state will be lost.
         * This method should thus be overridden in the event that the application
         * rendered component desires to perform a more efficient update.
         * This implementation may be called by the overriding implementation if
         * replacing-and-redrawing is desired.
         * 
         * @see Echo.Render.ComponentSync#renderUpdate
         */
        renderUpdate: function(update) {
            var domainElement = this.getDomainElement();
            var containerElement = domainElement.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(domainElement);
            this.renderAdd(update, containerElement);
        }
    }
});

/**
 * A simple container in which to render children of an application rendered component.
 * This container will render as a simple DIV element.
 */
Echo.Arc.ChildContainer = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("ArcChildContainer", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "ArcChildContainer"
});

/**
 * Synchronization peer for ChildContainer.
 */
Echo.Arc.ChildContainerPeer = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("ArcChildContainer", this);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = document.createElement("div");
        var component = this.component.get("component");
        if (component) {
            if (!component.parent || !component.parent.peer || !component.parent.peer.client) {
                throw new Error("Invalid component: not part of registered hierarchy.");
            }
            Echo.Render.renderComponentAdd(null, component, this._div);
        }
        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        var component = this.component.get("component");
        if (component) {
            Echo.Render.renderComponentDisplay(component);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        var component = this.component.get("component");
        if (component) {
            Echo.Render.renderComponentDispose(null, component);
        }
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) { }
});
/**
 * A simple debug console which attaches to Core.Debug to provide the capability to view messages printed with
 * <code>Core.Debug.consoleWrite()</code>.
 * 
 * This object intentionally takes advantage of as little functionality of CoreJS/Echo as possible.
 */
Echo.DebugConsole = {
        
    /** 
     * Flag indicating whether the debug console has been installed. 
     * @type Boolean
     */
    _installed: false,
    
    /** 
     * Flag indicating whether the console has been rendered on screen. 
     * @type Boolean
     */
    _rendered: false,
    
    /**
     * The DOM element in which the title is contained.
     */
    _titleDiv: null,
    
    /** 
     * The DOM element to which log messages should be appended. 
     * @type Element
     */
    _contentDiv: null,
    
    /** 
     * The outer container DOM element of the rendered console. 
     * @type Element
     */
    _div: null,
    
    /** 
     * Flag indicating whether the console is logging/processing output.
     * @type Boolean 
     */
    _logging: false,
    
    /** 
     * Flag indicating whether the console is maximized.
     * @type Boolean 
     */
    _maximized: false,
    
    /**
     * Reference to mouse move listener.
     * @type Function
     */
    _mouseMoveRef: null,
    
    /**
     * Reference to mouse up listener.
     * @type Function
     */
    _mouseDownRef: null,
    
    /**
     * Adds a control to the title bar.
     * 
     * @param {String}  text the control text
     * @param {Function} method the method to invoke when the control is clicked
     */
    _addControl: function(text, method) {
        var button = document.createElement("span");
        button.style.cssText = "padding:0 8px 0 0;cursor:pointer;";
        button.appendChild(document.createTextNode("[" + text + "]"));
        this._controlsDiv.appendChild(button);
        Core.Web.DOM.addEventListener(button, "click", Core.method(this, method), false);
    },

    /** Listener for click events from the "Clear" button: removes all content. */
    _clearListener: function(e) {
        while (this._contentDiv.firstChild) {
            this._contentDiv.removeChild(this._contentDiv.firstChild);
        }
    },
    
    /** Listener for click events from the close (X) button: sets display to none. */
    _closeListener: function(e) {
        this._div.style.display = "none";
    },
    
    /**
     * Method which will overwrite Core.Debug.consoleWrite().
     * 
     * @text {String} the text to output
     */
    _consoleWrite: function(text) {
        if (!this._logging) {
            return;
        }
    
        if (!this._rendered) {
            this._render();
        }
        
        var lineDiv = document.createElement("div");
        lineDiv.appendChild(document.createTextNode(text));
        this._contentDiv.appendChild(lineDiv);
        this._contentDiv.scrollTop = 10000000;
    },
    
    /** 
     * Listener for keyboard events (shows/hides console with Ctrl+Alt+C 
     */
    _keyListener: function(e) {
        e = e ? e : window.event;
        if (!(e.keyCode == 67 && e.ctrlKey && e.altKey)) {
            return;
        }
        
        this._logging = true;
        this.setVisible(!this.isVisible());
    },
    
    /**
     * Attaches the Debug console to Core.Web, by overriding the implementation of 
     * <code>Core.Debug.consoleWrite()</code>.
     */
    install: function() {
        if (this._installed) {
            return;
        }
        Core.Web.DOM.addEventListener(document, "keydown", Core.method(this, this._keyListener), false);
        Core.Debug.consoleWrite = function(text) {
            Echo.DebugConsole._consoleWrite(text);
        };
        
        if (document.URL.toString().indexOf("?debug") != -1) {
            this.setVisible(true);
            this._logging = true;
        }
        
        this._installed = true;
    },
    
    /**
     * Queries the visibility of the console.
     * 
     * @return the console visibility state.
     * @type Boolean
     */
    isVisible: function() {
        if (!this._rendered) {
            return false;
        }
        return this._div.style.display == "block";
    },
    
    /** Listener for click events from the maximize (^) button: toggles maximization state. */
    _maximizeListener: function(e) {
        this._maximized = !this._maximized;
        this._div.style.top = "20px";
        this._div.style.right = "20px";
        this._div.style.left = "";
        this._div.style.bottom = "";
        if (this._maximized) {
            var height = document.height || 600;
            var width = document.width || 600;
            this._div.style.width = (width - 50) + "px";
            this._div.style.height = (height - 50) + "px";
            this._contentDiv.style.width = (width - 72) + "px";
            this._contentDiv.style.height = (height - 85) + "px";
        } else {
            this._div.style.width = "300px";
            this._div.style.height = "300px";
            this._contentDiv.style.width = "278px";
            this._contentDiv.style.height = "265px";
        }
    },
    
    /**
     * Renders the debug console to the screen.
     */
    _render: function() {
        var button;
        
        this._div = document.createElement("div");
        this._div.id = "__DebugConsole__";
        this._div.style.cssText = 
                "display:none;position:absolute;top:20px;right:20px;width:300px;height:300px;background-color:#2f2f3f;" +
                "border:5px solid #3f6fff;overflow:hidden;z-index:32500;";
        
        this._titleDiv = document.createElement("div");
        this._titleDiv.style.cssText = "position:relative;" +
                "margin:1px;height:20px;padding:3px 10px;background-color:#5f5f8f;color:#ffffff;overflow:hidden;cursor:move;";
                
        Core.Web.DOM.addEventListener(this._titleDiv, "mousedown", Core.method(this, this._titleMouseDown), false);
        Core.Web.Event.Selection.disable(this._titleDiv);
        this._div.appendChild(this._titleDiv);

        var titleTextDiv = document.createElement("div");
        titleTextDiv.style.cssText = "position:absolute;font-weight:bold;";
        titleTextDiv.appendChild(document.createTextNode("Debug Console"));
        this._titleDiv.appendChild(titleTextDiv);
    
        this._controlsDiv = document.createElement("div");
        this._controlsDiv.style.cssText = "position:absolute;right:0;background-color:#5f5f8f;";
        this._titleDiv.appendChild(this._controlsDiv);
        
        this._addControl("C", this._clearListener);
        this._addControl("^", this._maximizeListener);
        this._addControl("X", this._closeListener);
        
        this._contentDiv = document.createElement("div");
        this._contentDiv.style.cssText = 
                "font-family:monospace;font-size:9px;position:absolute;top:28px;left:1px;" +
                "width:278px;height:265px;padding:3px 10px;background-color:#1f1f2f;overflow:auto;color:#3fff6f;";
        this._div.appendChild(this._contentDiv);
        
        document.body.appendChild(this._div);
        
        this._titleMouseUpRef = Core.method(this, this._titleMouseUp);
        this._titleMouseMoveRef = Core.method(this, this._titleMouseMove);
    
        this._rendered = true;
    },
    
    /**
     * Mouse down event handler for dragging console.
     */
    _titleMouseDown: function(e) {
        this._drag = { originX: e.clientX, originY: e.clientY, initialX: this._div.offsetLeft, initialY: this._div.offsetTop };
        Core.Web.DOM.preventEventDefault(e);
        Core.Web.DOM.addEventListener(document.body, "mouseup", this._titleMouseUpRef, false);
        Core.Web.DOM.addEventListener(document.body, "mousemove", this._titleMouseMoveRef, false);
    },
    
    /**
     * Mouse move event handler for dragging console.
     */
    _titleMouseMove: function(e) {
        if (!this._drag) {
            return;
        }
        this._div.style.right = this._div.style.bottom = "";
        this._div.style.top = (e.clientY - this._drag.originY + this._drag.initialY) + "px";
        this._div.style.left = (e.clientX - this._drag.originX + this._drag.initialX) + "px";
    },
    
    /**
     * Mouse up event handler for dragging console.
     */
    _titleMouseUp: function(e) {
        this._drag = null;
        Core.Web.DOM.removeEventListener(document.body, "mouseup", this._titleMouseUpRef, false);
        Core.Web.DOM.removeEventListener(document.body, "mousemove", this._titleMouseMoveRef, false);
    },
    
    /**
     * Sets the visibility of the console.
     * 
     * @param {Boolean} newValue the new console visibility state
     */
    setVisible: function(newValue) {
        if (!this._rendered) {
            this._render();
        }
        this._div.style.display = newValue ? "block" : "none";
    }
};
/**
 * Abstract base class for column/row peers.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.ArrayContainer = Core.extend(Echo.Render.ComponentSync, {

    $abstract: {

        /**
         * The DOM element name of child container cells.
         * @type String
         */
        cellElementNodeName: null,
        
        /** 
         * Abstract method which renders layout data on child cell element.
         * 
         * @param {Echo.Component} child the child component
         * @param {Element} the DOM element containing the child
         */
        renderChildLayoutData: function(child, cellElement) { }
    },
    
    $virtual: {
        
        /** 
         * The key code which should move focus to the previous child cell. 
         * @type Number
         */
        prevFocusKey: null,
        
        /** 
         * The Echo.Render.ComponentSync focus flag indicating which keys should trigger focus changes to the previous child. 
         * @type Boolean
         */
        prevFocusFlag: null,
        
        /** 
         * The key code which should move focus to the next child cell. 
         * @type Number
         */
        nextFocusKey: null,

        /** 
         * The Echo.Render.ComponentSync focus flag indicating which keys should trigger focus changes to the next child.
         * @type Boolean
         */
        nextFocusFlag: null,
        
        /** 
         * Flag indicating whether focus key should be inverted when the component is rendered with an RTL layout direction.
         * @type Boolean 
         */
        invertFocusRtl: false
    },
    
    /**
     * The root DOM element of the rendered array container.
     * @type Element
     */
    element: null,

    /**
     * The DOM element to which child elements should be added.  May be equivalent to <code>element</code>.
     * @type Element
     */
    containerElement: null,
    
    /**
     * Prototype Element to be cloned and added between cells of the array container.
     * 
     * @type Element
     */
    spacingPrototype: null,

    /** 
     * Number of pixels to be rendered as spacing between child cells of the container.
     * @type Number
     */
    cellSpacing: null,

    /**
     * Mapping between child render ids and child container cell elements. 
     */
    _childIdToElementMap: null,

    /**
     * Processes a key press event.  Provides support for adjusting focus via arrow keys.
     * 
     * @param e the event
     */
    clientKeyDown: function(e) {
        switch (e.keyCode) {
        case this.prevFocusKey:
        case this.nextFocusKey:
            var focusPrevious = e.keyCode == this.prevFocusKey;
            if (this.invertFocusRtl && !this.component.getRenderLayoutDirection().isLeftToRight()) {
                focusPrevious = !focusPrevious;
            }
            var focusedComponent = this.client.application.getFocusedComponent();
            if (focusedComponent && focusedComponent.peer && focusedComponent.peer.getFocusFlags) {
                var focusFlags = focusedComponent.peer.getFocusFlags();
                if ((focusPrevious && focusFlags & this.prevFocusFlag) || (!focusPrevious && focusFlags & this.nextFocusFlag)) {
                    var focusChild = this.client.application.focusManager.findInParent(this.component, focusPrevious);
                    if (focusChild) {
                        this.client.application.setFocusedComponent(focusChild);
                        Core.Web.DOM.preventEventDefault(e.domEvent);
                        return false;
                    }
                }
            }
            break;
        }
        return true;
    },

    /**
     * Renders the specified child to the containerElement.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     * @param {Echo.Component} the child component
     * @param {Number} index the index of the child within the parent 
     */
    _renderAddChild: function(update, child, index) {
        var cellElement = document.createElement(this.cellElementNodeName);
        this._childIdToElementMap[child.renderId] = cellElement;
        Echo.Render.renderComponentAdd(update, child, cellElement);

        this.renderChildLayoutData(child, cellElement);

        if (index != null) {
            var currentChildCount;
            if (this.containerElement.childNodes.length >= 3 && this.cellSpacing) {
                currentChildCount = (this.containerElement.childNodes.length + 1) / 2;
            } else {
                currentChildCount = this.containerElement.childNodes.length;
            }
            if (index == currentChildCount) {
                index = null;
            }
        }
        if (index == null || !this.containerElement.firstChild) {
            // Full render, append-at-end scenario, or index 0 specified and no children rendered.
            
            // Render spacing cell first if index != 0 and cell spacing enabled.
            if (this.cellSpacing && this.containerElement.firstChild) {
                this.containerElement.appendChild(this.spacingPrototype.cloneNode(false));
            }
    
            // Render child cell second.
            this.containerElement.appendChild(cellElement);
        } else {
            // Partial render insert at arbitrary location scenario (but not at end)
            var insertionIndex = this.cellSpacing ? index * 2 : index;
            var beforeElement = this.containerElement.childNodes[insertionIndex];
            
            // Render child cell first.
            this.containerElement.insertBefore(cellElement, beforeElement);
            
            // Then render spacing cell if required.
            if (this.cellSpacing) {
                this.containerElement.insertBefore(this.spacingPrototype.cloneNode(false), beforeElement);
            }
        }
    },
    
    /**
     * Renders all children.  Must be invoked by derived <code>renderAdd()</code> implementations.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     */
    renderAddChildren: function(update) {
        this._childIdToElementMap = {};
    
        var componentCount = this.component.getComponentCount();
        for (var i = 0; i < componentCount; ++i) {
            var child = this.component.getComponent(i);
            this._renderAddChild(update, child);
        }
    },

    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) { 
        this.element = null;
        this.containerElement = null;
        this._childIdToElementMap = null;
        this.spacingPrototype = null;
    },

    /**
     * Removes a child cell.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     * @param {Echo.Component} the child to remove
     */
    _renderRemoveChild: function(update, child) {
        var childElement = this._childIdToElementMap[child.renderId];
        if (!childElement) {
            return;
        }
        
        if (this.cellSpacing) {
            // If cell spacing is enabled, remove a spacing element, either before or after the removed child.
            // In the case of a single child existing in the Row, no spacing element will be removed.
            if (childElement.previousSibling) {
                this.containerElement.removeChild(childElement.previousSibling);
            } else if (childElement.nextSibling) {
                this.containerElement.removeChild(childElement.nextSibling);
            }
        }
        
        this.containerElement.removeChild(childElement);
        
        delete this._childIdToElementMap[child.renderId];
    },

    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var i, fullRender = false;
        if (update.hasUpdatedProperties() || update.hasUpdatedLayoutDataChildren()) {
            // Full render
            fullRender = true;
        } else {
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                // Remove children.
                for (i = 0; i < removedChildren.length; ++i) {
                    this._renderRemoveChild(update, removedChildren[i]);
                }
            }
            var addedChildren = update.getAddedChildren();
            if (addedChildren) {
                // Add children.
                for (i = 0; i < addedChildren.length; ++i) {
                    this._renderAddChild(update, addedChildren[i], this.component.indexOf(addedChildren[i])); 
                }
            }
        }
        if (fullRender) {
            var element = this.element;
            var containerElement = element.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(element);
            this.renderAdd(update, containerElement);
        }
        
        return fullRender;
    }
});

/**
 * Component rendering peer: Column
 */
Echo.Sync.Column = Core.extend(Echo.Sync.ArrayContainer, {

    $load: function() {
        Echo.Render.registerPeer("Column", this);
    },

    /** @see Echo.Render.ComponentSync#cellElementNodeName */
    cellElementNodeName: "div",
    
    /** @see Echo.Sync.ArrayContainer#prevFocusKey */
    prevFocusKey: 38,
    
    /** @see Echo.Sync.ArrayContainer#prevFocusFlag */
    prevFocusFlag: Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_UP,

    /** @see Echo.Sync.ArrayContainer#nextFocusKey */
    nextFocusKey: 40,

    /** @see Echo.Sync.ArrayContainer#nextFocusFlag */
    nextFocusFlag: Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_DOWN,
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.element = this.containerElement = document.createElement("div");
        this.element.id = this.component.renderId;
        this.element.style.outlineStyle = "none";
        this.element.tabIndex = "-1";
    
        Echo.Sync.renderComponentDefaults(this.component, this.element);
        Echo.Sync.Border.render(this.component.render("border"), this.element);
        Echo.Sync.Insets.render(this.component.render("insets"), this.element, "padding");
    
        this.cellSpacing = Echo.Sync.Extent.toPixels(this.component.render("cellSpacing"), false);
        if (this.cellSpacing) {
            this.spacingPrototype = document.createElement("div");
            this.spacingPrototype.style.height = this.cellSpacing + "px";
            this.spacingPrototype.style.fontSize = "1px";
            this.spacingPrototype.style.lineHeight = "0";
        }
        
        this.renderAddChildren(update);

        parentElement.appendChild(this.element);
    },
    
    /** @see Echo.Sync.ArrayContainer#renderChildLayoutData */
    renderChildLayoutData: function(child, cellElement) {
        var layoutData = child.render("layoutData");
        if (layoutData) {
            Echo.Sync.Color.render(layoutData.background, cellElement, "backgroundColor");
            Echo.Sync.FillImage.render(layoutData.backgroundImage, cellElement);
            Echo.Sync.Insets.render(layoutData.insets, cellElement, "padding");
            Echo.Sync.Alignment.render(layoutData.alignment, cellElement, true, this.component);
            if (layoutData.height) {
                cellElement.style.height = Echo.Sync.Extent.toPixels(layoutData.height, false) + "px";
            }
        }
    }
});

/**
 * Component rendering peer: Row
 */
Echo.Sync.Row = Core.extend(Echo.Sync.ArrayContainer, {

    $static: {
    
        /** 
         * Creates a prototype DOM element hierarchy to be cloned when rendering.   
         * 
         * @return the prototype Element
         * @type Element
         */
        _createRowPrototype: function() {
            var div = document.createElement("div");
            div.style.outlineStyle = "none";
            div.tabIndex = "-1";
        
            var table = document.createElement("table");
            table.style.borderCollapse = "collapse";
            div.appendChild(table);
        
            var tbody = document.createElement("tbody");
            table.appendChild(tbody);
            
            tbody.appendChild(document.createElement("tr"));
        
            return div;
        },
        
        /** 
         * The prototype DOM element hierarchy to be cloned when rendering.
         * @type Element 
         */
        _rowPrototype: null
    },
    
    $load: function() {
        this._rowPrototype = this._createRowPrototype();
        Echo.Render.registerPeer("Row", this);
    },

    /** @see Echo.Render.ComponentSync#cellElementNodeName */
    cellElementNodeName: "td",

    /** @see Echo.Sync.ArrayContainer#prevFocusKey */
    prevFocusKey: 37,
    
    /** @see Echo.Sync.ArrayContainer#prevFocusFlag */
    prevFocusFlag: Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_LEFT,
    
    /** @see Echo.Sync.ArrayContainer#nextFocusKey */
    nextFocusKey: 39,

    /** @see Echo.Sync.ArrayContainer#nextFocusFlag */
    nextFocusFlag: Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_RIGHT,
    
    /** @see Echo.Sync.ArrayContainer#invertFocusRtl */
    invertFocusRtl: true,
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.element = Echo.Sync.Row._rowPrototype.cloneNode(true);
        this.element.id = this.component.renderId;

        Echo.Sync.renderComponentDefaults(this.component, this.element);
        Echo.Sync.Border.render(this.component.render("border"), this.element);
        Echo.Sync.Insets.render(this.component.render("insets"), this.element, "padding");
        Echo.Sync.Alignment.render(this.component.render("alignment"), this.element, true, this.component);
        
        //                      div          table      tbody      tr
        this.containerElement = this.element.firstChild.firstChild.firstChild;
    
        this.cellSpacing = Echo.Sync.Extent.toPixels(this.component.render("cellSpacing"), false);
        if (this.cellSpacing) {
            this.spacingPrototype = document.createElement("td");
            this.spacingPrototype.style.padding = 0;
            this.spacingPrototype.style.width = this.cellSpacing + "px";
        }
        
        this.renderAddChildren(update);

        parentElement.appendChild(this.element);
    },

    /** @see Echo.Sync.ArrayContainer#renderChildLayoutData */
    renderChildLayoutData: function(child, cellElement) {
        var layoutData = child.render("layoutData");
        var insets;
        if (layoutData) {
            insets = layoutData.insets;
            Echo.Sync.Color.render(layoutData.background, cellElement, "backgroundColor");
            Echo.Sync.FillImage.render(layoutData.backgroundImage, cellElement);
            Echo.Sync.Alignment.render(layoutData.alignment, cellElement, true, this.component);
            if (layoutData.width) {
                if (Echo.Sync.Extent.isPercent(layoutData.width)) {
                    cellElement.style.width = layoutData.width;
                    if (this.element.firstChild.style.width != "100%") {
                        this.element.firstChild.style.width = "100%";
                    }
                } else {
                    cellElement.style.width = Echo.Sync.Extent.toPixels(layoutData.width, true) + "px";
                }
            }
        }
        if (!insets) {
            insets = 0;
        }
        Echo.Sync.Insets.render(insets, cellElement, "padding");
    }
});
/**
 * Component rendering peer: Button.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.Button = Core.extend(Echo.Render.ComponentSync, {

    $static: {

        /**
         * Default margin between icon and text elements.
         * @type Number
         */
        _defaultIconTextMargin: 5,
        
        /**
         * Prototype DOM hierarchy for a rendered button.
         * @type Element
         */
        _prototypeButton: null,
        
        /**
         * Creates the prototype DOM hierarchy for a rendered button.
         * @type Element
         */
        _createPrototypeButton: function() {
            var div = document.createElement("div");
            div.tabIndex = "0";
            div.style.outlineStyle = "none";
            div.style.cursor = "pointer";
            return div;
        }
    },
    
    $load: function() {
        this._prototypeButton = this._createPrototypeButton();
        Echo.Render.registerPeer("Button", this);
    },
    
    /**
     * The rendered enabled state of the component.
     * @type Boolean
     */
    enabled: null,
    
    /**
     * Outer DIV containing button.
     * @type Element
     */
    div: null,
    
    /**
     * Text-containing element, upon which font styles should be set.
     * @type Element
     */
    _textElement: null,
    
    /**
     * IMG element representing buttons icon.
     * @type Element
     */
    iconImg: null,
    
    /**
     * Method reference to _processRolloverExit.
     * @type Function
     */
    _processRolloverExitRef: null,
    
    /**
     * Method reference to _processInitEvent.
     * @type Function
     */
    _processInitEventRef: null,
    
    /**
     * The rendered focus state of the button.
     * @type Boolean
     */
    _focused: false,
    
    /** Creates a new Echo.Sync.Button */
    $construct: function() { 
        this._processInitEventRef = Core.method(this, this._processInitEvent);
    },
    
    $virtual: {
        
        /**
         * Processes a user action (i.e., clicking or pressing enter when button is focused).
         * Default implementation invokes <code>doAction()</code> on supported <code>Echo.Component</code>.
         */
        doAction: function() {
            this.component.doAction();
        },
        
        /**
         * Renders the content (e.g. text and/or icon) of the button.
         * Appends rendered content to bounding element (<code>this.div</code>).
         */
        renderContent: function() {
            var text = this.component.render("text");
            var icon = Echo.Sync.getEffectProperty(this.component, "icon", "disabledIcon", !this.enabled);
            if (text != null) {
                if (icon) {
                    // Text and icon.
                    var iconTextMargin = this.component.render("iconTextMargin", 
                            Echo.Sync.Button._defaultIconTextMargin);
                    var orientation = Echo.Sync.TriCellTable.getOrientation(this.component, "textPosition");
                    var tct = new Echo.Sync.TriCellTable(orientation, 
                            Echo.Sync.Extent.toPixels(iconTextMargin));
                    this.renderButtonText(tct.tdElements[0], text);
                    this.iconImg = this.renderButtonIcon(tct.tdElements[1], icon);
                    this.div.appendChild(tct.tableElement);
                } else {
                    // Text only.
                    this.renderButtonText(this.div, text);
                }
            } else if (icon) {
                // Icon only.
                this.iconImg = this.renderButtonIcon(this.div, icon);
            }
        },
    
        /**
         * Enables/disables pressed appearance of button.
         * 
         * @param {Boolean} pressedState the new pressed state.
         */
        setPressedState: function(pressedState) {
            var foreground = Echo.Sync.getEffectProperty(this.component, "foreground", "pressedForeground", pressedState);
            var background = Echo.Sync.getEffectProperty(this.component, "background", "pressedBackground", pressedState);
            var backgroundImage = Echo.Sync.getEffectProperty(
                    this.component, "backgroundImage", "pressedBackgroundImage", pressedState);
            var font = Echo.Sync.getEffectProperty(this.component, "font", "pressedFont", pressedState);
            var border = Echo.Sync.getEffectProperty(this.component, "border", "pressedBorder", pressedState);
            
            Echo.Sync.Color.renderClear(foreground, this.div, "color");
            Echo.Sync.Color.renderClear(background, this.div, "backgroundColor");
            Echo.Sync.FillImage.renderClear(backgroundImage, this.div, "backgroundColor");
            Echo.Sync.Border.renderClear(border, this.div);
            if (this._textElement) {
                Echo.Sync.Font.renderClear(font, this._textElement);
            }
            
            if (this.iconImg) {
                var iconUrl = Echo.Sync.ImageReference.getUrl(
                        Echo.Sync.getEffectProperty(this.component, "icon", "pressedIcon", pressedState));
                if (iconUrl != this.iconImg.src) {
                    this.iconImg.src = iconUrl;
                }
            }
        },
        
        /**
         * Enables/disables rollover appearance of button.
         * 
         * @param {Boolean} rolloverState the new rollover state.
         */
        setRolloverState: function(rolloverState) {
            var foreground = Echo.Sync.getEffectProperty(this.component, "foreground", "rolloverForeground", rolloverState);
            var background = Echo.Sync.getEffectProperty(this.component, "background", "rolloverBackground", rolloverState);
            var backgroundImage = Echo.Sync.getEffectProperty(
                    this.component, "backgroundImage", "rolloverBackgroundImage", rolloverState);
            var font = Echo.Sync.getEffectProperty(this.component, "font", "rolloverFont", rolloverState);
            var border = Echo.Sync.getEffectProperty(this.component, "border", "rolloverBorder", rolloverState);
            
            Echo.Sync.Color.renderClear(foreground, this.div, "color");
            Echo.Sync.Color.renderClear(background, this.div, "backgroundColor");
            Echo.Sync.FillImage.renderClear(backgroundImage, this.div, "backgroundColor");
            Echo.Sync.Border.renderClear(border, this.div);
            if (this._textElement) {
                Echo.Sync.Font.renderClear(font, this._textElement);
            }
        
            if (this.iconImg) {
                var iconUrl = Echo.Sync.ImageReference.getUrl(
                        Echo.Sync.getEffectProperty(this.component, "icon", "rolloverIcon", rolloverState));
                if (iconUrl != this.iconImg.src) {
                    this.iconImg.src = iconUrl;
                }
            }
        }
    },
    
    /**
     * Registers event listeners on the button.  This method is invoked lazily, i.e., the first time the button
     * is focused or rolled over with the mouse.  The initial focus/mouse rollover listeners are removed by this method.
     * This strategy is used for performance reasons due to the fact that many buttons may be present 
     * on the screen, and each button has many event listeners, which would otherwise need to be registered on the initial render.
     */
    _addEventListeners: function() {
        this._processRolloverExitRef = Core.method(this, this._processRolloverExit);
    
        // Remove initialization listeners.
        Core.Web.Event.remove(this.div, "focus", this._processInitEventRef);
        Core.Web.Event.remove(this.div, "mouseover", this._processInitEventRef);
        
        Core.Web.Event.add(this.div, "click", Core.method(this, this._processClick), false);
        if (this.component.render("rolloverEnabled")) {
            Core.Web.Event.add(this.div, Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseenter" : "mouseover", 
                    Core.method(this, this._processRolloverEnter), false);
            Core.Web.Event.add(this.div, Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseleave" : "mouseout", 
                    Core.method(this, this._processRolloverExit), false);
        }
        if (this.component.render("pressedEnabled")) {
            Core.Web.Event.add(this.div, "mousedown", Core.method(this, this._processPress), false);
            Core.Web.Event.add(this.div, "mouseup", Core.method(this, this._processRelease), false);
        }
        Core.Web.Event.add(this.div, "focus", Core.method(this, this._processFocus), false);
        Core.Web.Event.add(this.div, "blur", Core.method(this, this._processBlur), false);
        
        Core.Web.Event.Selection.disable(this.div);
    },
    
    /** 
     * Processes a key press event.  Invokes <code>doAction()</code> in the case of enter being pressed.
     * @see Echo.Render.ComponentSync#clientKeyDown 
     */
    clientKeyDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        if (e.keyCode == 13) {
            this.doAction();
            return false;
        } else {
            return true;
        }
    },
    
    /** @see Echo.Render.ComponentSync#getFocusFlags */ 
    getFocusFlags: function() {
        return Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_ALL;
    },
    
    /** Processes a focus blur event. */
    _processBlur: function(e) {
        this._renderFocusStyle(false);
    },
    
    /** Processes a mouse click event. */
    _processClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this.client.application.setFocusedComponent(this.component);
        this.doAction();
    },
    
    /** Processes a focus event. */
    _processFocus: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this.client.application.setFocusedComponent(this.component);
    },
    
    /**
     * The Initial focus/mouse rollover listener.
     * This listener is invoked the FIRST TIME the button is focused or mouse rolled over.
     * It invokes the addListeners() method to lazily add the full listener set to the button.
     */
    _processInitEvent: function(e) {
        this._addEventListeners();
        switch (e.type) {
        case "focus":
            this._processFocus(e);
            break;
        case "mouseover":
            if (this.component.render("rolloverEnabled")) {
                this._processRolloverEnter(e);
            }
            break;
        }
    },
    
    /** Processes a mouse button press event, displaying the button's pressed appearance. */
    _processPress: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        Core.Web.DOM.preventEventDefault(e);
        this.setPressedState(true);
    },
    
    /** Processes a mouse button release event on the button, displaying the button's normal appearance. */
    _processRelease: function(e) {
        if (!this.client) {
            return true;
        }
        this.setPressedState(false);
    },
    
    /** Processes a mouse roll over event, displaying the button's rollover appearance. */
    _processRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return true;
        }
        this.client.application.addListener("focus", this._processRolloverExitRef);
        this.setRolloverState(true);
        return true;
    },
    
    /** Processes a mouse roll over exit event, displaying the button's normal appearance. */
    _processRolloverExit: function(e) {
        if (!this.client || !this.client.application) {
            return true;
        }
        if (this._processRolloverExitRef) {
            this.client.application.removeListener("focus", this._processRolloverExitRef);
        }
        this.setRolloverState(false);
        return true;
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.enabled = this.component.isRenderEnabled();
        
        this.div = Echo.Sync.Button._prototypeButton.cloneNode(false); 
        this.div.id = this.component.renderId;

        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this.div);
        if (this.enabled) {
            Echo.Sync.Color.renderFB(this.component, this.div);
            Echo.Sync.Border.render(this.component.render("border"), this.div);
            Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this.div);
        } else {
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "foreground", "disabledForeground", true), 
                    this.div, "color");
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "background", "disabledBackground", true), 
                    this.div, "backgroundColor");
            Echo.Sync.Border.render(Echo.Sync.getEffectProperty(this.component, "border", "disabledBorder", true), 
                    this.div);
            Echo.Sync.FillImage.render(Echo.Sync.getEffectProperty(this.component, 
                    "backgroundImage", "disabledBackgroundImage", true), this.div);
        }
        
        Echo.Sync.Insets.render(this.component.render("insets"), this.div, "padding");
        Echo.Sync.Alignment.render(this.component.render("alignment"), this.div, true, this.component);
        
        var toolTipText = this.component.render("toolTipText");
        if (toolTipText) {
            this.div.title = toolTipText;
        }
        var width = this.component.render("width");
        if (width) {
            this.div.style.width = Echo.Sync.Extent.toCssValue(width, true, true);
        }
        var height = this.component.render("height");
        if (height) {
            this.div.style.height = Echo.Sync.Extent.toCssValue(height, false);
            this.div.style.overflow = "hidden";
        }
        
        this.renderContent();
        
        if (this.enabled) {
            // Add event listeners for focus and mouse rollover.  When invoked, these listeners will register the full gamut
            // of button event listeners.  There may be a large number of such listeners depending on how many effects
            // are enabled, and as such we do this lazily for performance reasons.
            Core.Web.Event.add(this.div, "focus", this._processInitEventRef, false);
            Core.Web.Event.add(this.div, "mouseover", this._processInitEventRef, false);
        }
        
        parentElement.appendChild(this.div);
    },
    
    /**
     * Renders the button text.  Configures text alignment, and font.
     * 
     * @param element the element which should contain the text.
     * @param text the text to render
     */
    renderButtonText: function(element, text) {
        this._textElement = element;
        var textAlignment = this.component.render("textAlignment"); 
        if (textAlignment) {
            Echo.Sync.Alignment.render(textAlignment, element, true, this.component);
        }
        if (this.enabled) {
            Echo.Sync.Font.render(this.component.render("font"), this._textElement);
        } else {
            Echo.Sync.Font.render(Echo.Sync.getEffectProperty(this.component, "font", "disabledFont", true), this._textElement);
        }
        
        element.appendChild(document.createTextNode(text));
        if (!this.component.render("lineWrap", true)) {
            element.style.whiteSpace = "nowrap";
        }
    },
    
    /** 
     * Renders the button icon.
     * 
     * @param elemnt the element which should contain the icon.
     * @param icon the icon property to render
     */
    renderButtonIcon: function(element, icon) {
        var alignment = this.component.render("alignment"); 
        if (alignment) {
            Echo.Sync.Alignment.render(alignment, element, true, this.component);
        }
        var imgElement = document.createElement("img");
        Echo.Sync.ImageReference.renderImg(icon, imgElement);
        element.appendChild(imgElement);
        return imgElement;
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        if (this._processRolloverExitRef) {
            this.client.application.removeListener("focus", this._processRolloverExitRef);
        }

        Core.Web.Event.removeAll(this.div);
        
        this._focused = false;
        this.div = null;
        this._textElement = null;
        this.iconImg = null;
    },

    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        if (this._focused) {
            return;
        }

        this._renderFocusStyle(true);
        Core.Web.DOM.focusElement(this.div);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this.div;
        var containerElement = element.parentNode;
        this.renderDispose(update);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return false; // Child elements not supported: safe to return false.
    },
    
    /**
     * Enables/disables focused appearance of button.
     * 
     * @param {Boolean} focusState the new focus state.
     */
    _renderFocusStyle: function(focusState) {
        if (this._focused == focusState) {
            return;
        }
        this._focused = focusState;
        var background;
        
        if (!this.component.render("focusedEnabled")) {
            // Render default focus aesthetic.
            background = this.component.render("background");
            if (background != null) {
                var newBackground = focusState ? Echo.Sync.Color.adjust(background, 0x20, 0x20, 0x20) : background;
                Echo.Sync.Color.render(newBackground, this.div, "backgroundColor");
            }
            return;
        } else {
            var foreground = Echo.Sync.getEffectProperty(this.component, "foreground", "focusedForeground", focusState);
            background = Echo.Sync.getEffectProperty(this.component, "background", "focusedBackground", focusState);
            var backgroundImage = Echo.Sync.getEffectProperty(
                    this.component, "backgroundImage", "focusedBackgroundImage", focusState);
            var font = Echo.Sync.getEffectProperty(this.component, "font", "focusedFont", focusState);
            var border = Echo.Sync.getEffectProperty(this.component, "border", "focusedBorder", focusState);
            
            Echo.Sync.Color.renderClear(foreground, this.div, "color");
            Echo.Sync.Color.renderClear(background, this.div, "backgroundColor");
            Echo.Sync.FillImage.renderClear(backgroundImage, this.div, "backgroundColor");
            Echo.Sync.Border.renderClear(border, this.div);
            if (this._textElement) {
                Echo.Sync.Font.renderClear(font, this._textElement);
            }
        
            if (this.iconImg) {
                var iconUrl = Echo.Sync.ImageReference.getUrl(
                        Echo.Sync.getEffectProperty(this.component, "icon", "focusedIcon", focusState));
                if (iconUrl != this.iconImg.src) {
                    this.iconImg.src = iconUrl;
                }
            }
        }
    }
});
/**
 * Component rendering peer: Composite.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.Composite = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Composite", this);
    },

    div: null,
    contentDiv: null,
    
    $virtual: {
        
        /**
         * Renders style attributes on the created DIV.
         * Overridden by <code>Echo.Sync.Panel</code> to provide additional features.
         */
        renderStyle: function() {
            Echo.Sync.renderComponentDefaults(this.component, this.div);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.div = this.contentDiv = document.createElement("div");
        this.div.id = this.component.renderId;
        
        if (this.component.children.length !== 0) {
            this.renderStyle();
            Echo.Render.renderComponentAdd(update, this.component.children[0], this.contentDiv);
        }
        
        parentElement.appendChild(this.div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) { 
        this.div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this.div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});

/**
 * Component rendering peer: Panel.
 */
Echo.Sync.Panel = Core.extend(Echo.Sync.Composite, {
    
    $load: function() {
        Echo.Render.registerPeer("Panel", this);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        if (this._imageBorder) {
            Echo.Sync.FillImageBorder.renderContainerDisplay(this.div);
        }
    },

    /** @see Echo.Sync.Composite#renderStyle */
    renderStyle: function() {
        this._imageBorder = this.component.render("imageBorder");
        
        var child = this.component.children.length !== 0 ? this.component.children[0] : null;
        var width = this.component.render("width");
        var height = this.component.render("height");
        if (Echo.Sync.Extent.isPercent(height)) {
            height = null;
        }
        if (child && child.pane) {
            this.div.style.position = "relative";
            if (!height) {
                height = "10em";
            }
        }
        
        if (width || height) {
            this.contentDiv.style.overflow = "hidden";
            if (height && this._imageBorder) {
                var insetsPx = Echo.Sync.Insets.toPixels(this._imageBorder.contentInsets);
                var contentHeight = Echo.Sync.Extent.toPixels(height) - insetsPx.top - insetsPx.bottom;
                if (!child || !child.pane) {
                    insetsPx = Echo.Sync.Insets.toPixels(this.component.render("insets"));
                    contentHeight -= insetsPx.top + insetsPx.bottom;
                }
                this.contentDiv.style.height = contentHeight + "px";
            }
        }
        
        if (this._imageBorder) {
            this.div = Echo.Sync.FillImageBorder.renderContainer(this._imageBorder, { child: this.contentDiv });
        } else {
            Echo.Sync.Border.render(this.component.render("border"), this.contentDiv);
        }
        Echo.Sync.renderComponentDefaults(this.component, this.contentDiv);
        if (!child || !child.pane) {
            Echo.Sync.Insets.render(this.component.render("insets"), this.contentDiv, "padding");
        }
        Echo.Sync.Alignment.render(this.component.render("alignment"), this.contentDiv, true, this.component);
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this.contentDiv);
        Echo.Sync.Extent.render(width, this.div, "width", true, true);
        Echo.Sync.Extent.render(height, this.div, "height", false, false);
    }
});
/**
 * Component rendering peer: ContentPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.ContentPane = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("ContentPane", this);
    },
    
    /** 
     * Array of child floating panes components, organized by z-index. 
     * @type Array
     */
    _floatingPaneStack: null,
    
    /** 
     * Flag indicating that the rendered z-indices are not synchronized with the order of <code>_floatingPaneStack</code>.
     * @type Boolean
     */
    _zIndexRenderRequired: false,

    /** Constructor. */
    $construct: function() {
        this._floatingPaneStack = [];
    },
    
    /**
     * Returns the measured size of the content pane element.  Child floating pane (e.g. WindowPane) peers may invoke this 
     * method to determine dimensions in which such panes can be placed/moved.
     * 
     * @return a bounds object describing the measured size
     * @type Core.Web.Measure.Bounds
     */
    getSize: function() {
        return new Core.Web.Measure.Bounds(this._div);
    },
    
    /**
     * Raises a floating pane child to the top.
     * 
     * @param {Echo.Component} the child component to raise
     */
    raise: function(child) {
        if (this._floatingPaneStack[this._floatingPaneStack.length - 1] == child) {
            // Already on top, do nothing.
            return;
        }
        Core.Arrays.remove(this._floatingPaneStack, child);
        this._floatingPaneStack.push(child);
        this._renderFloatingPaneZIndices();
        this._storeFloatingPaneZIndices();
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        var i;
        
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.style.position = "absolute";
        this._div.style.width = "100%";
        this._div.style.height = "100%";
        this._div.style.overflow = "hidden";
        this._div.style.zIndex = "0";
        
        Echo.Sync.renderComponentDefaults(this.component, this._div);

        var background = this.component.render("background");
        var backgroundImage = this.component.render("backgroundImage");
        Echo.Sync.FillImage.render(backgroundImage, this._div);
        
        if (!background && !backgroundImage) {
            Echo.Sync.FillImage.render(this.client.getResourceUrl("Echo", "resource/Transparent.gif"), this._div);  
        }
    
        this._childIdToElementMap = {};
        
        var componentCount = this.component.getComponentCount();
        for (i = 0; i < componentCount; ++i) {
            var child = this.component.getComponent(i);
            this._renderAddChild(update, child);
        }
    
        // Store values of horizontal/vertical scroll such that 
        // renderDisplay() will adjust scrollbars appropriately after rendering.
        this._pendingScrollX = this.component.render("horizontalScroll");
        this._pendingScrollY = this.component.render("verticalScroll");
        
        parentElement.appendChild(this._div);

        if (this._zIndexRenderRequired) {
            this._renderFloatingPaneZIndices();
        }
    },

    /**
     * Renders the addition of a child component.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     * @param {Echo.Component} child the child component to add
     */
    _renderAddChild: function(update, child) {
        var childDiv = document.createElement("div");
        this._childIdToElementMap[child.renderId] = childDiv;
        childDiv.style.position = "absolute";
        if (child.floatingPane) {
            var zIndex = child.render("zIndex");
            if (zIndex != null) {
                var added = false;
                var i = 0;
                
                while (i < this._floatingPaneStack.length && !added) {
                    var testZIndex = this._floatingPaneStack[i].render("zIndex");
                    if (testZIndex != null && testZIndex > zIndex) {
                        this._floatingPaneStack.splice(i, 0, child);
                        added = true;
                    }
                    ++i;
                }
                if (!added) {
                    this._floatingPaneStack.push(child);
                }
            } else {
                this._floatingPaneStack.push(child);
            }
            childDiv.style.zIndex = "1";
            childDiv.style.left = childDiv.style.top = 0;
            this._zIndexRenderRequired = true;
        } else {
            var insets = this.component.render("insets", 0);
            var pixelInsets = Echo.Sync.Insets.toPixels(insets);
            childDiv.style.zIndex = "0";
            childDiv.style.left = pixelInsets.left + "px";
            childDiv.style.top = pixelInsets.top + "px";
            childDiv.style.bottom = pixelInsets.bottom + "px";
            childDiv.style.right = pixelInsets.right + "px";
            if (child.pane) {
                childDiv.style.overflow = "hidden";
            } else {
                switch (this.component.render("overflow")) {
                case Echo.ContentPane.OVERFLOW_HIDDEN:
                    childDiv.style.overflow = "hidden";
                    break;
                case Echo.ContentPane.OVERFLOW_SCROLL:
                    childDiv.style.overflow = "scroll";
                    break;
                default:
                    childDiv.style.overflow = "auto";
                    break;
                }
            }
        }
        Echo.Render.renderComponentAdd(update, child, childDiv);
        this._div.appendChild(childDiv);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        var child = this._div.firstChild;
        while (child) {
            Core.Web.VirtualPosition.redraw(child);
            child = child.nextSibling;
        }
    
        // If a scrollbar adjustment has been requested by renderAdd, perform it.
        if (this._pendingScrollX || this._pendingScrollY) {
            var componentCount = this.component.getComponentCount();
            for (var i = 0; i < componentCount; ++i) {
                child = this.component.getComponent(i);
                if (!child.floatingPane) {
                    var contentElement = this._childIdToElementMap[child.renderId];
                    var position, percent;

                    // Adjust horizontal scroll position, if required.
                    if (this._pendingScrollX) {
                        var x = Echo.Sync.Extent.toPixels(this._pendingScrollX);
                        if (Echo.Sync.Extent.isPercent(this._pendingScrollX) || x < 0) {
                            percent = x < 0 ? 100 : parseInt(this._pendingScrollX, 10);
                            position = Math.round((contentElement.scrollWidth - contentElement.offsetWidth) * percent / 100);
                            if (position > 0) {
                                contentElement.scrollLeft = position;
                                if (Core.Web.Env.ENGINE_MSHTML) {
                                    // IE needs to be told twice.
                                    position = Math.round((contentElement.scrollWidth - contentElement.offsetWidth) * 
                                            percent / 100);
                                    contentElement.scrollLeft = position;
                                }
                            }
                        } else {
                            contentElement.scrollLeft = x;
                        }
                        this._pendingScrollX = null;
                    }

                    // Adjust vertical scroll position, if required.
                    if (this._pendingScrollY) {
                        var y = Echo.Sync.Extent.toPixels(this._pendingScrollY);
                        if (Echo.Sync.Extent.isPercent(this._pendingScrollY) || y < 0) {
                            percent = y < 0 ? 100 : parseInt(this._pendingScrollY, 10);
                            position = Math.round((contentElement.scrollHeight - contentElement.offsetHeight) * percent / 100);
                            if (position > 0) {
                                contentElement.scrollTop = position;
                                if (Core.Web.Env.ENGINE_MSHTML) {
                                    // IE needs to be told twice.
                                    position = Math.round((contentElement.scrollHeight - contentElement.offsetHeight) *
                                            percent / 100);
                                    contentElement.scrollTop = position;
                                }
                            }
                        } else {
                            contentElement.scrollTop = y;
                        }
                        this._pendingScrollY = null;
                    }
                    break;
                }
            }
        }
    },

    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._childIdToElementMap = null;
        this._div = null;
    },
    
    /** 
     * Updates the rendered CSS z-index attribute of all floating panes based on their positions in 
     * <code>_floatingPaneStack.</code>. 
     */ 
    _renderFloatingPaneZIndices: function() {
        for (var i = 0; i < this._floatingPaneStack.length; ++i) {
            var childElement = this._childIdToElementMap[this._floatingPaneStack[i].renderId];
            childElement.style.zIndex = 2 + i;
        }
        this._zIndexRenderRequired = false;
    },

    /**
     * Renders the removal of a child component.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     * @param {Echo.Component} child the child component to remove
     */
    _renderRemoveChild: function(update, child) {
        if (child.floatingPane) {
            Core.Arrays.remove(this._floatingPaneStack, child);
        }
        
        var childDiv = this._childIdToElementMap[child.renderId];
        if (!childDiv) {
            // Child never rendered.
            return;
        }
        childDiv.parentNode.removeChild(childDiv);
        delete this._childIdToElementMap[child.renderId];
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var i, fullRender = false;
        if (update.hasUpdatedProperties() || update.hasUpdatedLayoutDataChildren()) {
            // Full render
            fullRender = true;
        } else {
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                // Remove children.
                for (i = 0; i < removedChildren.length; ++i) {
                    this._renderRemoveChild(update, removedChildren[i]);
                }
            }
            var addedChildren = update.getAddedChildren();

            update.renderContext.displayRequired = [];
            
            if (addedChildren) {
                // Add children.
                for (i = 0; i < addedChildren.length; ++i) {
                    if (!addedChildren[i].floatingPane) {
                        // Content updated: renderDisplay() invocation required on ContentPane itself.
                        update.renderContext.displayRequired = null;
                    }
                    this._renderAddChild(update, addedChildren[i], this.component.indexOf(addedChildren[i]));
                    if (update.renderContext.displayRequired) {
                        // If only floating panes are being updated, invoke renderDisplay() only on children.
                        update.renderContext.displayRequired.push(addedChildren[i]); 
                    }
                }

                if (this._zIndexRenderRequired) {
                    this._renderFloatingPaneZIndices();
                }
            }
        }
        if (fullRender) {
            this._floatingPaneStack = [];
            var element = this._div;
            var containerElement = element.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(element);
            this.renderAdd(update, containerElement);
        }
        
        return fullRender;
    },
    
    /** Sets "zIndex" property on all child components based on their positions within the <code>_floatingPaneStack</code>. */
    _storeFloatingPaneZIndices: function() {
        for (var i = 0; i < this._floatingPaneStack.length; ++i) {
            this._floatingPaneStack[i].set("zIndex", i);
        }
    }
});
/**
 * Component rendering peer: Grid.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.Grid = Core.extend(Echo.Render.ComponentSync, {

    $static: {

        /**
         * Creates a prototype rendering of the basic DOM structure of a Grid which may be cloned
         * for enhanced rendering performance.
         * 
         * @return the prototype DOM hierarchy
         * @type Element
         */
        _createPrototypeTable: function() {
            var table = document.createElement("table");
            table.style.outlineStyle = "none";
            table.tabIndex = "-1";
            table.style.borderCollapse = "collapse";
            
            var colGroup = document.createElement("colgroup");
            table.appendChild(colGroup);
        
            table.appendChild(document.createElement("tbody"));
            
            return table;
        },
        
        /**
         * Performs processing on layout of grid, determining rendered cell sizes, and
         * eliminating conflicting row/column spans.
         * 
         * This object describes coordinates in terms of x and y, rather than column/row.
         * The translation between x/y and column/row varies based on the grid's orientation.
         * For horizontally oriented grids, the x-axis represents columns and the y-axis rows.
         * For vertically oriented grids, the x-axis represents rows and the y-axis columns.
         */
        Processor: Core.extend({
        
            $static: {
            
                /**
                 * Representation of a single cell of the grid.
                 */
                Cell: Core.extend({
                    
                    /** 
                     * The number of cells spanned in the x direction
                     * @type Number
                     */
                    xSpan: null,
                    
                    /** 
                     * The number of cells spanned in the y direction. 
                     * @type Number
                     */
                    ySpan: null,
                    
                    /** 
                     * The index of the child component within the Grid parent. 
                     * @type Number
                     */
                    index: null,
                    
                    /** 
                     * The child component.
                     * @type Echo.Component 
                     */
                    component: null,
                    
                    /**
                     * Creates a new cell.
                     * 
                     * @param {Echo.Component} component the component
                     * @param {Number} index the index of the component within the Grid parent
                     * @param {Number} xSpan the number of cells spanned in the x direction
                     * @param {Number} ySpan the number of cells spanned in the y direction
                     */
                    $construct: function(component, index, xSpan, ySpan) {
                        this.component = component;
                        this.index = index;
                        this.xSpan = xSpan;
                        this.ySpan = ySpan;
                    }
                })
            },
            
            /**
             * Two dimensional array which contains <code>Cell</code>s.
             * Each index of this array contains an array which represents a y-index of the grid.
             * Each index in a contained arrays represents a cell of the grid.
             * @type Array
             */
            cellArrays: null,
            
            /**
             * The Grid being rendered.
             * @type Echo.Grid
             */
            grid: null,
            
            /** 
             * The size of the grid's x-axis.
             * @type Number
             */ 
            gridXSize: null,
            
            /** 
             * The size of the grid's x-axis.
             * @type Number
             */ 
            gridYSize: null,
            
            /**
             * Array of extents representing cell sizes on x-axis.
             * @type Array
             */
            xExtents: null,
            
            /**
             * Array of extents representing cell sizes on y-axis.
             * @type Array
             */
            yExtents: null,
            
            /**
             * Flag indicating whether the grid is horizontally oriented.
             * @type Boolean
             */
            horizontalOrientation: null,
            
            /**
             * Creates a new Processor instance.
             * 
             * @param {Echo.Grid} grid the supported grid
             */
            $construct: function(grid) {
                this.grid = grid;
                this.cellArrays = [];
                this.horizontalOrientation = grid.render("orientation") != Echo.Grid.ORIENTATION_VERTICAL;
                
                var cells = this.createCells();
                if (cells == null) {
                    // Special case: empty Grid.
                    this.gridXSize = 0;
                    this.gridYSize = 0;
                    return;
                }
            
                
                this.renderCellMatrix(cells);
                
                this.calculateExtents();
                
                this.reduceY();
                this.reduceX();
            },
            
            /**
             * Adds two extents.
             * 
             * @param {#Extent} a the first extent
             * @param {#Extent} b the second extent
             * @param {Boolean} flag indicating whether extents are horizontal
             * @return the sum of the extents
             * @type #Extent
             */
            addExtents: function(a, b, horizontal) {
                var ap = Echo.Sync.Extent.isPercent(a), bp = Echo.Sync.Extent.isPercent(b);
                if (ap || bp) {
                    if (ap && bp) {
                        // Both are percents, add them.
                        return (parseFloat(a) + parseFloat(b)) + "%";
                    } else {
                        // One extent is percent, the other is not: return the percent extent.
                        return ap ? a : b;
                    }
                } else {
                    return Echo.Sync.Extent.toPixels(a) + Echo.Sync.Extent.toPixels(b);
                }
            },
            
            /**
             * Calculates sizes of columns and rows.
             */
            calculateExtents: function() {
                var i,
                    xProperty = this.horizontalOrientation ? "columnWidth" : "rowHeight",
                    yProperty = this.horizontalOrientation ? "rowHeight" : "columnWidth";
                
                this.xExtents = [];
                for (i = 0; i < this.gridXSize; ++i) {
                    this.xExtents.push(this.grid.renderIndex(xProperty, i));
                }
            
                this.yExtents = [];
                for (i = 0; i < this.gridYSize; ++i) {
                    this.yExtents.push(this.grid.renderIndex(yProperty, i));
                }
            },
            
            /**
             * Creates array of <code>Cell</code> instances representing child components of the grid.
             * 
             * @return the array of <code>Cell</code> instances
             * @type Array
             */
            createCells: function() {
                var childCount = this.grid.getComponentCount();
                if (childCount === 0) {
                    // Abort if Grid is empty.
                    return null;
                }
                
                var cells = [];
                for (var i = 0; i < childCount; ++i) {
                    var child = this.grid.getComponent(i);
                    var layoutData = child.render("layoutData");
                    if (layoutData) {
                        var xSpan = this.horizontalOrientation ? layoutData.columnSpan : layoutData.rowSpan; 
                        var ySpan = this.horizontalOrientation ? layoutData.rowSpan : layoutData.columnSpan; 
                        cells.push(new Echo.Sync.Grid.Processor.Cell(child, i, xSpan ? xSpan : 1, ySpan ? ySpan : 1));
                    } else {
                        cells.push(new Echo.Sync.Grid.Processor.Cell(child, i, 1, 1));
                    }
                }
                return cells;
            },
            
            /**
             * Returns an array representing the cells at the specified y-index.
             * If no array currently exists, one is created.
             * 
             * @param {Integer} y the y-index
             * @return the array of cells.
             * @type Array
             */
            _getCellArray: function(y) {
                while (y >= this.cellArrays.length) {
                    this.cellArrays.push([]);
                }
                return this.cellArrays[y]; 
            },
            
            /**
             * Returns the number of columns that should be rendered.
             * 
             * @return the number of rendered columns
             * @type Integer
             */
            getColumnCount: function() {
                return this.horizontalOrientation ? this.gridXSize : this.gridYSize;
            },
            
            /**
             * Returns the cell that should be rendered at the
             * specified position.
             * 
             * @param {Integer} column the column index
             * @param {Integer} row the row index
             * @return the cell
             * @type Echo.Sync.Grid.Processor.Cell
             */
            getCell: function(column, row) {
                if (this.horizontalOrientation) {
                    return this.cellArrays[row][column];
                } else {
                    return this.cellArrays[column][row];
                }
            },
            
            /**
             * Returns the number of rows that should be rendered.
             * 
             * @return the number of rendered rows
             * @type Integer
             */
            getRowCount: function() {
                return this.horizontalOrientation ? this.gridYSize : this.gridXSize;
            },
            
            /**
             * Remove duplicates from the x-axis where all cells simply
             * "span over" a given x-axis coordinate. 
             */
            reduceX: function() {
                // Determine duplicate cell sets on x-axis.
                var xRemoves = [], 
                    x = 1, 
                    y, 
                    length = this.cellArrays[0].length;
                while (x < length) {
                    y = 0;
                    var identical = true;
                    while (y < this.cellArrays.length) {
                        if (this.cellArrays[y][x] != this.cellArrays[y][x - 1]) {
                            identical = false;
                            break;
                        }
                        ++y;
                    }
                    if (identical) {
                        xRemoves[x] = true;
                    }
                    ++x;
                }
                
                // If no reductions are necessary on the x-axis, do nothing.
                if (xRemoves.length === 0) {
                    return;
                }
                
                for (var removedX = this.gridXSize - 1; removedX >= 1; --removedX) {
                    if (!xRemoves[removedX]) {
                        continue;
                    }
                    
                    for (y = 0; y < this.gridYSize; ++y) {
                        if (y === 0 || this.cellArrays[y][removedX - 1] != this.cellArrays[y - 1][removedX - 1]) {
                            // Reduce x-span, taking care not to reduce it multiple times if cell has a y-span.
                            if (this.cellArrays[y][removedX - 1] != null) {
                                --this.cellArrays[y][removedX - 1].xSpan;
                            }
                        }
                        this.cellArrays[y].splice(removedX, 1);
                    }
                    
                    var removedXExtent = this.xExtents.splice(removedX, 1)[0];

                    if (removedXExtent) {
                        this.xExtents[removedX - 1] = this.addExtents(this.xExtents[removedX - 1], removedXExtent,
                                this.horizontalOrientation ? true : false);
                    }
                    
                    --this.gridXSize;
                }
            },
            
            /**
             * Remove duplicates from the y-axis where all cells simply
             * "span over" a given y-axis coordinate. 
             */
            reduceY: function() {
                var yRemoves = [],
                    y = 1,
                    x,
                    size = this.cellArrays.length,
                    previousCellArray,
                    currentCellArray = this.cellArrays[0];
                
                while (y < size) {
                    previousCellArray = currentCellArray;
                    currentCellArray = this.cellArrays[y];
                    
                    x = 0;
                    var identical = true;
                    
                    while (x < currentCellArray.length) {
                        if (currentCellArray[x] != previousCellArray[x]) {
                            identical = false;
                            break;
                        }
                        ++x;
                    }
                    if (identical) {
                        yRemoves[y] = true;
                    }
                    
                    ++y;
                }
                
                // If no reductions are necessary on the y-axis, do nothing.
                if (yRemoves.length === 0) {
                    return;
                }
                
                for (var removedY = this.gridYSize - 1; removedY >= 0; --removedY) {
                    if (!yRemoves[removedY]) {
                        continue;
                    }
                    
                    // Shorten the y-spans of the cell array that will be retained to 
                    // reflect the fact that a cell array is being removed.
                    var retainedCellArray = this.cellArrays[removedY - 1];
                    for (x = 0; x < this.gridXSize; ++x) {
                        if (x === 0 || retainedCellArray[x] != retainedCellArray[x - 1]) {
                            // Reduce y-span, taking care not to reduce it multiple times if cell has an x-span.
                            if (retainedCellArray[x] != null) {
                                --retainedCellArray[x].ySpan;
                            }
                        }
                    }
                    
                    // Remove the duplicate cell array.
                    this.cellArrays.splice(removedY, 1);
                    
                    // Remove size data for removed row, add value to previous if necessary.
                    var removedYExtent = this.yExtents.splice(removedY, 1)[0];
                    if (removedYExtent) {
                        this.yExtents[removedY - 1] = this.addExtents(this.yExtents[removedY - 1], removedYExtent,
                                this.horizontalOrientation ? false : true);
                    }
                    
                    // Decrement the grid size to reflect cell array removal.
                    --this.gridYSize;
                }
            },
            
            /**
             * Iterates over cells to create the cell matrix, adjusting column and row spans as of cells to ensure
             * that no overlap occurs between column and row spans.
             * Additionally determines actual y-size of grid.   
             * 
             * @param {Array} cells array of <code>Echo.Sync.Grid.Processor.Cell</code> instances 
             */
            renderCellMatrix: function(cells) {
                this.gridXSize = parseInt(this.grid.render("size", 2), 10);
                var x = 0, 
                    y = 0,
                    xIndex,
                    yIndex,
                    yCells = this._getCellArray(y);
                
                for (var componentIndex = 0; componentIndex < cells.length; ++componentIndex) {
                    
                    // Set x-span to fill remaining size in the event SPAN_FILL has been specified or if the cell would
                    // otherwise extend past the specified size.
                    if (cells[componentIndex].xSpan == Echo.Grid.SPAN_FILL || cells[componentIndex].xSpan > this.gridXSize - x) {
                        cells[componentIndex].xSpan = this.gridXSize - x;
                    }
                    
                    // Set x-span of any cell INCORRECTLY set to negative value to 1 (note that SPAN_FILL has already been handled).
                    if (cells[componentIndex].xSpan < 1) {
                        cells[componentIndex].xSpan = 1;
                    }
                    // Set y-span of any cell INCORRECTLY set to negative value (or more likely SPAN_FILL) to 1.
                    if (cells[componentIndex].ySpan < 1) {
                        cells[componentIndex].ySpan = 1;
                    }
                    
                    if (cells[componentIndex].xSpan != 1 || cells[componentIndex].ySpan != 1) {
                        // Scan to ensure no y-spans are blocking this x-span.
                        // If a y-span is blocking, shorten the x-span to not
                        // interfere.
                        for (xIndex = 1; xIndex < cells[componentIndex].xSpan; ++xIndex) {
                            if (yCells[x + xIndex] != null) {
                                // Blocking component found.
                                cells[componentIndex].xSpan = xIndex;
                                break;
                            }
                        }
                        for (yIndex = 0; yIndex < cells[componentIndex].ySpan; ++yIndex) {
                            var yIndexCells = this._getCellArray(y + yIndex);
                            for (xIndex = 0; xIndex < cells[componentIndex].xSpan; ++xIndex) {
                                yIndexCells[x + xIndex] = cells[componentIndex];
                            }
                        }
                    }
                    yCells[x] = cells[componentIndex];
            
                    if (componentIndex < cells.length - 1) {
                        // Move rendering cursor.
                        var nextRenderPointFound = false;
                        while (!nextRenderPointFound) {
                            if (x < this.gridXSize - 1) {
                                ++x;
                            } else {
                                // Move cursor to next line.
                                x = 0;
                                ++y;
                                yCells = this._getCellArray(y);
                                
                            }
                            nextRenderPointFound = yCells[x] == null;
                        }
                    }
                }
            
                // Store actual 'y' dimension.
                this.gridYSize = this.cellArrays.length;
            }
        })
    },
    
    $load: function() {
        this._prototypeTable = this._createPrototypeTable();
        Echo.Render.registerPeer("Grid", this);
    },
    
    /**
     * The number of columns.
     * @type Number
     */
    _columnCount: null,
    
    /**
     * The number of rows.
     * @type Number
     */
    _rowCount: null,
    
    /**
     * Processes a key press event (for focus navigation amongst child cells.
     */
    clientKeyDown: function(e) { 
        var focusPrevious,
            focusedComponent,
            focusFlags,
            focusChild;
        switch (e.keyCode) {
        case 37:
        case 39:
            focusPrevious = this.component.getRenderLayoutDirection().isLeftToRight() ? e.keyCode == 37 : e.keyCode == 39;
            focusedComponent = this.client.application.getFocusedComponent();
            if (focusedComponent && focusedComponent.peer && focusedComponent.peer.getFocusFlags) {
                focusFlags = focusedComponent.peer.getFocusFlags();
                if ((focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_LEFT) ||
                        (!focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_RIGHT)) {
                    focusChild = this.client.application.focusManager.findInParent(this.component, focusPrevious);
                    if (focusChild) {
                        this.client.application.setFocusedComponent(focusChild);
                        Core.Web.DOM.preventEventDefault(e.domEvent);
                        return false;
                    }
                }
            }
            break;
        case 38:
        case 40:
            focusPrevious = e.keyCode == 38;
            focusedComponent = this.client.application.getFocusedComponent();
            if (focusedComponent && focusedComponent.peer && focusedComponent.peer.getFocusFlags) {
                focusFlags = focusedComponent.peer.getFocusFlags();
                if ((focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_UP) ||
                        (!focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_DOWN)) {
                    focusChild = this.client.application.focusManager.findInParent(this.component, focusPrevious,
                            this._columnCount);
                    if (focusChild) {
                        this.client.application.setFocusedComponent(focusChild);
                        Core.Web.DOM.preventEventDefault(e.domEvent);
                        return false;
                    }
                }
            }
            break;
        }
        return true;
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        var gridProcessor = new Echo.Sync.Grid.Processor(this.component),
            defaultInsets = Echo.Sync.Insets.toCssValue(this.component.render("insets", 0)),
            defaultPixelInsets,
            defaultBorder = this.component.render("border", ""),
            width = this.component.render("width"),
            height = this.component.render("height"),
            td,
            columnIndex;
        defaultPixelInsets = Echo.Sync.Insets.toPixels(defaultInsets);
        
        this._columnCount = gridProcessor.getColumnCount();
        this._rowCount = gridProcessor.getRowCount();
        
        this._table = Echo.Sync.Grid._prototypeTable.cloneNode(true);
        this._table.id = this.component.renderId;
        
        Echo.Sync.renderComponentDefaults(this.component, this._table);
        Echo.Sync.Border.render(defaultBorder, this._table);
        this._table.style.padding = defaultInsets; 
        
        // Render percent widths using measuring for IE to avoid potential horizontal scrollbars.
        if (width && Core.Web.Env.QUIRK_IE_TABLE_PERCENT_WIDTH_SCROLLBAR_ERROR && Echo.Sync.Extent.isPercent(width)) {
            this._renderPercentWidthByMeasure = parseInt(width, 10);
            width = null;
        }
        
        // Set overall width/height.
        if (width) {
            if (Echo.Sync.Extent.isPercent(width)) {
                this._table.style.width = width;
            } else {
                this._table.style.width = Echo.Sync.Extent.toCssValue(width, true);
            }
        }
        if (height) {
            if (Echo.Sync.Extent.isPercent(height)) {
                this._table.style.height = height;
            } else {
                this._table.style.height = Echo.Sync.Extent.toCssValue(height, false);
            }
        }

        // Render column widths into colgroup element.
        var colGroup = this._table.firstChild;
        for (columnIndex = 0; columnIndex < this._columnCount; ++columnIndex) {
            var col = document.createElement("col");
            width = gridProcessor.xExtents[columnIndex];
            if (width != null) {
                if (Echo.Sync.Extent.isPercent(width)) {
                    col.style.width = width.toString();
                } else {
                    var widthValue = Echo.Sync.Extent.toPixels(width, true);
                    if (Core.Web.Env.QUIRK_TABLE_CELL_WIDTH_EXCLUDES_PADDING) {
                        widthValue -= defaultPixelInsets.left + defaultPixelInsets.right;
                        if (widthValue < 0) {
                            widthValue = 0;
                        }
                    }
                    col.style.width = widthValue + "px";
                }
            }
            colGroup.appendChild(col);
        }
        
        var tbody = colGroup.nextSibling;
        
        var size = parseInt(this.component.render("size", 2), 10);
        
        var tr;
        var renderedComponentIds = {};
        
        var xSpan, ySpan;
        if (gridProcessor.horizontalOrientation) {
            xSpan = "colSpan";
            ySpan = "rowSpan"; 
        } else {
            xSpan = "rowSpan";
            ySpan = "colSpan"; 
        }
        
        var tdPrototype = document.createElement("td");
        Echo.Sync.Border.render(defaultBorder, tdPrototype);
        tdPrototype.style.padding = defaultInsets;
        
        // Render grid layout.
        for (var rowIndex = 0; rowIndex < this._rowCount; ++rowIndex) {
            tr = document.createElement("tr");
            height = gridProcessor.yExtents[rowIndex];
            if (height) {
                tr.style.height = Echo.Sync.Extent.toCssValue(height, false);
            }
            tbody.appendChild(tr);
            
            for (columnIndex = 0; columnIndex < this._columnCount; ++columnIndex) {
                var cell = gridProcessor.getCell(columnIndex, rowIndex);
                if (cell == null) {
                    td = document.createElement("td");
                    tr.appendChild(td);
                    continue;
                }
                if (renderedComponentIds[cell.component.renderId]) {
                    // Cell already rendered.
                    continue;
                }
                renderedComponentIds[cell.component.renderId] = true;
                
                td = tdPrototype.cloneNode(false);
                
                if (cell.xSpan > 1) {
                    td.setAttribute(xSpan, cell.xSpan);
                }
                if (cell.ySpan > 1) {
                    td.setAttribute(ySpan, cell.ySpan);
                }
                
                var layoutData = cell.component.render("layoutData");
                if (layoutData) {
                    var columnWidth = gridProcessor.xExtents[columnIndex];
                    if (Core.Web.Env.QUIRK_TABLE_CELL_WIDTH_EXCLUDES_PADDING && columnWidth && 
                            !Echo.Sync.Extent.isPercent(columnWidth)) { 
                        var cellInsets = Echo.Sync.Insets.toPixels(layoutData.insets);
                        if (defaultPixelInsets.left + defaultPixelInsets.right < cellInsets.left + cellInsets.right) {
                            td.style.width = (Echo.Sync.Extent.toPixels(columnWidth) - 
                                    (cellInsets.left + cellInsets.right)) + "px";
                        }
                    }
                    Echo.Sync.Insets.render(layoutData.insets, td, "padding");
                    Echo.Sync.Alignment.render(layoutData.alignment, td, true, this.component);
                    Echo.Sync.FillImage.render(layoutData.backgroundImage, td);
                    Echo.Sync.Color.render(layoutData.background, td, "backgroundColor");
                }
                
                Echo.Render.renderComponentAdd(update, cell.component, td);
    
                tr.appendChild(td);
            }
        }
        
        parentElement.appendChild(this._table);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        if (this._renderPercentWidthByMeasure) {
            this._table.style.width = "";
            var tableParent = this._table.parentNode;
            var availableWidth = tableParent.offsetWidth;
            if (tableParent.style.paddingLeft) {
                availableWidth -= parseInt(tableParent.style.paddingLeft, 10);
            }
            if (tableParent.style.paddingRight) {
                availableWidth -= parseInt(tableParent.style.paddingRight, 10);
            }
            var width = ((availableWidth * this._renderPercentWidthByMeasure) / 100) - Core.Web.Measure.SCROLL_WIDTH;
            if (width > 0) {
                this._table.style.width = width + "px";
            }
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this._table);
        this._table = null;
        this._renderPercentWidthByMeasure = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._table;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});
/**
 * Abstract base class for rendering SELECT-element based list components.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.ListComponent = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /** 
         * Alternate rendering: default border style.
         * @type #Border
         */
        DEFAULT_DIV_BORDER: "1px solid #7f7f7f",
        
        /** 
         * Alternate rendering: default selected item background.
         * @type #Color
         */
        DEFAULT_SELECTED_BACKGROUND: "#0a246a",
        
        /** 
         * Alternate rendering: default selected item foreground.
         * @type #Color
         */
        DEFAULT_SELECTED_FOREGROUND: "#ffffff"
    },

    $abstract: {
        
        /**
         * Flag indicating whether the component should be rendered as a list box (true) or select field (false).
         * @type Boolean
         */
        listBox: null
    },
    
    /**
     * Flag indicating that one or more of the items in the list component has been rendered with a selected appearance.
     * @type Boolean
     */
    _hasRenderedSelectedItems: false,
    
    /**
     * Flag indicating whether multiple selection is allowed (for listboxes).
     * @type Boolean
     */
    _multipleSelect: false,
    
    /**
     * Flag indicating that selection should be determined based on "selectedId"
     * property rather than "selection" property.  This flag is enabled when
     * "selectedId" is updated and disabled when an item is selected by the user.
     * @type Boolean
     */
    _selectedIdPriority: false,

    /**
     * Flag indicating that component will be rendered as a DHTML-based ListBox.
     * This form of rendering is necessary on Internet Explorer 6 browsers due to unstable
     * code in this web browser when using listbox-style SELECT elements.
     * @type Boolean
     */
    _alternateRender: false,
    
    /**
     * The "main" element upon which contains items and upon which listeners are registered.  
     * For normal rendering, this is the SELECT, which directly contains individual OPTION elements.
     * For the alternate rendering, this is the TABLE, whose TBODY element contains individual
     * TR elements that represent options.
     * @type Element
     */
    _element: null,
    
    /**
     * Rendered DIV element when alternate listbox rendering is enabled.
     * Null if list is rendered as a SELECT element.
     * @type Element.
     */
    _div: null,
    
    /**
     * Rendered focus state of component, based on received DOM focus/blur events.
     * @type Boolean
     */
    _focused: false,
    
    /**
     * Determines current selection state.
     * By default, the value of the "selection" property of the component is returned.
     * If the _selectedIdPriorirty flag is set, or if the "selection" property has no value,
     * then selection is determined based on the "selectedId" property of the component.
     * 
     * @return the selection, either an integer index or array of indices
     */
    _getSelection: function() {
        // Retrieve selection from "selection" property.
        var selection = this._selectedIdPriority ? null : this.component.get("selection");
        
        if (selection == null) {
            // If selection is now in "selection" property, query "selectedId" property.
            var selectedId = this.component.get("selectedId");

            if (selectedId) {
                // If selectedId property is set, find item with corresponding id.
                var items = this.component.get("items");

                for (var i = 0; i < items.length; ++i) {
                    if (items[i].id == selectedId) {
                        selection = i;
                        break;
                    }
                }
            }
            
            // If selection is null (selectedId not set, or corresponding item not found),
            // set selection to null/default value.
            if (selection == null) {
                selection = this.listBox ? [] : 0;
            }
        }
        
        return selection;
    },
    
    /** Processes a focus blur event */
    _processBlur: function(e) {
        this._focused = false;
    },
    
    /**
     * Processes a click event.
     * This event handler is registered only in the case of the "alternate" DHTML-based rendered
     * listbox for IE6, i.e., the _alternateRender flag will be true. 
     */
    _processClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            this._renderSelection();
            return true;
        }
        
        var child = this._div.firstChild;
        var i = 0;
        while (child) {
            if (child == e.target) {
                break;
            }
            child = child.nextSibling;
            ++i;
        }
        if (child == null) {
            return;
        }
        
        if (this._multipleSelect && e.ctrlKey) {
            // Multiple selection and user has pressed ctrl key to select multiple items.
            var selection = this._getSelection();
            if (selection == null) {
                selection = [];
            } else if (typeof (selection) == "number") {
                selection = [selection];
            }
            var arrayIndex = Core.Arrays.indexOf(selection, i); 
            if (arrayIndex == -1) {
                // Add item to selection if not present.
                selection.push(i);
            } else {
                // Remove item from selection if already present.
                selection.splice(arrayIndex, 1);
            }
        } else {
            selection = i;
        }
        
        this._setSelection(selection);
        this.component.doAction();
        this._renderSelection();
    },
    
    /**
     * Processes a selection change event.
     * This event handler is registered only for traditional SELECT elements, i.e., the _alternateRender flag will be false.
     */
    _processChange: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            this._renderSelection();
            return false;
        }
        
        var selection;
        if (this._multipleSelect) {
            selection = [];
            for (var i = 0; i < this._element.options.length; ++i) {
                if (this._element.options[i].selected) {
                    selection.push(i);
                }
            }
        } else {
            if (this._element.selectedIndex != -1) {
                selection = this._element.selectedIndex;
            }
        }
    
        this._setSelection(selection);
        this.component.doAction();
    },
    
    /** Processes a focus event */
    _processFocus: function(e) {
        this._focused = true;
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this.client.application.setFocusedComponent(this.component);
    },
    
    /** IE-specific event handler to prevent mouse-selection of text in DOM-rendered listbox component. */
    _processSelectStart: function(e) {
        Core.Web.DOM.preventEventDefault(e);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._multipleSelect = this.component.get("selectionMode") == Echo.ListBox.MULTIPLE_SELECTION;
        if (this.listBox && Core.Web.Env.QUIRK_IE_SELECT_LIST_DOM_UPDATE) {
            this._alternateRender = true;
        }
        this._enabled = this.component.isRenderEnabled();
        
        if (this._alternateRender) {
            this._renderMainAsDiv(update, parentElement);
        } else {
            this._renderMainAsSelect(update, parentElement);
        }
    },

    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        this._renderSelection();
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) { 
        Core.Web.Event.removeAll(this._element);
        this._element = null;
        if (this._div) {
            Core.Web.Event.removeAll(this._div);
            this._div = null;
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        if (this._focused) {
            return;
        }
        
        this._focused = true;
        Core.Web.DOM.focusElement(this._element);
    },
    
    /**
     * Renders a list box as a DIV element containing DIV elements of selectable items.
     * This strategy is used on IE6 due to bugs in this browser's rendering engine.
     * This strategy is used when the _alternateRender flag is true.
     * 
     * @param {Echo.Update.ComponentUpdate} update the update
     * @param {Element} parent the parent DOM element 
     */
    _renderMainAsDiv: function(update, parentElement) {
        this._element = document.createElement("table");
        this._element.id = this.component.renderId;
        
        var tbodyElement = document.createElement("tbody");
        this._element.appendChild(tbodyElement);
        var trElement = document.createElement("tr");
        tbodyElement.appendChild(trElement);
        var tdElement = document.createElement("td");
        trElement.appendChild(tdElement);
        
        this._div = document.createElement("div");
        tdElement.appendChild(this._div);
        
        this._div.style.cssText = "cursor:default;overflow:auto;";
        this._div.style.height = Echo.Sync.Extent.toCssValue(this.component.render("height", "6em"), false, false);
        var width = this.component.render("width");
        if (!Echo.Sync.Extent.isPercent(width)) {
            this._div.style.width = Echo.Sync.Extent.toCssValue(width, true, false);
        }
        if (this._enabled) {
            Echo.Sync.renderComponentDefaults(this.component, this._element);
        } else {
            Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this._element);
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "foreground", "disabledForeground", true), 
                    this._div, "color");
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "background", "disabledBackground", true), 
                    this._div, "backgroundColor");
            Echo.Sync.Font.render(Echo.Sync.getEffectProperty(this.component, "font", "disabledFont", true), this._div);
        }
        Echo.Sync.Border.render(
                Echo.Sync.getEffectProperty(this.component, "border", "disabledBorder", !this._enabled, 
                Echo.Sync.ListComponent.DEFAULT_DIV_BORDER, null), 
                this._div);
        Echo.Sync.Insets.render(this.component.render("insets"), this._div, "padding");

        var items = this.component.get("items");
        if (items) {
            for (var i = 0; i < items.length; ++i) {
                var optionElement = document.createElement("div");
                if (items[i].text) {
                    optionElement.appendChild(document.createTextNode(items[i].text));
                } else {
                    optionElement.appendChild(document.createTextNode(items[i].toString()));
                }
                if (items[i].foreground) {
                    Echo.Sync.Color.render(items[i].foreground, optionElement, "color");
                }
                if (items[i].background) {
                    Echo.Sync.Color.render(items[i].background, optionElement, "backgroundColor");
                }
                if (items[i].font) {
                    Echo.Sync.Font.render(items[i].font, optionElement);
                }
                this._div.appendChild(optionElement);
            }
        }
        
        if (this._enabled) {
            Core.Web.Event.add(this._element, "blur", Core.method(this, this._processBlur), false);
            Core.Web.Event.add(this._element, "focus", Core.method(this, this._processFocus), false);
            Core.Web.Event.add(this._div, "click", Core.method(this, this._processClick), false);
            Core.Web.Event.add(this._div, "selectstart", Core.method(this, this._processSelectStart), false);
        }
        
        parentElement.appendChild(this._element);
    },
    
    /**
     * Renders the list selection component as a standard SELECT element.
     * This strategy is always used in all browsers except IE6, and is used in IE6
     * for drop-down select fields.  IE6 cannot use this strategy for listboxes
     * do to major bugs in this browser (listboxes randomly change back into selectfields
     * when rendered by DOM manipulation).
     * This strategy is used when the _alternateRender flag is false.
     * 
     * @param {Echo.Update.ComponentUpdate} update the update
     * @param {Element} parent the parent DOM element 
     */
    _renderMainAsSelect: function(update, parentElement) {
        this._div = document.createElement("div");
    
        this._element = document.createElement("select");
        this._element.id = this.component.renderId;
        this._element.size = this.listBox ? 6 : 1;

        if (!this._enabled) {
            this._element.disabled = true;
        }
        if (this._multipleSelect) {
            this._element.multiple = "multiple";
        }

        this._element.style.height = Echo.Sync.Extent.toCssValue(this.component.render("height"), false, false);
        
        var width = this.component.render("width");
        if (width) {
            if (Echo.Sync.Extent.isPercent(width)) {
                if (!Core.Web.Env.QUIRK_IE_SELECT_PERCENT_WIDTH) {
                    this._div.style.width = width;
                    this._element.style.width = "100%";
                }
            } else {
                this._element.style.width = Echo.Sync.Extent.toCssValue(width, true, false);
            }
        }
        if (this._enabled) {
            Echo.Sync.renderComponentDefaults(this.component, this._element);
        } else {
            Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this._element);
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "foreground", "disabledForeground", true), 
                    this._element, "color");
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "background", "disabledBackground", true), 
                    this._element, "backgroundColor");
            Echo.Sync.Font.render(Echo.Sync.getEffectProperty(this.component, "font", "disabledFont", true),this._element);
        }
        Echo.Sync.Border.render(Echo.Sync.getEffectProperty(this.component, "border", "disabledBorder", !this._enabled), 
                this._element);
        Echo.Sync.Insets.render(this.component.render("insets"), this._element, "padding");

        var items = this.component.get("items");
        if (items) {
            for (var i = 0; i < items.length; ++i) {
                var optionElement = document.createElement("option");
                if (items[i].text == null) {
                    optionElement.appendChild(document.createTextNode(items[i].toString()));
                } else {
                    optionElement.appendChild(document.createTextNode(items[i].text));
                }
                if (items[i].foreground) {
                    Echo.Sync.Color.render(items[i].foreground, optionElement, "color");
                }
                if (items[i].background) {
                    Echo.Sync.Color.render(items[i].background, optionElement, "backgroundColor");
                }
                if (items[i].font) {
                    Echo.Sync.Font.render(items[i].font, optionElement);
                }
                this._element.appendChild(optionElement);
            }
        }
    
        if (this._enabled) {
            Core.Web.Event.add(this._element, "change", Core.method(this, this._processChange), false);
            Core.Web.Event.add(this._element, "blur", Core.method(this, this._processBlur), false);
            Core.Web.Event.add(this._element, "focus", Core.method(this, this._processFocus), false);
        }

        this._div.appendChild(this._element);

        parentElement.appendChild(this._div);
    },

    /**
     * Renders the current selection state.
     */
    _renderSelection: function() {
        var selection = this._getSelection(),
            i;
        
        if (this._alternateRender) {
            if (this._hasRenderedSelectedItems) {
                var items = this.component.get("items");
                for (i = 0; i < items.length; ++i) {
                    Echo.Sync.Color.renderClear(items[i].foreground, this._div.childNodes[i], 
                            "color");
                    Echo.Sync.Color.renderClear(items[i].background, this._div.childNodes[i], 
                            "backgroundColor");
                }
            }
            if (selection instanceof Array) {
                for (i = 0; i < selection.length; ++i) {
                    if (selection[i] >= 0 && selection[i] < this._div.childNodes.length) {
                        Echo.Sync.Color.render(Echo.Sync.ListComponent.DEFAULT_SELECTED_FOREGROUND,
                                this._div.childNodes[selection[i]], "color");
                        Echo.Sync.Color.render(Echo.Sync.ListComponent.DEFAULT_SELECTED_BACKGROUND,
                                this._div.childNodes[selection[i]], "backgroundColor");
                    }
                }
            } else if (selection >= 0 && selection < this._div.childNodes.length) {
                Echo.Sync.Color.render(Echo.Sync.ListComponent.DEFAULT_SELECTED_FOREGROUND,
                        this._div.childNodes[selection], "color");
                Echo.Sync.Color.render(Echo.Sync.ListComponent.DEFAULT_SELECTED_BACKGROUND,
                        this._div.childNodes[selection], "backgroundColor");
            }
        } else {
            if (this._hasRenderedSelectedItems) {
                this._element.selectedIndex = -1;
            }
            if (selection instanceof Array) {
                for (i = 0; i < selection.length; ++i) {
                    if (selection[i] >= 0 && selection[i] < this._element.options.length) {
                        this._element.options[selection[i]].selected = true;
                    }
                }
            } else if (selection >= 0 && selection < this._element.options.length) {
                this._element.options[selection].selected = true;
            }
        }
        this._hasRenderedSelectedItems = true;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.getUpdatedProperty("selectedId") && !update.getUpdatedProperty("selection")) {
            this._selectedIdPriority = true;
        }
    
        var element = this._element;
        var containerElement = element.parentNode;
        this.renderDispose(update);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return false; // Child elements not supported: safe to return false.
    },
    
    /**
     * Sets the selection state.
     * Updates values of both "selection" and "selectedId" properties of the component.
     * 
     * @param selection the new selection state, either the selected index or an array of selected indices 
     */
    _setSelection: function(selection) {
        this._selectedIdPriority = false;
    
        var selectedId = null;
        
        if (selection instanceof Array && selection.length == 1) {
            selection = selection[0];
        }
        
        var items = this.component.get("items");
        if (selection instanceof Array) {
            selectedId = [];
            for (var i = 0; i < selection.length; ++i) {
                var selectedIndex = selection[i];
                if (selectedIndex < items.length) {
                    if (items[selectedIndex].id != null) {
                        selectedId.push(items[selectedIndex].id);
                    }
                }
            }
        } else {
            if (selection < items.length) {
                if (items[selection].id != null) {
                    selectedId = items[selection].id;
                }
            }
        }

        this.component.set("selection", selection);
        this.component.set("selectedId", selectedId);
    }
});

/**
 * Component rendering peer: ListBox
 */
Echo.Sync.ListBox = Core.extend(Echo.Sync.ListComponent, {
    
    /** @see Echo.Sync.ListComponent#listBox */
    listBox: true,

    $load: function() {
        Echo.Render.registerPeer("ListBox", this);
    }
});

/**
 * Component rendering peer: SelectField
 */
Echo.Sync.SelectField = Core.extend(Echo.Sync.ListComponent, { 

    /** @see Echo.Sync.ListComponent#listBox */
    listBox: false,

    $load: function() {
        Echo.Render.registerPeer("SelectField", this);
    }
});
/**
 * Component rendering peer: SplitPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.SplitPane = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /**    
         * Describes the configuration of a child pane of the SplitPane,
         * including the child component and scroll bar positions.
         */
        ChildPane: Core.extend({
        
            /** 
             * Minimum pixel size of the child pane.
             * @type Number
             */
            minimumSize: 0,
            
            /** 
             * Maximum pixel size of the child pane.
             * @type Number
             */
            maximumSize: null,
            
            /**
             * The child pane <code>Echo.Component</code> instance.
             * @type Echo.Component
             */
            component: null,
            
            /**
             * The value of the child pane <code>Echo.Component</code>'s <code>layoutData</code> property.
             */
            layoutData: null,
            
            /** 
             * Horizontal scroll position, in pixels.
             * @type Number.
             */
            scrollLeft: 0,

            /** 
             * Vertical scroll position, in pixels.
             * @type Number.
             */
            scrollTop: 0,
            
            /** 
             * Flag indicating that scroll position should be reset on next renderDisplay() invocation.
             * @type Boolean
             */
            scrollRequired: false,
            
            /**
             * Flag indicating whether sizing information is permanent (fixed pixel-based) or variable (percent-based).
             * @type Boolean
             */
            _permanentSizes: false,
            
            /**
             * The SplitPane component rendering peer using this <code>ChildPane</code> object.
             * @type Echo.Sync.SplitPane
             */
            _peer: null,
        
            /**
             * Creates a new PaneConfiguration instance
             * 
             * @param {Echo.Sync.SplitPane} splitPanePeer the relevant componentPeer
             * @param {Echo.Component} component the child component
             */
            $construct: function(splitPanePeer, component) {
                this._peer = splitPanePeer;
                this.component = component;
                this.layoutData = component.render("layoutData");
            },
            
            /**
             * Load minimum and maximum separator positions for panes.
             */
            loadDisplayData: function() {
                if (this._permanentSizes) {
                    // Pane size constraints have been loaded for this ChildPane, and will not ever change
                    // (because they are pixel rather percent-based.
                    return;
                }
                
                var size;
                this._permanentSizes = true;
                if (this.layoutData) {
                    if (this.layoutData.minimumSize) {
                        if (Echo.Sync.Extent.isPercent(this.layoutData.minimumSize)) {
                            size = this._peer._getSize();
                            this.minimumSize = Math.round((this._peer._orientationVertical ? size.height : size.width) *
                                    parseInt(this.layoutData.minimumSize, 10) / 100);
                            this._permanentSizes = false;
                        } else {
                            this.minimumSize = Math.round(Echo.Sync.Extent.toPixels(this.layoutData.minimumSize, 
                                    !this._peer._orientationVertical));
                        }
                    }
                    if (this.layoutData.maximumSize) {
                        if (Echo.Sync.Extent.isPercent(this.layoutData.maximumSize)) {
                            size = this._peer._getSize();
                            this.maximumSize = Math.round((this._peer._orientationVertical ? size.height : size.width) *
                                    parseInt(this.layoutData.maximumSize, 10) / 100);
                            this._permanentSizes = false;
                        } else {
                            this.maximumSize = Math.round(Echo.Sync.Extent.toPixels(this.layoutData.maximumSize, 
                                    !this._peer._orientationVertical));
                        }
                    }
                }
            },
            
            /**
             * Update pane DIV element's scroll positions to reflect those stored in this object.
             *  
             * @param paneDiv the pane's DIV element
             */
            loadScrollPositions: function(paneDiv) {
                paneDiv.scrollLeft = this.scrollLeft;
                paneDiv.scrollTop = this.scrollTop;
            },
            
            /**
             * Retrieve scroll bar positions from pane DIV element and store in this object.
             * 
             * @param paneDiv the pane's DIV element
             */
            storeScrollPositions: function(paneDiv) {
                this.scrollLeft = paneDiv.scrollLeft;
                this.scrollTop = paneDiv.scrollTop;
            }
        })
    },

    $load: function() {
        Echo.Render.registerPeer("SplitPane", this);
    },

    /**
     * Array containing two PaneConfiguration instances, representing the state of each child pane.
     * @type Array
     */
    _childPanes: null,
    
    /**
     * Array containing the elements of the first and second child pane DIVs.  This array always has two elements.
     * @type Array
     */
    _paneDivs: null,
    
    /**
     * The rendered separator DIV element.
     * @type Element
     */
    _separatorDiv: null,
    
    /**
     * Flag indicating whether separator is to be automatically positioned.
     * @type Boolean
     */
    _autoPositioned: false,

    /**
     * Overlay DIV which covers other elements (such as IFRAMEs) when dragging which may otherwise suppress events.
     * @type Element
     */
    _overlay: null,
    
    /**
     * Flag indicating whether the renderDisplay() method must be invoked on this peer 
     * (and descendant component peers).
     * @type Number
     */
    _redisplayRequired: false,
    
    /**
     * The user's desired position of the separator.  This is the last
     * position to which the user dragged the separator or the last position
     * that the separator was explicitly set to.  This value may not be the
     * actual separator position, in cases where other constraints have
     * temporarily adjusted it.
     * This is value is retained such that if constraints are lifted, the 
     * separator position will return to where the user last preferred it.
     * 
     * @type Extent
     */
    _requested: null,
    
    /**
     * Current rendered separator position.
     * @type Number
     */
    _rendered: null,

    /**
     * Method reference to this._processSeparatorMouseMove().
     * @type Function
     */
    _processSeparatorMouseMoveRef: null,

    /**
     * Method reference to this._processSeparatorMouseUp().
     * @type Function
     */
    _processSeparatorMouseUpRef: null,

    /**
     * Flag indicating whether initial automatic sizing operation (which occurs on first invocation of 
     * <code>renderDisplay()</code> after <code>renderAdd()</code>) has been completed.
     * @type Boolean
     */
    _initialAutoSizeComplete: false,
    
    /**
     * The rendered size of the SplitPane outer DIV.  This value is lazily loaded by
     * _getSize(), thus it should always be retrieved by invoking _getSize().
     * This property will be cleared any time the size changes.
     */
    _size: null,

    /** Constructor. */
    $construct: function() {
        this._childPanes = [];
        this._paneDivs = [];
        this._processSeparatorMouseMoveRef = Core.method(this, this._processSeparatorMouseMove);
        this._processSeparatorMouseUpRef = Core.method(this, this._processSeparatorMouseUp);
    },
    
    /** Processes a key press event. */
    clientKeyDown: function(e) {
        var focusPrevious,
            focusedComponent,
            focusFlags,
            focusChild;
        switch (e.keyCode) {
        case 37:
        case 39:
            if (!this._orientationVertical) {
                focusPrevious = (e.keyCode == 37) ^ (!this._orientationTopLeft);
                focusedComponent = this.client.application.getFocusedComponent();
                if (focusedComponent && focusedComponent.peer && focusedComponent.peer.getFocusFlags) {
                    focusFlags = focusedComponent.peer.getFocusFlags();
                    if ((focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_LEFT) || 
                            (!focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_RIGHT)) {
                        focusChild = this.client.application.focusManager.findInParent(this.component, focusPrevious);
                        if (focusChild) {
                            this.client.application.setFocusedComponent(focusChild);
                            Core.Web.DOM.preventEventDefault(e.domEvent);
                            return false;
                        }
                    }
                }
            }
            break;
        case 38:
        case 40:
            if (this._orientationVertical) {
                focusPrevious = (e.keyCode == 38) ^ (!this._orientationTopLeft);
                focusedComponent = this.client.application.getFocusedComponent();
                if (focusedComponent && focusedComponent.peer && focusedComponent.peer.getFocusFlags) {
                    focusFlags = focusedComponent.peer.getFocusFlags();
                    if ((focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_UP) ||
                            (!focusPrevious && focusFlags & Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_DOWN)) {
                        focusChild = this.client.application.focusManager.findInParent(this.component, focusPrevious);
                        if (focusChild) {
                            this.client.application.setFocusedComponent(focusChild);
                            Core.Web.DOM.preventEventDefault(e.domEvent);
                            return false;
                        }
                    }
                }
            }
            break;
        }
        return true;
    }, 
    
    /**
     * Converts a desired separator position into a render-able separator position that
     * complies with the SplitPane's separator bounds (miniumSize and maximumSize of child
     * component layout data).
     * 
     * @param {Number} position requested separator position
     * @return the bounded separator position
     * @type Number
     */
    _getBoundedSeparatorPosition: function(position) {
        if (this._childPanes[1]) {
            var totalSize = this._orientationVertical ? this._getSize().height : this._getSize().width;
            if (position > totalSize - this._childPanes[1].minimumSize - this._separatorSize) {
                position = totalSize - this._childPanes[1].minimumSize - this._separatorSize;
            } else if (this._childPanes[1].maximumSize != null
                    && position < totalSize - this._childPanes[1].maximumSize - this._separatorSize) {
                position = totalSize - this._childPanes[1].maximumSize - this._separatorSize;
            }
        }
        if (this._childPanes[0]) {
            if (position < this._childPanes[0].minimumSize) {
                position = this._childPanes[0].minimumSize;
            } else if (this._childPanes[0].maximumSize != null && position > this._childPanes[0].maximumSize) {
                position = this._childPanes[0].maximumSize;
            }
        }
        return position;
    },
    
    /**
     * Determines the number of pixels of inset margin specified in a layout data object.
     * Horizontal or vertical pixels will be analyzed based on the SplitPane's orientation.
     * The result of this method can be subtracted from the desired height or width of a pane
     * to determine the appropriate value to set for a CSS width/height attribute.
     * 
     * @param {Object} layoutData a component layout data object
     * @return the number of inset pixels
     * @type Number 
     */
    _getInsetsSizeAdjustment: function(position, layoutData) {
        if (!layoutData || layoutData.insets == null) {
            return 0;
        }
        var layoutDataInsets = Echo.Sync.Insets.toPixels(layoutData.insets);
        var adjustment;
        if (this._orientationVertical) {
            adjustment = layoutDataInsets.top + layoutDataInsets.bottom;
        } else {
            adjustment = layoutDataInsets.left + layoutDataInsets.right;
        }
        if (position != null && adjustment > position) {
            adjustment = position;
        }
        return adjustment;
    },
    
    /**
     * Calculates the preferred rendered size of the SplitPane by measuring the sizes of its content and/or
     * invoking getPreferredSize() on its content (if supported).
     * 
     * @see Echo.Render.ComponnetSync#getPreferredSize
     */
    getPreferredSize: function(dimension) {
        if (this.component.children.length === 0) {
            return null;
        }
        
        var bounds, insets, layoutData;
        
        dimension = dimension || (Echo.Render.ComponentSync.SIZE_WIDTH | Echo.Render.ComponentSync.SIZE_HEIGHT);        

        // Determine size of pane 0.
        var size0;
        if (this.component.children[0].peer.getPreferredSize) {
            // Use getPreferredSize() if available.
            size0 = this.component.children[0].peer.getPreferredSize(dimension);
        } else if (!this.component.children[0].pane && (dimension & Echo.Render.ComponentSync.SIZE_HEIGHT) &&
                this._paneDivs[0].firstChild) {
            // Measure height of non-pane child (assuming height is being requested).
            bounds = new Core.Web.Measure.Bounds(this._paneDivs[0].firstChild);
            size0 = { height: bounds.height === 0 ? null : bounds.height };
            if (size0.height) {
                layoutData = this.component.children[0].render("layoutData");
                if (layoutData && layoutData.insets) {
                    insets = Echo.Sync.Insets.toPixels(layoutData.insets);
                    size0.height += insets.top + insets.bottom;
                }
            }
        } else {
            // Pane 0 cannot be measured.
            size0 = { };
        }

        // Determine size of pane 1.
        var size1;
        if (this.component.children.length == 1) {
            // Pane 1 does not exist.
            size1 = { width: 0, height: 0 };
        } else if (this.component.children[1].peer.getPreferredSize) {
            // Use getPreferredSize() if available.
            size1 = this.component.children[1].peer.getPreferredSize(dimension);
        } else if (!this.component.children[1].pane && (dimension & Echo.Render.ComponentSync.SIZE_HEIGHT) &&
                this._paneDivs[1].firstChild) {
            // Measure height of non-pane child (assuming height is being requested).
            bounds = new Core.Web.Measure.Bounds(this._paneDivs[1].firstChild);
            size1 = { height: bounds.height === 0 ? null : bounds.height };
            if (size1.height) {
                layoutData = this.component.children[1].render("layoutData");
                if (layoutData && layoutData.insets) {
                    insets = Echo.Sync.Insets.toPixels(layoutData.insets);
                    size1.height += insets.top + insets.bottom;
                }
            }
        } else {
            // Pane 1 cannot be measured.
            size1 = { };
        }
        
        var height = null;
        if ((dimension & Echo.Render.ComponentSync.SIZE_HEIGHT) && size0.height != null && size1.height != null) {
            if (this._orientationVertical) {
                // Measure height of vertical SplitPane: sum pane heights and separator.
                height = size0.height + size1.height + this._separatorSize;
            } else {
                // Measure height of horizontal SplitPane: use maximum pane height.
                height = size0.height > size1.height ? size0.height : size1.height;
            }
        }
        
        var width = null;
        if ((dimension & Echo.Render.ComponentSync.SIZE_WIDTH) && size0.width != null && size1.width != null) {
            if (this._orientationVertical) {
                // Measure width of vertical SplitPane: use maximum pane width.
                width = size0.width > size1.width ? size0.width : size1.width;
            } else {
                // Measure width of horizontal SplitPane: sum pane widths and separator.
                width = size0.width + size1.width + this._separatorSize;
            }
        }
        
        return { height: height, width: width };
    },
    
    /**
     * Retrieves the (potentially cached) dimensions of the SplitPane outer DIV.
     * 
     * @return the dimensions
     * @type Core.Web.Measure.Bounds
     */
    _getSize: function() {
        if (!this._size) {
            this._size = new Core.Web.Measure.Bounds(this._splitPaneDiv);
        }
        return this._size;
    },
    
    /**
     * Determines if the specified update has caused either child of the SplitPane to
     * be relocated (i.e., a child which existed before continues to exist, but at a
     * different index).
     * 
     * @param {Echo.Update.ComponentUpdate} update the component update
     * @return true if a child has been relocated
     * @type Boolean
     */
    _hasRelocatedChildren: function(update) {
        var oldChild0 = this._childPanes[0] ? this._childPanes[0].component : null; 
        var oldChild1 = this._childPanes[1] ? this._childPanes[1].component : null; 
        var childCount = this.component.getComponentCount();
        var newChild0 = childCount > 0 ? this.component.getComponent(0) : null;
        var newChild1 = childCount > 1 ? this.component.getComponent(1) : null;
        return (oldChild0 != null && oldChild0 == newChild1) || 
                (oldChild1 != null && oldChild1 == newChild0);
    },

    /**
     * Retrieves properties from Echo.SplitPane component instances and
     * stores them in local variables in a format more convenient for processing
     * by this synchronization peer.
     */
    _loadRenderData: function() {
        var orientation = this.component.render("orientation", 
                Echo.SplitPane.ORIENTATION_HORIZONTAL_LEADING_TRAILING);
        
        switch (orientation) {
        case Echo.SplitPane.ORIENTATION_HORIZONTAL_LEADING_TRAILING:
            this._orientationTopLeft = this.component.getRenderLayoutDirection().isLeftToRight();
            this._orientationVertical = false;
            break;
        case Echo.SplitPane.ORIENTATION_HORIZONTAL_TRAILING_LEADING:
            this._orientationTopLeft = !this.component.getRenderLayoutDirection().isLeftToRight();
            this._orientationVertical = false;
            break;
        case Echo.SplitPane.ORIENTATION_HORIZONTAL_LEFT_RIGHT:
            this._orientationTopLeft = true;
            this._orientationVertical = false;
            break;
        case Echo.SplitPane.ORIENTATION_HORIZONTAL_RIGHT_LEFT:
            this._orientationTopLeft = false;
            this._orientationVertical = false;
            break;
        case Echo.SplitPane.ORIENTATION_VERTICAL_TOP_BOTTOM:
            this._orientationTopLeft = true;
            this._orientationVertical = true;
            break;
        case Echo.SplitPane.ORIENTATION_VERTICAL_BOTTOM_TOP:
            this._orientationTopLeft = false;
            this._orientationVertical = true;
            break;
        default:
            throw new Error("Invalid orientation: " + orientation);
        }

        this._resizable = this.component.render("resizable");
        this._autoPositioned = this.component.render("autoPositioned");
        this._requested = this.component.render("separatorPosition");
        
        var defaultSeparatorSize = this._resizable ? Echo.SplitPane.DEFAULT_SEPARATOR_SIZE_RESIZABLE : 
                Echo.SplitPane.DEFAULT_SEPARATOR_SIZE_FIXED;
        var separatorSizeExtent = this.component.render(
                this._orientationVertical ? "separatorHeight" : "separatorWidth", defaultSeparatorSize);
        this._separatorSize = Echo.Sync.Extent.toPixels(separatorSizeExtent, this._orientationVertical);
        if (this._separatorSize == null) {
            this._separatorSize = defaultSeparatorSize;
        }
        this._separatorVisible = this._resizable || (this.component.render("separatorVisible", true) && this._separatorSize > 0);
        if (!this._separatorVisible) {
            this._separatorSize = 0;
        }
        
        if (this._separatorSize > 0) {
            this._separatorColor = this.component.render("separatorColor", Echo.SplitPane.DEFAULT_SEPARATOR_COLOR); 
            this._separatorRolloverColor = this.component.render("separatorRolloverColor") || 
                    Echo.Sync.Color.adjust(this._separatorColor, 0x20, 0x20, 0x20);
            
            this._separatorImage = this.component.render(this._orientationVertical ? 
                    "separatorVerticalImage" : "separatorHorizontalImage");
            this._separatorRolloverImage = this.component.render(this._orientationVertical ? 
                    "separatorVerticalRolloverImage" : "separatorHorizontalRolloverImage");
        }
    },
    
    /**
     * Adds an overlay DIV at maximum z-index to cover any objects that will not provide move mouseup freedback.
     * @see #_overlayRemove
     */ 
    _overlayAdd: function() {
        if (this._overlay) {
            return;
        }
        this._overlay = document.createElement("div");
        this._overlay.style.cssText = "position:absolute;z-index:32600;width:100%;height:100%;";
        Echo.Sync.FillImage.render(this.client.getResourceUrl("Echo", "resource/Transparent.gif"), this._overlay);
        document.body.appendChild(this._overlay);
    },
    
    /**
     * Removes the overlay DIV.
     * @see #_overlayAdd
     */
    _overlayRemove: function() {
        if (!this._overlay) {
            return;
        }
        document.body.removeChild(this._overlay);
        this._overlay = null;
    },
    
    /** Processes a mouse down event on a SplitPane separator that is about to be dragged. */
    _processSeparatorMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
    
        Core.Web.DOM.preventEventDefault(e);
        
        Core.Web.dragInProgress = true;
    
        this._dragInitPosition = this._rendered;
        if (this._orientationVertical) {
            this._dragInitMouseOffset = e.clientY;
        } else {
            this._dragInitMouseOffset = e.clientX;
        }
        
        Core.Web.Event.add(document.body, "mousemove", this._processSeparatorMouseMoveRef, true);
        Core.Web.Event.add(document.body, "mouseup", this._processSeparatorMouseUpRef, true);
        this._overlayAdd();
    },
    
    /** Processes a mouse move event on a SplitPane separator that is being dragged. */
    _processSeparatorMouseMove: function(e) {
        var mousePosition = this._orientationVertical ? e.clientY : e.clientX;
        this._rendered = this._getBoundedSeparatorPosition(this._orientationTopLeft ?
                this._dragInitPosition + mousePosition - this._dragInitMouseOffset :
                this._dragInitPosition - mousePosition + this._dragInitMouseOffset);
        this._redraw(this._rendered);
    },
    
    /** Processes a mouse up event on a SplitPane separator that was being dragged. */
    _processSeparatorMouseUp: function(e) {
        Core.Web.DOM.preventEventDefault(e);
        
        this._overlayRemove();
        Core.Web.dragInProgress = false;
    
        this._removeSeparatorListeners();
        this.component.set("separatorPosition", this._rendered);
        
        // Inform renderer that separator position is currently drawn as this._rendered.
        this._requested = this._rendered;
    
        if (this._paneDivs[0]) {
            Core.Web.VirtualPosition.redraw(this._paneDivs[0]);
        }
        if (this._paneDivs[1]) {
            Core.Web.VirtualPosition.redraw(this._paneDivs[1]);
        }
    
        Echo.Render.notifyResize(this.component);
    },
    
    /** Processes a mouse rollover enter event on the SplitPane separator. */
    _processSeparatorRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        
        if (this._separatorRolloverImage) {
            Echo.Sync.FillImage.render(this._separatorRolloverImage, this._separatorDiv, 0);
        } else {
            Echo.Sync.Color.render(this._separatorRolloverColor, this._separatorDiv, "backgroundColor");
        }
    },
    
    /** Processes a mouse rollover exit event on the SplitPane separator. */
    _processSeparatorRolloverExit: function(e) {
        if (this._separatorRolloverImage) {
            Echo.Sync.FillImage.renderClear(this._separatorImage, this._separatorDiv, 0);
        } else {
            Echo.Sync.Color.render(this._separatorColor, this._separatorDiv, "backgroundColor");
        }
    },
    
    /**
     * Updates the variable CSS attributes of the SplitPane.
     * 
     * @param {Number} position the pixel position of the separator
     */
    _redraw: function(position) {
        var insetsAdjustment = 0;
        if (this.component.getComponentCount() > 0) {
            var layoutData = this.component.getComponent(0).render("layoutData");
            insetsAdjustment = this._getInsetsSizeAdjustment(position, layoutData);
        }

        var sizeAttr = this._orientationVertical ? "height" : "width";
        var positionAttr = this._orientationVertical ?
                (this._orientationTopLeft ? "top" : "bottom") :
                (this._orientationTopLeft ? "left" : "right");
        if (this._paneDivs[0]) {
            this._paneDivs[0].style[sizeAttr] = (position - insetsAdjustment) + "px";
        }
        if (this._paneDivs[1]) {
            this._paneDivs[1].style[positionAttr] =  (position + this._separatorSize) + "px";
        }
        if (this._separatorDiv) {
            this._separatorDiv.style[positionAttr] = position + "px";
        }
    },
    
    /**
     * Removes listeners from the separator used to monitor its state while it is being dragging.
     */
    _removeSeparatorListeners: function() {
        Core.Web.Event.remove(document.body, "mousemove", this._processSeparatorMouseMoveRef, true);
        Core.Web.Event.remove(document.body, "mouseup", this._processSeparatorMouseUpRef, true);
    },
    
    /**
     * Adds basic structure of SplitPane to DOM, but much work is delayed for initial invocation
     * of renderDisplay().
     * @see Echo.Render.ComponentSync#renderAdd
     */
    renderAdd: function(update, parentElement) {
        this._initialAutoSizeComplete = false;
        this._loadRenderData();

        var childCount = this.component.getComponentCount();
        if (childCount > 2) {
            throw new Error("Cannot render SplitPane with more than two child components.");
        }
        var child0 = childCount < 1 ? null : this.component.getComponent(0);
        var child1 = childCount < 2 ? null : this.component.getComponent(1);
    
        this._splitPaneDiv = document.createElement("div");
        this._splitPaneDiv.id = this.component.renderId;
        this._splitPaneDiv.style.cssText = "position:absolute;overflow:hidden;top:0;left:0;right:0;bottom:0;";
        
        Echo.Sync.renderComponentDefaults(this.component, this._splitPaneDiv);
        
        if (this._separatorVisible) {
            this._separatorDiv = document.createElement("div");
            this._separatorDiv.style.cssText = "position:absolute;font-size:1px;line-height:0;z-index:2;";
            Echo.Sync.Color.render(this._separatorColor, this._separatorDiv, "backgroundColor");
    
            var resizeCursor = null;
            if (this._orientationVertical) {
                resizeCursor = this._orientationTopLeft ? "s-resize" : "n-resize";
                this._separatorDiv.style.width = "100%";
                this._separatorDiv.style.height = this._separatorSize + "px";
                Echo.Sync.FillImage.render(this._separatorImage, this._separatorDiv, 0);
            } else {
                resizeCursor = this._orientationTopLeft ? "e-resize" : "w-resize";
                this._separatorDiv.style.height = "100%";
                this._separatorDiv.style.width = this._separatorSize + "px";
                Echo.Sync.FillImage.render(this._separatorImage, this._separatorDiv, 0);
            }
            if (this._resizable && resizeCursor) {
                this._separatorDiv.style.cursor = resizeCursor;
            }
            this._splitPaneDiv.appendChild(this._separatorDiv);
        } else {
            this._separatorDiv = null;
        }
        
        for (var i = 0; i < childCount && i < 2; ++i) {
            var child = this.component.getComponent(i);
            this._renderAddChild(update, child, i);
        }
        
        parentElement.appendChild(this._splitPaneDiv);
        
        if (this._resizable) {
            Core.Web.Event.add(this._separatorDiv, "mousedown", 
                    Core.method(this, this._processSeparatorMouseDown), false);
            Core.Web.Event.add(this._separatorDiv, "mouseover", 
                    Core.method(this, this._processSeparatorRolloverEnter), false);
            Core.Web.Event.add(this._separatorDiv, "mouseout", 
                    Core.method(this, this._processSeparatorRolloverExit), false);
        }
    },
    
    /**
     * Renders the addition of a child.
     * 
     * @param {Echo.Update.ComponentUpdate} update the update
     * @param {Echo.Component} child the added child
     * @param {Number} index the index of the child within the SplitPane 
     */
    _renderAddChild: function(update, child, index) {
        var childIndex = this.component.indexOf(child);
        var paneDiv = document.createElement("div");
        this._paneDivs[index] = paneDiv;
        
        paneDiv.style.cssText = "position: absolute; overflow: auto; z-index: 1;";
        
        var layoutData = child.render("layoutData");
        if (layoutData) {
            Echo.Sync.Alignment.render(layoutData.alignment, paneDiv, false, this.component);
            Echo.Sync.Color.render(layoutData.background, paneDiv, "backgroundColor");
            Echo.Sync.FillImage.render(layoutData.backgroundImage, paneDiv);
            if (!child.pane) {
                Echo.Sync.Insets.render(layoutData.insets, paneDiv, "padding");
                switch (layoutData.overflow) {
                case Echo.SplitPane.OVERFLOW_HIDDEN:
                    paneDiv.style.overflow = "hidden";
                    break;
                case Echo.SplitPane.OVERFLOW_SCROLL:
                    paneDiv.style.overflow = "scroll";
                    break;
                }
            }
        }
        if (child.pane) {
            paneDiv.style.overflow = "hidden";
        }
                
        // Set static CSS positioning attributes on pane DIV.
        if (this._orientationVertical) {
            paneDiv.style.left = 0;
            paneDiv.style.right = 0;
            if ((this._orientationTopLeft && index === 0) || (!this._orientationTopLeft && index == 1)) {
                paneDiv.style.top = 0;
            } else {
                paneDiv.style.bottom = 0;
            }
        } else {
            paneDiv.style.top = "0";
            paneDiv.style.bottom = "0";
            if ((this._orientationTopLeft && index === 0) || (!this._orientationTopLeft && index == 1)) {
                paneDiv.style.left = 0;
            } else {
                paneDiv.style.right = 0;
            }
        }
        
        Echo.Render.renderComponentAdd(update, child, paneDiv);
        this._splitPaneDiv.appendChild(paneDiv);
    
        if (this._childPanes[index] && this._childPanes[index].component == child) {
            this._childPanes[index].scrollRequired = true;
        } else {
            this._childPanes[index] = new Echo.Sync.SplitPane.ChildPane(this, child);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this._splitPaneDiv);
        Core.Web.VirtualPosition.redraw(this._paneDivs[0]);
        Core.Web.VirtualPosition.redraw(this._paneDivs[1]);

        this._size = null;
        
        if (this._childPanes[0]) {
            this._childPanes[0].loadDisplayData();
        }
        if (this._childPanes[1]) {
            this._childPanes[1].loadDisplayData();
        }

        var position = this._requested;
        
        if (position == null && this._autoPositioned && this._paneDivs[0]) {
            // Automatic sizing requested: set separator and pane 1 positions to be adjacent to browser's 
            // rendered size of pane 0.

            if (this.component.children[0].peer.getPreferredSize) {
                // Query child 0 component for preferred size if available.
                var prefSize = this.component.children[0].peer.getPreferredSize(
                        this._orientationVertical ? Echo.Render.ComponentSync.SIZE_HEIGHT : Echo.Render.ComponentSync.SIZE_WIDTH);
                position = prefSize ? (this._orientationVertical ? prefSize.height : prefSize.width) : null;
            }
            
            if (position == null && this._orientationVertical && !this.component.children[0].pane) {
                // Automatically position vertical SplitPane based on height of non-pane child 0.
                this._paneDivs[0].style.height = "";
                var bounds0 = new Core.Web.Measure.Bounds(this._paneDivs[0]);
                position = bounds0.height;
            }

            if (position != null && !this._initialAutoSizeComplete) {
                // If position was successfully set, perform initial operations related to automatic sizing 
                // (executed on first renderDisplay() after renderAdd()).
                this._initialAutoSizeComplete = true;
                var imageListener = Core.method(this, function() {
                    if (this.component) { // Verify component still registered.
                        Echo.Render.renderComponentDisplay(this.component);
                    }
                });
                Core.Web.Image.monitor(this._paneDivs[0], imageListener);
            }
        }

        if (position == null) {
            // Use default separator position if none has been provided at this point.
            position = Echo.SplitPane.DEFAULT_SEPARATOR_POSITION;
        }

        if (Echo.Sync.Extent.isPercent(position)) {
            // Convert percent position to integer value.
            var totalSize = this._orientationVertical ? this._getSize().height : this._getSize().width;
            position = Math.round((parseInt(position, 10) / 100) * totalSize);
        } else {
            // Convert non-percent extent position to integer position.
            position = Math.round(Echo.Sync.Extent.toPixels(position, !this._orientationVertical));
        }
        
        // Constrain position and assign as rendered position.
        this._rendered = this._getBoundedSeparatorPosition(position);
        
        // Redraw dynamic elements of SplitPane.
        this._redraw(this._rendered);
        
        // IE Virtual positioning updates.
        Core.Web.VirtualPosition.redraw(this._paneDivs[0]);
        Core.Web.VirtualPosition.redraw(this._paneDivs[1]);

        // Update scroll bar positions for scenario where pane has been disposed and redrawn.
        for (var i = 0; i < this._childPanes.length; ++i) {
            if (this._childPanes[i] && this._childPanes[i].scrollRequired && this._paneDivs[i]) {
                this._childPanes[i].loadScrollPositions(this._paneDivs[i]);
                this._childPanes[i].scrollRequired = false;
            }
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._overlayRemove();

        for (var i = 0; i < 2; ++i) {
            if (this._paneDivs[i]) {
                if (this._childPanes[i]) {
                    this._childPanes[i].storeScrollPositions(this._paneDivs[i]);
                }
                this._paneDivs[i] = null;
            }
        }
        
        if (this._separatorDiv) {
            Core.Web.Event.removeAll(this._separatorDiv);
            this._separatorDiv = null;
        }

        Core.Web.Event.removeAll(this._splitPaneDiv);
    
        this._splitPaneDiv = null;
    },
    
    /**
     * Renders the removal a single child component.
     * 
     * @param {Echo.Update.ComponentUpdate} update the update
     * @param {Echo.Component} child the removed child
     */
    _renderRemoveChild: function(update, child) {
        var index;
        if (this._childPanes[0] && this._childPanes[0].component == child) {
            index = 0;
        } else if (this._childPanes[1] && this._childPanes[1].component == child) {
            index = 1;
        } else {
            // Do nothing (component was never rendered within the SplitPane).
            return;
        }

        this._childPanes[index] = null;
        
        Core.Web.DOM.removeNode(this._paneDivs[index]);
        this._paneDivs[index] = null;
    },
        
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var fullRender = false,
            i;
        
        if (this._hasRelocatedChildren()) {
            fullRender = true;
        } else if (update.hasUpdatedProperties() || update.hasUpdatedLayoutDataChildren()) {
            if (update.isUpdatedPropertySetIn({ separatorPosition: true })) {
                this._requested = this.component.render("separatorPosition");
            } else {
                fullRender = true;
            }
        }
        
        if (!fullRender && (update.hasAddedChildren() || update.hasRemovedChildren())) {
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                // Remove children.
                for (i = 0; i < removedChildren.length; ++i) {
                    this._renderRemoveChild(update, removedChildren[i]);
                }
            }
            var addedChildren = update.getAddedChildren();
            if (addedChildren) {
                // Add children.
                for (i = 0; i < addedChildren.length; ++i) {
                    this._renderAddChild(update, addedChildren[i], this.component.indexOf(addedChildren[i])); 
                }
            }
        }
        
        if (fullRender) {
            var element = this._splitPaneDiv;
            var containerElement = element.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(element);
            this.renderAdd(update, containerElement);
        }
        
        return fullRender;
    }
});
/**
 * Component rendering peer: TextComponent.
 * This class should not be extended by developers, the implementation is subject to change.
 * 
 * Note that this component has workarounds for issues with percentage-width text fields/areas in various browsers.
 * Percentage widths are reduced based on container size and border width to ensure overall width of component meets
 * user-set percent width specification.  Workaround is also provided for Internet Explorer 6's growing textarea bug. 
 */
Echo.Sync.TextComponent = Core.extend(Echo.Render.ComponentSync, {
    
    $abstract: true,
    
    $virtual: {
        
        getSupportedPartialProperties: function() {
           return ["text", "editable", "selectionStart", "selectionEnd"];
        },
        
        /**
         * Processes a focus blur event.
         * Overriding implementations must invoke.
         */
        processBlur: function(e) {
            this._focused = false;
            this._storeSelection();
            this._storeValue();
            return true;
        },
        
        /**
         * Processes a focus event. Notifies application of focus.
         * Overriding implementations must invoke.
         */
        processFocus: function(e) {
            this._focused = true;
            if (this.client) {
                if (this.component.isActive()) {
                    this.client.application.setFocusedComponent(this.component);
                } else {
                    this._resetFocus();
                }
            }
            return false;
        },
            
        /**
         * Invoked to ensure that input meets requirements of text field.  Default implementation ensures input
         * does not exceed maximum length.
         */
        sanitizeInput: function() {
            var maximumLength = this.component.render("maximumLength", -1);
            if (maximumLength >= 0) {
                if (this.input.value && this.input.value.length > maximumLength) {
                    this.input.value = this.input.value.substring(0, maximumLength);
                }
            }
        }
    },
    
    /**
     * The rendered "input" element (may be a textarea).
     * @type Element
     */
    input: null,
    
    /**
     * Container element which wraps the input element.
     * This element is only rendered for text areas, to mitigate IE "growing" text area bug.
     * @type Element
     */
    container: null,
    
    /**
     * Actual focus state of component, based on received DOM focus/blur events.
     * @type Boolean
     */
    _focused: false,
    
    /**
     * The last processed value of the text field, i.e., the last value of the input field
     * that was stored in the component hierarchy.  When input is provided while restrictions
     * are in place, this value is not updated.
     */
    _lastProcessedValue: null,
    
    /**
     * Flag indicating whether width has been set as a percentage.
     * @type Boolean
     */
    percentWidth: false,
    
    /**
     * First index of cursor selection.
     * @type Nunber
     */
    _selectionStart: 0,
    
    /**
     * Last index of cursor selection.
     * @type Nunber
     */
    _selectionEnd: 0,
    
    /**
     * Renders style information: colors, borders, font, insets, etc.
     * Sets percentWidth flag.
     */
    _renderStyle: function() {
        if (this.component.isRenderEnabled()) {
            Echo.Sync.renderComponentDefaults(this.component, this.input);
            Echo.Sync.Border.render(this.component.render("border"), this.input);
            Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this.input);
        } else {
            Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this.input);
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "foreground", "disabledForeground", true), 
                    this.input, "color");
            Echo.Sync.Color.render(Echo.Sync.getEffectProperty(this.component, "background", "disabledBackground", true), 
                    this.input, "backgroundColor");
            Echo.Sync.Border.render(Echo.Sync.getEffectProperty(this.component, "border", "disabledBorder", true), 
                    this.input);
            Echo.Sync.Font.render(Echo.Sync.getEffectProperty(this.component, "font", "disabledFont", true), 
                    this.input);
            Echo.Sync.FillImage.render(Echo.Sync.getEffectProperty(this.component, 
                    "backgroundImage", "disabledBackgroundImage", true), this.input);
        }
        Echo.Sync.Alignment.render(this.component.render("alignment"), this.input, false, null);
        Echo.Sync.Insets.render(this.component.render("insets"), this.input, "padding");
        var width = this.component.render("width");
        this.percentWidth = Echo.Sync.Extent.isPercent(width);
        if (width) {
            if (this.percentWidth) {
                // Set width very small temporarily, renderDisplay will correct.
                this.input.style.width = "5px";
            } else {
                this.input.style.width = Echo.Sync.Extent.toCssValue(width, true);
            }
        }
        var height = this.component.render("height");
        if (height) {
            this.input.style.height = Echo.Sync.Extent.toCssValue(height, false);
        }
        var toolTipText = this.component.render("toolTipText");
        if (toolTipText) {
            this.input.title = toolTipText;
        }
    },
    
    /**
     * Registers event handlers on the text component.
     */
    _addEventHandlers: function() {
        Core.Web.Event.add(this.input, "keydown", Core.method(this, this._processKeyDown), false);
        Core.Web.Event.add(this.input, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.add(this.input, "focus", Core.method(this, this.processFocus), false);
        Core.Web.Event.add(this.input, "blur", Core.method(this, this.processBlur), false);
    },
    
    /**
     * Reduces a percentage width by a number of pixels based on the container size.
     * 
     * @param {Number} percentValue the percent span
     * @param {Number} reducePixels the number of pixels by which the percent span should be reduced
     * @param {Number} containerPixels the size of the container element 
     */
    _adjustPercentWidth: function(percentValue, reducePixels, containerPixels) {
        var value = (100 - (100 * reducePixels / containerPixels)) * percentValue / 100;
        return value > 0 ? value : 0;
    },
    
    /** @see Echo.Render.ComponentSync#clientKeyDown */
    clientKeyDown: function(e) {
        this._storeValue(e);
        if (this.client && this.component.isActive()) {
            if (!this.component.doKeyDown(e.keyCode)) {
                Core.Web.DOM.preventEventDefault(e.domEvent);
            }
        }
        return true;
    },
    
    /** @see Echo.Render.ComponentSync#clientKeyPress */
    clientKeyPress: function(e) {
        this._storeValue(e);
        if (this.client && this.component.isActive()) {
            if (!this.component.doKeyPress(e.keyCode, e.charCode)) {
                Core.Web.DOM.preventEventDefault(e.domEvent);
            }
        }
        return true;
    },
    
    /** @see Echo.Render.ComponentSync#clientKeyUp */
    clientKeyUp: function(e) {
        this._storeSelection();
        this._storeValue(e);
        return true;
    },

    /**
     * Processes a mouse click event. Notifies application of focus.
     */
    _processClick: function(e) {
        if (!this.client || !this.component.isActive()) {
            Core.Web.DOM.preventEventDefault(e);
            return true;
        }
        this.client.application.setFocusedComponent(this.component);
        this._storeSelection();
        return false;
    },

    /**
     * Keydown event handler to suppress input when component is inactive
     * (clientKeyXXX() methods will not be invoked, even though component can potentially be focused).
     * 
     * @param e the event
     */
    _processKeyDown: function(e) {
        if (!this.component.isActive()) {
            Core.Web.DOM.preventEventDefault(e);
        }
        return true;
    },
    
    /**
     * Event listener to process input after client input restrictions have been cleared. 
     */
    _processRestrictionsClear: function() {
        if (!this.client) {
            // Component has been disposed, do nothing.
            return;
        }

        if (!this.client.verifyInput(this.component) || this.input.readOnly) {
            // Client is unwilling to accept input or component has been made read-only:
            // Reset value of text field to text property of component.
            this.input.value = this.component.get("text");
            return;
        }

        // All-clear, store current text value.
        this.component.set("text", this.input.value, true);
    },

    /**
     * Forcibly resets focus.  Creates hidden focusable text field, focuses it, destroys it.  Then invokes
     * Echo.Render.updateFocus() to re-focus correct component.
     */
    _resetFocus: function() {
        var div = document.createElement("div");
        div.style.cssText = "position:absolute;width:0;height:0;overflow:hidden;";
        var input = document.createElement("input");
        input.type = "text";
        div.appendChild(input);
        document.body.appendChild(div);
        input.focus();
        document.body.removeChild(div);
        div = null;
        input = null;
        this.client.forceRedraw();
        Echo.Render.updateFocus(this.client);
    },
    
    /**
     * Adds the input element to its parent in the DOM.
     * Wraps the element in a special container DIV if necessary to appease Internet Explorer's various text field/area bugs,
     * including percent-based text areas inducing scroll bars and the IE6 percentage width "growing" text area bug.
     * 
     * @param parentElement the parent element
     */
    renderAddToParent: function(parentElement) {
        if (Core.Web.Env.ENGINE_MSHTML && this.percentWidth) {
            this.container = document.createElement("div");
            this.container.appendChild(this.input);
            parentElement.appendChild(this.container);
        } else {
            parentElement.appendChild(this.input);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        var width = this.component.render("width");
        if (width && Echo.Sync.Extent.isPercent(width) && this.input.parentNode.offsetWidth) {
            // If width is a percentage, reduce rendered percent width based on measured container size and border width,
            // such that border pixels will not make the component wider than specified percentage.
            var border = this.component.render("border");
            var borderSize = border ? 
                    (Echo.Sync.Border.getPixelSize(border, "left") + Echo.Sync.Border.getPixelSize(border, "right")) : 4;
            var insets = this.component.render("insets");
            if (insets) {
                var insetsPx = Echo.Sync.Insets.toPixels(insets);
                borderSize += insetsPx.left + insetsPx.right;
            }
            
            // Perform fairly ridiculous browser-specific adjustments.
            if (Core.Web.Env.ENGINE_MSHTML) {
                // Add additional 1px for IE.
                borderSize += 1;
                // Add default windows scroll bar width to border size for Internet Explorer browsers.
                if (this.container) {
                    this.container.style.width = this._adjustPercentWidth(100, Core.Web.Measure.SCROLL_WIDTH, 
                            this.input.parentNode.offsetWidth) + "%";
                } else {
                    borderSize += Core.Web.Measure.SCROLL_WIDTH;
                }
            } else if (Core.Web.Env.BROWSER_CHROME && this.input.nodeName.toLowerCase() == "textarea") {
                // Add additional 3px to TEXTAREA elements for Chrome.
                borderSize += 3;
            } else if (Core.Web.Env.BROWSER_SAFARI && this.input.nodeName.toLowerCase() == "input") {
                // Add additional 1px to INPUT elements for Safari.
                borderSize += 1;
            } else if (Core.Web.Env.ENGINE_PRESTO) {
                // Add additional 1px to all for Opera.
                borderSize += 1;
            }
            
            this.input.style.width = this._adjustPercentWidth(parseInt(width, 10), borderSize, 
                    this.input.parentNode.offsetWidth) + "%";
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this.input);
        this._focused = false;
        this.input = null;
        this.container = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        if (this._focused) {
            return;
        }
            
        this._focused = true;
        Core.Web.DOM.focusElement(this.input);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var fullRender = !Core.Arrays.containsAll(this.getSupportedPartialProperties(), update.getUpdatedPropertyNames(), true);
    
        if (fullRender) {
            var element = this.container ? this.container : this.input;
            var containerElement = element.parentNode;
            this.renderDispose(update);
            containerElement.removeChild(element);
            this.renderAdd(update, containerElement);
        } else {
            if (update.hasUpdatedProperties()) {
                var textUpdate = update.getUpdatedProperty("text");
                if (textUpdate) {
                    var newValue = textUpdate.newValue == null ? "" : textUpdate.newValue;
                    if (newValue != this._lastProcessedValue) {
                        this.input.value = newValue;
                        this._lastProcessedValue = newValue;
                    }
                }
                var editableUpdate = update.getUpdatedProperty("editable");
                if (editableUpdate != null) {
                    this.input.readOnly = !editableUpdate.newValue;
                }
            }
        }
        
        return false; // Child elements not supported: safe to return false.
    },

    /**
     * Stores the selection/cursor position within the input field.
     */
    _storeSelection: function() {
        var range, measureRange;
        if (!this.component) {
            return;
        }
        
        if (!Core.Web.Env.NOT_SUPPORTED_INPUT_SELECTION) {
            this._selectionStart = this.input.selectionStart;
            this._selectionEnd = this.input.selectionEnd;
        } else if (Core.Web.Env.PROPRIETARY_IE_RANGE) {
            range = document.selection.createRange();
            if (range.parentElement() != this.input) {
                return;
            }
            measureRange = range.duplicate();
            if (this.input.nodeName.toLowerCase() == "textarea") {
                measureRange.moveToElementText(this.input);
            } else {
                measureRange.expand("textedit");
            }
            measureRange.setEndPoint("EndToEnd", range);
            this._selectionStart = measureRange.text.length - range.text.length;
            this._selectionEnd = this._selectionStart + range.text.length;
        } else {
            return;
        }
        this.component.set("selectionStart", this._selectionStart, true);
        this.component.set("selectionEnd", this._selectionEnd, true);
    },
    
    /**
     * Stores the current value of the input field, if the client will allow it.
     * If the client will not allow it, but the component itself is active, registers
     * a restriction listener to be notified when the client is clear of input restrictions
     * to store the value later.
     * 
     * @param keyEvent the user keyboard event which triggered the value storage request (optional)
     */
    _storeValue: function(keyEvent) {
        if (!this.client || !this.component.isActive()) {
            if (keyEvent) {
                // Prevent input.
                Core.Web.DOM.preventEventDefault(keyEvent);
            }
            return;
        }

        this.sanitizeInput();
        
        if (!this.client.verifyInput(this.component)) {
            // Component is willing to receive input, but client is not ready:  
            // Register listener to be notified when client input restrictions have been removed, 
            // but allow the change to be reflected in the text field temporarily.
            this.client.registerRestrictionListener(this.component, Core.method(this, this._processRestrictionsClear)); 
            return;
        }

        // Component and client are ready to receive input, set the component property and/or fire action event.
        this.component.set("text", this.input.value, true);
        this._lastProcessedValue = this.input.value;
        
        if (keyEvent && keyEvent.keyCode == 13 && keyEvent.type == "keydown") {
            this.component.doAction();
        }
    }
});

/**
 * Component rendering peer: TextArea
 */
Echo.Sync.TextArea = Core.extend(Echo.Sync.TextComponent, {

    $load: function() {
        Echo.Render.registerPeer("TextArea", this);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.input = document.createElement("textarea");
        this.input.id = this.component.renderId;
        if (!this.component.render("editable", true)) {
            this.input.readOnly = true;
        }
        this._renderStyle(this.input);
        this.input.style.overflow = "auto";
        this._addEventHandlers(this.input);
        if (this.component.get("text")) {
            this.input.value = this.component.get("text");
        }
        this.renderAddToParent(parentElement);
    }
});

/**
 * Component rendering peer: TextField
 */
Echo.Sync.TextField = Core.extend(Echo.Sync.TextComponent, {
    
    $load: function() {
        Echo.Render.registerPeer("TextField", this);
    },
    
    $virtual: {
        
        /** 
         * Input element type, either "text" or "password"
         * @type String 
         */
        _type: "text"
    },

    /** @see Echo.Render.ComponentSync#getFocusFlags */
    getFocusFlags: function() {
        return Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_UP | Echo.Render.ComponentSync.FOCUS_PERMIT_ARROW_DOWN;
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.input = document.createElement("input");
        this.input.id = this.component.renderId;
        if (!this.component.render("editable", true)) {
            this.input.readOnly = true;
        }
        this.input.type = this._type;
        var maximumLength = this.component.render("maximumLength", -1);
        if (maximumLength >= 0) {
            this.input.maxLength = maximumLength;
        }
        this._renderStyle(this.input);
        this._addEventHandlers(this.input);
        if (this.component.get("text")) {
            this.input.value = this.component.get("text");
        }
        
        this.renderAddToParent(parentElement);
    },

    /**
     * Allows all input.
     * @see Echo.Sync.TextComponent#sanitizeInput
     */
    sanitizeInput: function() {
        // allow all input
    }
});

/**
 * Component rendering peer: PasswordField
 */
Echo.Sync.PasswordField = Core.extend(Echo.Sync.TextField, {
    
    $load: function() {
        Echo.Render.registerPeer("PasswordField", this);
    },
    
    /** @see Echo.Sync.TextField#_type */
    _type: "password"
});
/**
 * Component rendering peer: ToggleButton.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.ToggleButton = Core.extend(Echo.Sync.Button, {
    
    $load: function() {
        Echo.Render.registerPeer("ToggleButton", this);
    },
    
    $abstract: {
        
        /** The type setting for the input form element (i.e. "radio" or "checkbox"). */
        inputType: null
    },
    
    /** 
     * Selection state.
     * @type Boolean
     */
    _selected: false,
    
    /**
     * The DOM element which represents the button's state.
     * 
     * @type Element
     */
    _stateElement: null,
    
    /** @see Echo.Sync.Button#doAction */
    doAction: function() {
        this.setSelected(!this._selected);
        Echo.Sync.Button.prototype.doAction.call(this);
    },
    
    /** 
     * Returns the appropriate state icon for the given state of the control (based on disabled and selected state).
     * 
     * @param {Boolean} rollover flag indicating whether the rollover icon should be retrieved
     * @param {Boolean} pressed flag indicating whether the pressed icon should be retrieved
     * @return the state icon
     * @type #ImageReference
     */
    getStateIcon: function(rollover, pressed) {
        var icon;
        if (this._selected) {
            icon = Echo.Sync.getEffectProperty(this.component, "selectedStateIcon", "disabledSelectedStateIcon", !this.enabled);
            if (icon) {
                if (pressed) {
                    icon = this.component.render("pressedSelectedStateIcon", icon); 
                } else if (rollover) {
                    icon = this.component.render("rolloverSelectedStateIcon", icon);
                }
            }
        }
        if (!icon) {
            icon = Echo.Sync.getEffectProperty(this.component, "stateIcon", "disabledStateIcon", !this.enabled);
            if (icon) {
                if (pressed) {
                    icon = this.component.render("pressedStateIcon", icon); 
                } else if (rollover) {
                    icon = this.component.render("rolloverStateIcon", icon);
                }
            }
        }
        return icon;
    },
    
    /** Processes a change event from the state INPUT element (checkbox/radio form control itself). */
    _processStateChange: function(e) {
        this._updateStateElement();
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._selected = this.component.render("selected");
        
        Echo.Sync.Button.prototype.renderAdd.call(this, update, parentElement);
    },
    
    /** @see Echo.Sync.Button.renderContent */
    renderContent: function() {
        var text = this.component.render("text");
        var icon = this.component.render("icon");
        var orientation, margin, tct;
        
        var entityCount = (text != null ? 1 : 0) + (icon ? 1 : 0) + 1; // +1 for state element.
        if (entityCount == 1) {
            if (text != null) {
                this.renderButtonText(this.div, text);
            } else if (icon) {
                this.iconImg = this.renderButtonIcon(this.div, icon);
            } else {
                this._stateElement = this._renderButtonState(this.div);
            }
        } else if (entityCount == 2) {
            orientation = Echo.Sync.TriCellTable.getInvertedOrientation(this.component, "statePosition", "leading");
            margin = this.component.render("stateMargin", Echo.Sync.Button._defaultIconTextMargin);
            tct = new Echo.Sync.TriCellTable(orientation, Echo.Sync.Extent.toPixels(margin));
            if (text != null) {
                this.renderButtonText(tct.tdElements[0], text);
                if (icon) {
                    this.iconImg = this.renderButtonIcon(tct.tdElements[1], icon);
                } else {
                    this._stateElement = this._renderButtonState(tct.tdElements[1]);
                }
            } else {
                this.iconImg = this.renderButtonIcon(tct.tdElements[0], icon);
                this._stateElement = this._renderButtonState(tct.tdElements[1]);
            }
            this.div.appendChild(tct.tableElement);
        } else if (entityCount == 3) {
            orientation = Echo.Sync.TriCellTable.getOrientation(this.component, "textPosition");
            margin = this.component.render("iconTextMargin", Echo.Sync.Button._defaultIconTextMargin);
            var stateOrientation = Echo.Sync.TriCellTable.getInvertedOrientation(this.component, "statePosition", "leading");
            var stateMargin = this.component.render("stateMargin", Echo.Sync.Button._defaultIconTextMargin);
            tct = new Echo.Sync.TriCellTable(orientation, 
                    Echo.Sync.Extent.toPixels(margin), stateOrientation, Echo.Sync.Extent.toPixels(stateMargin));
            this.renderButtonText(tct.tdElements[0], text);
            this.iconImg = this.renderButtonIcon(tct.tdElements[1], icon);
            this._stateElement = this._renderButtonState(tct.tdElements[2]);
            this.div.appendChild(tct.tableElement);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Echo.Sync.Button.prototype.renderDispose.call(this, update);
        if (this._stateElement) {
            Core.Web.Event.removeAll(this._stateElement);
            this._stateElement = null;
        }
    },
    
    /**
     * Renders the state element, appending it to the specified parent.
     *
     * @param {Element} parent the parent DOM element in which the state element should be rendered
     * @return the created state element
     * @type Element
     */
    _renderButtonState: function(parent) {
        var stateIcon = this.getStateIcon();
        var stateElement;
        if (stateIcon) {
            stateElement = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(stateIcon, stateElement);
        } else {
            stateElement = document.createElement("input");
            stateElement.type = this.inputType;
            if (this.inputType == "radio") {
                stateElement.name = "__echo_" + Echo.Sync.RadioButton._nextNameId++;
            }
            stateElement.defaultChecked = this._selected ? true : false;
            Core.Web.Event.add(stateElement, "change", Core.method(this, this._processStateChange), false);
            Core.Web.Event.add(this.div, "click", Core.method(this, this._processStateChange), false);
        }
        parent.appendChild(stateElement);
        var stateAlignment = this.component.render("stateAlignment"); 
        if (stateAlignment) {
            Echo.Sync.Alignment.render(stateAlignment, parent, true, this.component);
        }
        
        return stateElement;
    },

    /** @see Echo.Sync.Button#setPressedState */
    setPressedState: function(pressedState) {
        Echo.Sync.Button.prototype.setPressedState.call(this, pressedState);
        var stateIcon = this.getStateIcon(false, pressedState);
        if (stateIcon) {
            var url = Echo.Sync.ImageReference.getUrl(stateIcon);
            if (this._stateElement.src != url) {
                this._stateElement.src = url;
            }
        }
    },
    
    /** @see Echo.Sync.Button#setRolloverState */
    setRolloverState: function(rolloverState) {
        Echo.Sync.Button.prototype.setRolloverState.call(this, rolloverState);
        var stateIcon = this.getStateIcon(rolloverState, false);
        if (stateIcon) {
            var url = Echo.Sync.ImageReference.getUrl(stateIcon);
            if (this._stateElement.src != url) {
                this._stateElement.src = url;
            }
        }
    },
    
    /**
     * Selects or deselects this button.
     * 
     * @param newState {Boolean} the new selection state
     */
    setSelected: function(newState) {
        if (this._selected == newState) {
            return;
        }
        this._selected = newState;
        this.component.set("selected", newState);
        
        this._updateStateElement();
    },

    /**
     * Updates the image/checked state of the state element in response to the state having changed.
     */
    _updateStateElement: function() {
        var stateIcon = this.getStateIcon();
        if (stateIcon) {
            this._stateElement.src = Echo.Sync.ImageReference.getUrl(stateIcon);
        } else {
            this._stateElement.checked = this._selected ? true : false;
        }
    }
});

/**
 * Component rendering peer: CheckBox
 */
Echo.Sync.CheckBox = Core.extend(Echo.Sync.ToggleButton, {
    
    $load: function() {
        Echo.Render.registerPeer("CheckBox", this);
    },
    
    /** @see Echo.Sync.ToggleButton#inputType */
    inputType: "checkbox"
});

/**
 * Component rendering peer: RadioButton
 */
Echo.Sync.RadioButton = Core.extend(Echo.Sync.ToggleButton, {

    $static: {
    
        /** Next sequentially assigned identifier for radio button groups. */
        _nextNameId: 0,
        
        /**
         * Contains mappings from RadioButton render ids to Echo.Sync.RadioButton.Group objects.
         * 
         * @type Core.Arrays.LargeMap
         */
        _groups: new Core.Arrays.LargeMap()
    },

    $load: function() {
        Echo.Render.registerPeer("RadioButton", this);
    },
    
    /** @see Echo.Sync.ToggleButton#inputType */
    inputType: "radio",
    
    /** 
     * The group to which this radio button belongs.
     * @type Echo.Sync.RadioButton.Group
     */
    _group: null,

    /** @see Echo.Sync.Button#doAction */
    doAction: function() {
        if (this._group) {
            this._group.deselect();
        }
        Echo.Sync.ToggleButton.prototype.doAction.call(this);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        var groupId = this.component.render("group");
        if (groupId != null) {
            var group = Echo.Sync.RadioButton._groups.map[groupId];
            if (!group) {
                group = new Echo.Sync.RadioButton.Group(groupId);
                Echo.Sync.RadioButton._groups.map[groupId] = group;
            }
            group.add(this);
            this._group = group;
        }
        Echo.Sync.ToggleButton.prototype.renderAdd.call(this, update, parentElement);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Echo.Sync.ToggleButton.prototype.renderDispose.call(this, update);
        if (this._group) {
            this._group.remove(this);
            if (this._group.size() === 0) {
                Echo.Sync.RadioButton._groups.remove(this._group.id);
            }
            this._group = null;
        }
    }
});

/**
 * Representation of a collection of radio buttons, only one of which
 * may be selected at a given time.
 */
Echo.Sync.RadioButton.Group = Core.extend({

    /** Group id. */
    id: null,
    
    /** Array of buttons (peers) in this group. */
    _buttons: null,

    /**
     * Creates a RadioButton group.
     * 
     * @param id {String} the id
     */
    $construct: function(id) {
        this.id = id;
        this._buttons = [];
    },
    
    /**
     * Adds the specified button to this button group.
     *
     * @param {Echo.Render.ComponentSync.ToggleButton} button the button
     */
    add: function(button) {
        this._buttons.push(button);
    },
    
    /**
     * Deselects all buttons in this button group.
     */
    deselect: function() {
        for (var i = 0; i < this._buttons.length; ++i) {
            this._buttons[i].setSelected(false);
        }
    },
    
    /**
     * Removes the specified button from this button group.
     * 
     * @param {Echo.Render.ComponentSync.ToggleButton} button the button
     */
    remove: function(button) {
        // Find index of button in array.
        var buttonIndex = -1;
        for (var i = 0; i < this._buttons.length; ++i) {
            if (this._buttons[i] == button) {
                buttonIndex = i;
                break;
            }
        }
        
        if (buttonIndex == -1) {
            // Button does not exist in group.
            throw new Error("No such button: " + button.component.renderId);
        }
        
        if (this._buttons.length == 1) {
            // Array will now be empty.
            this._buttons = [];
        } else {
            // Buttons remain, remove button from button group.
            this._buttons[buttonIndex] = this._buttons[this._buttons.length - 1];
            this._buttons.length = this._buttons.length - 1;
        }
    },

    /**
     * Returns the number of buttons contained by this button group.
     * 
     * @return the number of buttons
     * @type Number
     */
    size: function() {
        return this._buttons.length;
    }
});
/**
 * Component rendering peer: WindowPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Echo.Sync.WindowPane = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /** 
         * Array mapping CSS cursor types to indices of the _borderDivs property.
         * @type Array 
         */
        CURSORS: ["n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize"],
        
        /** Map containing properties whose update can be rendered without replacing component. */
        PARTIAL_PROPERTIES: {background: true, backgroundImage: true, border: true, closable: true, closeIcon: true, 
                closeIconInsets: true, controlsInsets: true, font: true, foreground: true, height: true, icon: true, 
                iconInsets: true, insets: true, maximizeEnabled: true, maximizeIcon: true, maximumHeight: true, 
                maximumWidth: true, minimizeEnabled: true, minimizeIcon: true, minimumHeight: true, 
                minimumWidth: true, movable: true, positionX: true, positionY: true, resizable: true, title: true, 
                titleBackground: true, titleBackgroundImage: true, titleFont: true, 
                titleForeground: true, titleHeight: true, titleInsets: true, width: true },
                
        /** Map containing properties whose update should not result in any rendering. */
        NON_RENDERED_PROPERTIES: { zIndex: true },
                
        /** 
         * Map containing position/size-related properties whose update can be rendered by moving/resizing the window.
         */
        PARTIAL_PROPERTIES_POSITION_SIZE: { positionX: true, positionY: true, width: true, height: true }
    },
    
    $load: function() {
        Echo.Render.registerPeer("WindowPane", this);
    },
    
    /**
     * Flag indicating whether initial automatic sizing operation (which occurs on first invocation of 
     * <code>renderDisplay()</code> after <code>renderAdd()</code>) has been completed.
     * @type Boolean
     */
    _initialAutoSizeComplete: false,

    /**
     * The user-requested bounds of the window.  Contains properties x, y, width, and height.  
     * Property values are extents.  Percentage values are valid.
     */
    _requested: null,
    
    /**
     * Rendered bounds of the window.  Contains properties x, y, width, and height.
     * Property values are integers.  Will differ from user-requested bounds in scenarios where space is not available
     * or user-requested values are otherwise out of range.
     */
    _rendered: null,
    
    /**
     * The rendered bounds of the window immediately prior to the active drag operation.
     */
    _dragInit: null,
    
    /**
     * The X/Y coordinates of the mouse when the active drag operation originated.
     */
    _dragOrigin: null,
    
    /**
     * X/Y directions in which to increment (decrement) size of window when moving mouse.
     * Used in resize operations.
     */ 
    _resizeIncrement: null,
    
    /**
     * The size of the region containing the window.
     * @type Core.Web.Measure.Bounds
     */
    _containerSize: null,

    /**
     * Method reference to <code>_processBorderMouseMove()</code>.
     * @type Function
     */
    _processBorderMouseMoveRef: null,

    /**
     * Method reference to <code>_processBorderMouseUp()</code>.
     * @type Function
     */
    _processBorderMouseUpRef: null,

    /**
     * Method reference to <code>_processTitleBarMouseMove()</code>.
     * @type Function
     */
    _processTitleBarMouseMoveRef: null,

    /**
     * Method reference to <code>_processTitleBarMouseUp()</code>.
     * @type Function
     */
    _processTitleBarMouseUpRef: null,

    /**
     * Array of control icon DOM elements.
     * @type Array
     */
    _controlIcons: null,
    
    /**
     * Overlay DIV which covers other elements (such as IFRAMEs) when dragging which may otherwise suppress events.
     * @type Element
     */
    _overlay: null,

    /**
     * Creates a <code>Echo.Sync.WindowPane<code>.
     */
    $construct: function() {
        this._processBorderMouseMoveRef = Core.method(this, this._processBorderMouseMove);
        this._processBorderMouseUpRef = Core.method(this, this._processBorderMouseUp);
        this._processTitleBarMouseMoveRef = Core.method(this, this._processTitleBarMouseMove);
        this._processTitleBarMouseUpRef = Core.method(this, this._processTitleBarMouseUp);
    },
    
    /**
     * Updates the _requested object based on values from the component object.
     */
    _loadPositionAndSize: function() {
        this._requested = {
            x: this.component.render("positionX", "50%"),
            y: this.component.render("positionY", "50%"),
            contentWidth: this.component.render("contentWidth"),
            contentHeight: this.component.render("contentHeight")
        };
        
        this._requested.width = this.component.render("width", 
                this._requested.contentWidth ? null : Echo.WindowPane.DEFAULT_WIDTH);
        this._requested.height = this.component.render("height");
    },

    /**
     * Determines size of container and stores in this._containerSize property.
     */
    _loadContainerSize: function() {
        this._containerSize = this.component.parent.peer.getSize();
    },
    
    /**
     * Adds an overlay DIV at maximum z-index to cover any objects that will not provide mouseup feedback (e.g., IFRAMEs).
     */
    _overlayAdd: function() {
        if (this._overlay) {
            return;
        }
        this._overlay = document.createElement("div");
        this._overlay.style.cssText = "position:absolute;z-index:32600;width:100%;height:100%;";
        Echo.Sync.FillImage.render(this.client.getResourceUrl("Echo", "resource/Transparent.gif"), this._overlay);
        document.body.appendChild(this._overlay);
    },
    
    /**
     * Removes the overlay DIV.
     */
    _overlayRemove: function() {
        if (!this._overlay) {
            return;
        }
        document.body.removeChild(this._overlay);
        this._overlay = null;
    },
    
    /**
     * Processes a mouse-down event on the window border (resize drag).
     */
    _processBorderMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }

        // Prevent selections.
        Core.Web.dragInProgress = true;
        Core.Web.DOM.preventEventDefault(e);
        this._overlayAdd();
    
        this._loadContainerSize();
        this._dragInit = {
            x: this._rendered.x,
            y: this._rendered.y,
            width: this._rendered.width,
            height: this._rendered.height
        };
        
        this._dragOrigin = { x: e.clientX, y: e.clientY };
        
        switch (e.target) {
        case this._borderDivs[0]: this._resizeIncrement = { x:  0, y: -1 }; break; 
        case this._borderDivs[1]: this._resizeIncrement = { x:  1, y: -1 }; break; 
        case this._borderDivs[2]: this._resizeIncrement = { x:  1, y:  0 }; break; 
        case this._borderDivs[3]: this._resizeIncrement = { x:  1, y:  1 }; break; 
        case this._borderDivs[4]: this._resizeIncrement = { x:  0, y:  1 }; break; 
        case this._borderDivs[5]: this._resizeIncrement = { x: -1, y:  1 }; break; 
        case this._borderDivs[6]: this._resizeIncrement = { x: -1, y:  0 }; break; 
        case this._borderDivs[7]: this._resizeIncrement = { x: -1, y: -1 }; break;
        }
            
        Core.Web.Event.add(document.body, "mousemove", this._processBorderMouseMoveRef, true);
        Core.Web.Event.add(document.body, "mouseup", this._processBorderMouseUpRef, true);
    },
    
    /**
     * Processes a mouse-move event on the window border (resize drag).
     */
    _processBorderMouseMove: function(e) {
        this._setBounds({
            x: this._resizeIncrement.x == -1 ? this._dragInit.x + e.clientX - this._dragOrigin.x : null,
            y: this._resizeIncrement.y == -1 ? this._dragInit.y + e.clientY - this._dragOrigin.y : null,
            width: this._dragInit.width + (this._resizeIncrement.x * (e.clientX - this._dragOrigin.x)),
            height: this._dragInit.height + (this._resizeIncrement.y * (e.clientY - this._dragOrigin.y))
        }, true);
        Echo.Sync.FillImageBorder.renderContainerDisplay(this._div);
    },

    /**
     * Processes a mouse-up event on the window border (resize drag).
     */
    _processBorderMouseUp: function(e) {
        Core.Web.DOM.preventEventDefault(e);
        
        Core.Web.dragInProgress = false;
        this._overlayRemove();
    
        this._removeBorderListeners();
        
        this.component.set("positionX", this._rendered.x);
        this.component.set("positionY", this._rendered.y);
        this.component.set("width", this._rendered.width);
        this.component.set("height", this._rendered.height);
        
        this._requested = {
            x: this._rendered.x,
            y: this._rendered.y,
            width: this._rendered.width,
            height: this._rendered.height
        };
        
        Echo.Sync.FillImageBorder.renderContainerDisplay(this._div);
        Core.Web.VirtualPosition.redraw(this._contentDiv);
        Core.Web.VirtualPosition.redraw(this._maskDiv);
        Echo.Render.notifyResize(this.component);
    },
    
    /**
     * Processes a click event on the window controls (i.e. close/maximize/minimize). 
     */
    _processControlClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        switch (e.registeredTarget._controlData.name) {
        case "close":
            this.component.userClose();
            break;
        case "maximize":
            this.component.userMaximize();
            Echo.Render.processUpdates(this.client);
            break;
        case "minimize":
            this.component.userMinimize();
            break;
        }
    },
    
    /**
     * Processes a mouse rollover enter event on a specific window control button. 
     */
    _processControlRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        Echo.Sync.ImageReference.renderImg(e.registeredTarget._controlData.rolloverIcon, e.registeredTarget.firstChild);
    },
    
    /**
     * Processes a mouse rollover exit event on a specific window control button. 
     */
    _processControlRolloverExit: function(e) {
        Echo.Sync.ImageReference.renderImg(e.registeredTarget._controlData.icon, e.registeredTarget.firstChild);
    },
    
    /**
     * Processes a key down event in the window.
     */
    clientKeyDown: function(e) {
        if (e.keyCode == 27) {
            if (this.component.render("closable", true)) {
                this.component.userClose();
                Core.Web.DOM.preventEventDefault(e.domEvent);
                return false;
            }
        }
        return true;
    },
    
    /**
     * Processes a (captured) focus click within the window region.
     */
    _processFocusClick: function(e) { 
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this.component.parent.peer.raise(this.component);
        return true;
    },
    
    /**
     * Processes a mouse down event on the window title bar (move drag).
     */
    _processTitleBarMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        
        // Ignore mouse down clicks on control icons.
        var target = e.target;
        while (target != e.registeredTarget) {
            if (target._controlData) {
                return;
            }
            target = target.parentNode;
        }
    
        // Raise window.
        this.component.parent.peer.raise(this.component);
        
        // Prevent selections.
        Core.Web.dragInProgress = true;
        Core.Web.DOM.preventEventDefault(e);
        this._overlayAdd();
    
        this._loadContainerSize();
        this._dragInit = { x: this._rendered.x, y: this._rendered.y };
        this._dragOrigin = { x: e.clientX, y: e.clientY };
    
        Core.Web.Event.add(document.body, "mousemove", this._processTitleBarMouseMoveRef, true);
        Core.Web.Event.add(document.body, "mouseup", this._processTitleBarMouseUpRef, true);
    },
    
    /**
     * Processes a mouse move event on the window title bar (move drag).
     */
    _processTitleBarMouseMove: function(e) {
        this._setBounds({
            x: this._dragInit.x + e.clientX - this._dragOrigin.x, 
            y: this._dragInit.y + e.clientY - this._dragOrigin.y
        }, true);
    },
    
    /**
     * Processes a mouse up event on the window title bar (move drag).
     */
    _processTitleBarMouseUp: function(e) {
        Core.Web.dragInProgress = false;
        this._overlayRemove();
    
        this._removeTitleBarListeners();
    
        this.component.set("positionX", this._rendered.x);
        this.component.set("positionY", this._rendered.y);
    
        this._requested.x = this._rendered.x;
        this._requested.y = this._rendered.y;
    },
    
    /**
     * Repositions and resizes the window based on the current bounds specified in this._rendered.
     * Performs no operation if this._rendered does not have width/height data.
     */
    _redraw: function() {
        if (this._rendered.width <= 0 || this._rendered.height <= 0) {
            // Do not render if window does not have set dimensions.
            return;
        }
        
        var borderSideWidth = this._rendered.width - this._borderInsets.left - this._borderInsets.right;
        var borderSideHeight = this._rendered.height - this._borderInsets.top - this._borderInsets.bottom;
    
        this._div.style.left = this._rendered.x + "px";
        this._div.style.top = this._rendered.y + "px";
        this._div.style.width = this._rendered.width + "px";
        this._div.style.height = this._rendered.height + "px";
    
        this._titleBarDiv.style.width = (this._rendered.width - this._contentInsets.left - this._contentInsets.right) + "px";
        
        Echo.Sync.FillImageBorder.renderContainerDisplay(this._div);
        Core.Web.VirtualPosition.redraw(this._contentDiv);
        Core.Web.VirtualPosition.redraw(this._maskDiv);
    },
    
    /**
     * Removes mouseup/mousemove listeners from border.  Invoked after resize drag has completed/on dispose.
     */
    _removeBorderListeners: function() {
        Core.Web.Event.remove(document.body, "mousemove", this._processBorderMouseMoveRef, true);
        Core.Web.Event.remove(document.body, "mouseup", this._processBorderMouseUpRef, true);
    },
    
    /**
     * Removes mouseup/mousemove listeners from title bar.  Invoked after move drag has completed/on dispose.
     */
    _removeTitleBarListeners: function() {
        Core.Web.Event.remove(document.body, "mousemove", this._processTitleBarMouseMoveRef, true);
        Core.Web.Event.remove(document.body, "mouseup", this._processTitleBarMouseUpRef, true);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._initialAutoSizeComplete = false;
        this._rtl = !this.component.getRenderLayoutDirection().isLeftToRight();
        
        // Create content DIV.
        // Content DIV will be appended to main DIV by _renderAddFrame().
        this._contentDiv = document.createElement("div");

        // Render child component, add to content DIV.
        var componentCount = this.component.getComponentCount();
        if (componentCount == 1) {
            Echo.Render.renderComponentAdd(update, this.component.getComponent(0), this._contentDiv);
        } else if (componentCount > 1) {
            throw new Error("Too many children: " + componentCount);
        }
    
        // Render Internet Explorer 6-specific windowed control-blocking IFRAME ("mask DIV").
        // Mask DIV will be added to main DIV by _renderAddFrame().
        if (Core.Web.Env.QUIRK_IE_SELECT_Z_INDEX) {
            // Render Select Field Masking Transparent IFRAME.
            this._maskDiv = document.createElement("div");
            this._maskDiv.style.cssText = 
                    "filter:alpha(opacity=0);z-index:1;position:absolute;left:0,right:0,top:0,bottom:0,borderWidth:0;";
            var maskIFrameElement = document.createElement("iframe");
            maskIFrameElement.style.cssText = "width:100%;height:100%;";
            maskIFrameElement.src = this.client.getResourceUrl("Echo", "resource/Blank.html");
            this._maskDiv.appendChild(maskIFrameElement);
        }
    
        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this._div);
        
        // Render window frame.
        this._renderAddFrame(parentElement);
    },
    
    /**
     * Renders the frame of the window.  Does not alter window content.  This method may be invoked after the window has 
     * initially been rendered to update the window content.
     * _renderDisposeFrame() must be invoked between invocations of _renderAddFrame() to dispose resources.
     * _contentDiv will be appended to rendered DOM structure.
     * 
     * @param {Element} parentElement the parent element to which the rendered frame should be appended 
     */
    _renderAddFrame: function(parentElement) {
        this._loadPositionAndSize();

        // Create main component DIV.
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.tabIndex = "0";

        // Load property states.
        this._minimumWidth = Echo.Sync.Extent.toPixels(
                this.component.render("minimumWidth", Echo.WindowPane.DEFAULT_MINIMUM_WIDTH), true);
        this._minimumHeight = Echo.Sync.Extent.toPixels(
                this.component.render("minimumHeight", Echo.WindowPane.DEFAULT_MINIMUM_HEIGHT), false);
        this._maximumWidth = Echo.Sync.Extent.toPixels(this.component.render("maximumWidth"), true);
        this._maximumHeight = Echo.Sync.Extent.toPixels(this.component.render("maximumHeight"), false);
        this._resizable = this.component.render("resizable", true);
        var border = this.component.render("border", Echo.WindowPane.DEFAULT_BORDER);
        this._borderInsets = Echo.Sync.Insets.toPixels(border.borderInsets);
        this._contentInsets = Echo.Sync.Insets.toPixels(border.contentInsets);
        var movable = this.component.render("movable", true);
        var closable = this.component.render("closable", true);
        var maximizeEnabled = this.component.render("maximizeEnabled", false);
        var minimizeEnabled = this.component.render("minimizeEnabled", false);
        var hasControlIcons = closable || maximizeEnabled || minimizeEnabled;
        var fillImageFlags = this.component.render("ieAlphaRenderBorder") ? Echo.Sync.FillImage.FLAG_ENABLE_IE_PNG_ALPHA_FILTER : 0;
        
        this._div = Echo.Sync.FillImageBorder.renderContainer(border, { absolute: true });
        this._div.style.outlineStyle = "none";
        this._div.style.overflow = "hidden";
        this._div.style.zIndex = 1;
        
        this._borderDivs = Echo.Sync.FillImageBorder.getBorder(this._div);
        var mouseDownHandler = this._resizable ? Core.method(this, this._processBorderMouseDown) : null; 
        for (var i = 0; i < 8; ++i) {
            if (this._borderDivs[i]) {
                if (this._resizable) {
                    this._borderDivs[i].style.zIndex = 2;
                    this._borderDivs[i].style.cursor = Echo.Sync.WindowPane.CURSORS[i];
                    Core.Web.Event.add(this._borderDivs[i], "mousedown", mouseDownHandler, true);
                }
            }
        }
        
        // Render Title Bar
        
        this._titleBarDiv = document.createElement("div");
        this._titleBarDiv.style.position = "absolute";
        this._titleBarDiv.style.zIndex = 3;
        
        var icon = this.component.render("icon");
        if (icon) {
            var titleIconDiv = document.createElement("div");
            titleIconDiv.style[Core.Web.Env.CSS_FLOAT] = this._rtl ? "right" : "left";
            Echo.Sync.Insets.render(this.component.render("iconInsets"), titleIconDiv, "padding");
            this._titleBarDiv.appendChild(titleIconDiv);
            
            var img = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(icon, img);
            titleIconDiv.appendChild(img);
        }
    
        var title = this.component.render("title");
        var titleTextDiv = document.createElement("div");
        if (icon) {
            titleTextDiv.style[Core.Web.Env.CSS_FLOAT] = this._rtl ? "right" : "left";
        }
        titleTextDiv.style.whiteSpace = "nowrap";
        Echo.Sync.Font.render(this.component.render("titleFont"), titleTextDiv);
        Echo.Sync.Insets.render(this.component.render("titleInsets", 
                Echo.WindowPane.DEFAULT_TITLE_INSETS), titleTextDiv, "padding");
        titleTextDiv.appendChild(document.createTextNode(title ? title : "\u00a0"));
        this._titleBarDiv.appendChild(titleTextDiv);
        
        var titleBarHeight = this.component.render("titleHeight");
        if (titleBarHeight) {
            this._titleBarHeight = Echo.Sync.Extent.toPixels(titleBarHeight);
        }
        if (!titleBarHeight) {
            var titleMeasure = new Core.Web.Measure.Bounds(this._titleBarDiv);
            if (titleMeasure.height) {
                this._titleBarHeight = titleMeasure.height;
            } else {
                this._titleBarHeight = Echo.Sync.Extent.toPixels(Echo.WindowPane.DEFAULT_TITLE_HEIGHT);
            }
        }
    
        this._titleBarDiv.style.top = this._contentInsets.top + "px";
        this._titleBarDiv.style.left = this._contentInsets.left + "px";
        this._titleBarDiv.style.height = this._titleBarHeight + "px";
        this._titleBarDiv.style.overflow = "hidden";
        if (movable) {
            this._titleBarDiv.style.cursor = "move";
            Core.Web.Event.add(this._titleBarDiv, "mousedown", Core.method(this, this._processTitleBarMouseDown), true);
        }
    
        Echo.Sync.Color.render(this.component.render("titleForeground"), this._titleBarDiv, "color");
    
        var titleBackground = this.component.render("titleBackground");
        var titleBackgroundImage = this.component.render("titleBackgroundImage");
    
        if (titleBackground) {
            this._titleBarDiv.style.backgroundColor = titleBackground;
        }
        if (titleBackgroundImage) {
            Echo.Sync.FillImage.render(titleBackgroundImage, this._titleBarDiv);
        }
    
        if (!titleBackground && !titleBackgroundImage) {
            this._titleBarDiv.style.backgroundColor = Echo.WindowPane.DEFAULT_TITLE_BACKGROUND;
        }
        
        if (hasControlIcons) {
            this._controlDiv = document.createElement("div");
            this._controlDiv.style.cssText = "position:absolute;top:0;";
            this._controlDiv.style[this._rtl ? "left" : "right"] = 0;
            Echo.Sync.Insets.render(this.component.render("controlsInsets",  
                    Echo.WindowPane.DEFAULT_CONTROLS_INSETS), this._controlDiv, "margin");
            this._titleBarDiv.appendChild(this._controlDiv);

            // Close Button
            if (closable) {
                this._renderControlIcon("close", this.client.getResourceUrl("Echo", "resource/WindowPaneClose.gif"), "[X]");
            }
            if (maximizeEnabled) {
                this._renderControlIcon("maximize", this.client.getResourceUrl("Echo", "resource/WindowPaneMaximize.gif"), "[+]");
            }
            if (minimizeEnabled) {
                this._renderControlIcon("minimize", this.client.getResourceUrl("Echo", "resource/WindowPaneMinimize.gif"), "[-]");
            }
        }
        
        this._div.appendChild(this._titleBarDiv);
        
        // Add content to main DIV.  
        // The object this._contentDiv will have been created by renderAdd(). 
        // Note that overflow is set to 'hidden' if child is a pane component, this is necessary to workaround what
        // what is presumably a bug in Safari 3.0.x.  It should otherwise not be required.
        this._contentDiv.style.cssText = "position:absolute;z-index:2;top:" + 
                (this._contentInsets.top + this._titleBarHeight) + "px;bottom:" + this._contentInsets.bottom + "px;left:" + 
                this._contentInsets.left + "px;right:" + this._contentInsets.right + "px;" +
                "overflow:"+ ((this.component.children.length === 0 || this.component.children[0].pane) ? "hidden;" : "auto;");
        Echo.Sync.Font.renderClear(this.component.render("font"), this._contentDiv);
        if (this.component.children.length > 0 && !this.component.children[0].pane) {
            Echo.Sync.Insets.render(this.component.render("insets"), this._contentDiv, "padding");
        }
                
        Echo.Sync.Color.render(this.component.render("background", Echo.WindowPane.DEFAULT_BACKGROUND),
                this._contentDiv, "backgroundColor");
        Echo.Sync.Color.render(this.component.render("foreground", Echo.WindowPane.DEFAULT_FOREGROUND),
                this._contentDiv, "color");
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this._contentDiv);
        this._div.appendChild(this._contentDiv);

        // Add Internet Explorer 6-specific windowed control-blocking IFRAME.
        if (Core.Web.Env.QUIRK_IE_SELECT_Z_INDEX) {
            this._div.appendChild(this._maskDiv);
        }
        Core.Web.Event.add(this._div, "click", 
                Core.method(this, this._processFocusClick), true);

        // Append main DIV to parent.
        parentElement.appendChild(this._div);
    },

    /**
     * Renders a specific control button icon.
     * 
     * @param {String} name the name of the control icon, used for both event identification and to
     *        retrieve icon property names from component (e.g., a value "close" will cause
     *        "closeIcon" and "closeRolloverIcon" properties of component to be used)
     * @param {#ImageReference} defaultIcon the default icon image to use in the event none is specified
     *        by the component
     * @param {String} altText the alternate text to display if no icon is available (and defaultIcon is null)
     */
    _renderControlIcon: function(name, defaultIcon, altText) {
        var controlDiv = document.createElement("div"),
            icon = this.component.render(name + "Icon", defaultIcon),
            rolloverIcon = this.component.render(name + "RolloverIcon");
 
        var controlSpacing = Echo.Sync.Extent.toCssValue(this.component.render("controlsSpacing", 
                Echo.WindowPane.DEFAULT_CONTROLS_SPACING));
        controlDiv.style.cssText = this._rtl ? ("float:left;cursor:pointer;margin-right:" + controlSpacing) :  
                ("float:right;cursor:pointer;margin-left:" + controlSpacing);
        Echo.Sync.Insets.render(this.component.render(name + "Insets"), controlDiv, "padding");

        if (icon) {
            var img = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(icon, img);
            controlDiv.appendChild(img);
            if (rolloverIcon) {
                Core.Web.Event.add(controlDiv, "mouseover", Core.method(this, this._processControlRolloverEnter), false);
                Core.Web.Event.add(controlDiv, "mouseout", Core.method(this, this._processControlRolloverExit), false);
            }
        } else {
            controlDiv.appendChild(document.createTextNode(altText));
        }
        
        Core.Web.Event.add(controlDiv, "click", Core.method(this, this._processControlClick), false);

        this._controlDiv.appendChild(controlDiv);
        if (this._controlIcons == null) {
            this._controlIcons = [];
        }
        this._controlIcons.push(controlDiv);
        
        controlDiv._controlData = {
            name: name,
            icon: icon,
            rolloverIcon: rolloverIcon
        };
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        this._loadContainerSize();
        this._setBounds(this._requested, false);
        Core.Web.VirtualPosition.redraw(this._contentDiv);
        Core.Web.VirtualPosition.redraw(this._maskDiv);
        
        if (!this._initialAutoSizeComplete) {
            // If position was successfully set, perform initial operations related to automatic sizing 
            // (executed on first renderDisplay() after renderAdd()).
            this._initialAutoSizeComplete = true;
            var imageListener = Core.method(this, function() {
                if (this.component) { // Verify component still registered.
                    Echo.Render.renderComponentDisplay(this.component);
                }
            });
            Core.Web.Image.monitor(this._contentDiv, imageListener);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._overlayRemove();
        this._renderDisposeFrame();
        this._maskDiv = null;
        this._contentDiv = null;
    },
    
    /**
     * Disposes state of rendered window frame.  This method disposes all resources initialized in _renderAddFrame().
     */
    _renderDisposeFrame: function() {
        var i;

        Core.Web.Event.removeAll(this._div);

        for (i = 0; i < 8; ++i) {
            if (this._borderDivs[i]) {
                Core.Web.Event.removeAll(this._borderDivs[i]);
            }
        }
        this._borderDivs = null;
        
        if (this._controlIcons != null) {
            for (i = 0; i < this._controlIcons.length; ++i) {
                Core.Web.Event.removeAll(this._controlIcons[i]);
            }
            this._controlIcons = null;
        }
        
        Core.Web.Event.removeAll(this._titleBarDiv);
        this._titleBarDiv = null;
        
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        Core.Web.DOM.focusElement(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.hasAddedChildren() || update.hasRemovedChildren()) {
            // Children added/removed: perform full render.
        } else if (update.isUpdatedPropertySetIn(Echo.Sync.WindowPane.NON_RENDERED_PROPERTIES)) {
            // Do nothing.
            return false;
        } else if (update.isUpdatedPropertySetIn(Echo.Sync.WindowPane.PARTIAL_PROPERTIES_POSITION_SIZE)) {
            this._loadPositionAndSize();
            return false;
        } else if (update.isUpdatedPropertySetIn(Echo.Sync.WindowPane.PARTIAL_PROPERTIES)) {
            this._renderUpdateFrame();
            return false;
        }

        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    },
    
    /**
     * Renders an update to the window frame.  Disposes existing frame, removes rendered elements, adds new frame.
     */
    _renderUpdateFrame: function() {
        var element = this._div;
        var containerElement = element.parentNode;
        this._renderDisposeFrame();
        containerElement.removeChild(element);
        this._renderAddFrame(containerElement);
    },
    
    /**
     * Sets the bounds of the window.  Constrains the specified bounds to within the available area.
     * If userAdjusting parameter is true, specBounds values must be in pixel values.
     * Invokes _redraw().
     * 
     * @param specBounds an object containing extent properties x, y, width, and height
     * @param {Boolean} userAdjusting flag indicating whether this bounds adjustment is a result of the user moving/resizing
     *        the window (true) or is programmatic (false)
     */
    _setBounds: function(specBounds, userAdjusting) {
        var pxBounds = {}, // Pixel bounds (x/y/width/height as numeric pixel values. 
            calculatedHeight = false; // Flag indicating whether height is calculated or default.
        
        if (userAdjusting) {
            // Constrain user adjustment specBounds coordinate to be an on-screen negative value.
            // if userAdjusting is true, x/y values are guaranteed to be integers.
            if (specBounds.x != null && specBounds.x < 0) {
                specBounds.x = 0;
            }
            if (specBounds.y != null && specBounds.y < 0) {
                specBounds.y = 0;
            }
        }
        
        // Determine pixel width based on specified extent width.
        if (specBounds.width != null) {
            // Determine pixel width based on specified outside width.
            pxBounds.width = Math.round(Echo.Sync.Extent.isPercent(specBounds.width) ?
                    (parseInt(specBounds.width, 10) * this._containerSize.width / 100) :
                    Echo.Sync.Extent.toPixels(specBounds.width, true));
        } else if (specBounds.contentWidth != null) {
            // Determine pixel width based on specified inside (content) width.
            pxBounds.contentWidth = Math.round(Echo.Sync.Extent.isPercent(specBounds.contentWidth) ?
                    (parseInt(specBounds.contentWidth, 10) * this._containerSize.width / 100) :
                    Echo.Sync.Extent.toPixels(specBounds.contentWidth, true));
            pxBounds.width = this._contentInsets.left + this._contentInsets.right + pxBounds.contentWidth;
        }
        
        // Determine pixel height based on specified extent height, or if not specified, calculate height.
        if (specBounds.height != null) {
            // Calculate pixel height based on specified outside height.
            pxBounds.height = Math.round(Echo.Sync.Extent.isPercent(specBounds.height) ?
                    (parseInt(specBounds.height, 10) * this._containerSize.height / 100) :
                    Echo.Sync.Extent.toPixels(specBounds.height, false));
        } else if (specBounds.contentHeight != null) {
            // Calculate pixel height based on specified inside (content) height.
            pxBounds.contentHeight = Math.round(Echo.Sync.Extent.isPercent(specBounds.contentHeight) ?
                    (parseInt(specBounds.contentHeight, 10) * this._containerSize.height / 100) :
                    Echo.Sync.Extent.toPixels(specBounds.contentHeight, false));
            pxBounds.height = this._contentInsets.top + this._contentInsets.bottom + this._titleBarHeight + pxBounds.contentHeight;
        } else if (!userAdjusting) {
            // Set calculated height flag, will be used later for constraints.
            calculatedHeight = true;
            
            // Calculate height based on content size.
            if (this.component.children[0]) {
                // Determine pixel content width.
                var contentWidth = pxBounds.contentWidth ? pxBounds.contentWidth : 
                        pxBounds.width - (this._contentInsets.left + this._contentInsets.right);
                // Cache current content DIV CSS text.
                var contentDivCss = this._contentDiv.style.cssText;
                
                // Use child peer's getPreferredSize() implementation if available.
                if (this.component.children[0].peer.getPreferredSize) {
                    // Set content DIV CSS text for measuring.
                    this._contentDiv.style.cssText = "position:absolute;width:" + contentWidth + 
                            "px;height:" + this._containerSize.height + "px";

                    // Determine size using getPreferredSize()
                    var prefSize = this.component.children[0].peer.getPreferredSize(Echo.Render.ComponentSync.SIZE_HEIGHT);
                    if (prefSize.height) {
                        pxBounds.height = this._contentInsets.top + this._contentInsets.bottom + this._titleBarHeight + 
                                prefSize.height;
                    }
                    
                    // Reset content DIV CSS text.
                    this._contentDiv.style.cssText = contentDivCss;
                }
                
                // If height not yet determined and child is not a pane, measure child height.
                if (!pxBounds.height && !this.component.children[0].pane) {
                    // Configure _contentDiv state for proper measuring of its content height.
                    var insets = Echo.Sync.Insets.toPixels(this.component.render("insets"));
                    this._contentDiv.style.position = "static";
                    this._contentDiv.style.width = (contentWidth - insets.left - insets.right) + "px";
                    this._contentDiv.style.height = "";
                    this._contentDiv.style.padding = "";

                    // Determine size using measurement.
                    var measuredHeight = new Core.Web.Measure.Bounds(this._contentDiv).height;
                    if (measuredHeight) {
                        pxBounds.height = this._contentInsets.top + this._contentInsets.bottom + this._titleBarHeight + 
                                measuredHeight + insets.top + insets.bottom;
                    }

                    // Reset content DIV CSS text.
                    this._contentDiv.style.cssText = contentDivCss;
                }
            }
            
            if (!pxBounds.height) {
                // Height calculation not possible: revert to using default height value.
                pxBounds.height = Echo.Sync.Extent.toPixels(Echo.WindowPane.DEFAULT_HEIGHT, false);            
            }
        }
        
        // Determine x-coordinate of window based on specified x-coordinate.
        if (specBounds.x != null) {
            if (Echo.Sync.Extent.isPercent(specBounds.x)) {
                pxBounds.x = Math.round((this._containerSize.width - pxBounds.width) * (parseInt(specBounds.x, 10) / 100));
                if (pxBounds.x < 0) {
                    // Constain x coordinate if window is too large to fit on-screen.
                    pxBounds.x = 0;
                }
            } else {
                pxBounds.x = Math.round(Echo.Sync.Extent.toPixels(specBounds.x, true));
                if (pxBounds.x < 0) {
                    // Negative value: position window from right side of screen.
                    pxBounds.x += this._containerSize.width - pxBounds.width;
                }
            }
        }

        // Determine y-coordinate of window based on specified y-coordinate.
        if (specBounds.y != null) {
            if (Echo.Sync.Extent.isPercent(specBounds.y)) {
                pxBounds.y = Math.round((this._containerSize.height - pxBounds.height) * (parseInt(specBounds.y, 10) / 100));
                if (pxBounds.y < 0) {
                    // Constain y coordinate if window is too large to fit on-screen.
                    pxBounds.y = 0;
                }
            } else {
                pxBounds.y = Math.round(Echo.Sync.Extent.toPixels(specBounds.y, false));
                if (pxBounds.y < 0) {
                    // Negative value: position window from bottom side of screen
                    pxBounds.y += this._containerSize.height - pxBounds.height;
                }
            }
        }
        
        // Initialize _rendered property if required.
        if (this._rendered == null) {
            this._rendered = { };
        }

        // Constrain width, store value in _rendered property.
        if (pxBounds.width != null) {
            // Constrain to width of region.
            if (this._resizable && pxBounds.width > this._containerSize.width) {
                pxBounds.width = this._containerSize.width;
            }

            // Constrain to maximum width.
            if (this._maximumWidth && pxBounds.width > this._maximumWidth) {
                if (userAdjusting && pxBounds.x != null) {
                    // If user is adjusting the window and x-coordinate is provided, adjust x-coordinate appropriately
                    // as window is being resized using a left-side handle.
                    pxBounds.x += (pxBounds.width - this._maximumWidth);
                }
                pxBounds.width = this._maximumWidth;
            }

            // Constrain to minimum width.
            if (pxBounds.width < this._minimumWidth) {
                if (userAdjusting && pxBounds.x != null) {
                    // If user is adjusting the window and x-coordinate is provided, adjust x-coordinate appropriately
                    // as window is being resized using a left-side handle.
                    pxBounds.x += (pxBounds.width - this._minimumWidth);
                }
                pxBounds.width = this._minimumWidth;
            }

            // Store.
            this._rendered.width = Math.round(pxBounds.width);
        }
        
        // Constrain height, store value in _rendered property.
        if (pxBounds.height != null) {
            // Constrain to height of region.
            if ((calculatedHeight || this._resizable) && pxBounds.height > this._containerSize.height) {
                pxBounds.height = this._containerSize.height;
            }
            
            // Constrain to maximum height.
            if (this._maximumHeight && pxBounds.height > this._maximumHeight) {
                if (userAdjusting && pxBounds.y != null) {
                    // If user is adjusting the window and y-coordinate is provided, adjust y-coordinate appropriately
                    // as window is being resized using a top-side handle.
                    pxBounds.y += (pxBounds.height - this._maximumHeight);
                }
                pxBounds.height = this._maximumHeight;
            }

            // Constrain to minimum height.
            if (pxBounds.height < this._minimumHeight) {
                if (userAdjusting && pxBounds.y != null) {
                    // If user is adjusting the window and y-coordinate is provided, adjust y-coordinate appropriately
                    // as window is being resized using a top-side handle.
                    pxBounds.y += (pxBounds.height - this._minimumHeight);
                }
                pxBounds.height = this._minimumHeight;
            }
            
            // Store.
            this._rendered.height = Math.round(pxBounds.height);
        }
    
        // Constrain x position, store value in _rendered property.
        if (pxBounds.x != null) {
            // Ensure right edge of window is on-screen.
            if (this._containerSize.width > 0 && pxBounds.x > this._containerSize.width - this._rendered.width) {
                pxBounds.x = this._containerSize.width - this._rendered.width;
            }

            // Ensure left edge of window is on-screen.
            if (pxBounds.x < 0) {
                pxBounds.x = 0;
            }

            // Store.
            this._rendered.x = Math.round(pxBounds.x);
        }
    
        // Constrain y position, store value in _rendered property.
        if (pxBounds.y != null) {
            // Ensure bottom edge of window is on-screen.
            if (this._containerSize.height > 0 && pxBounds.y > this._containerSize.height - this._rendered.height) {
                pxBounds.y = this._containerSize.height - this._rendered.height;
            }

            // Ensure top edge of window is on-screen.
            if (pxBounds.y < 0) {
                pxBounds.y = 0;
            }

            // Store.
            this._rendered.y = Math.round(pxBounds.y);
        }

        // Perform redraw based on new _rendered state.
        this._redraw();
    }
});
/**
 * Extras root namespace object.  Components are contained directly in this namespace.
 * @namespace
 */
Extras = { 

    /**
     * Maintains a unique id for the ExtrasApp namespace.
     * 
     * @type Number
     */
    uniqueId: 0
};

/**
 * Extras serialization namespace.
 * @namespace
 */
Extras.Serial = { 
    
    /**
     * Serialization type prefix for properties specific to Echo Extras.
     */
    PROPERTY_TYPE_PREFIX: "Extras.Serial."
};

/**
 * Extras components synchronization peer namespace.  Any objects in this namespace should not be accessed by application 
 * developers or extended outside of the Extras library.
 * @namespace
 */
Extras.Sync = { };

/**
 * Abstract base class for timed animated effects.
 * Animation developer provides initialization, step, and completion methods.
 */
Extras.Sync.Animation = Core.extend({

    /**
     * The current animation step index.  This value is incremented when init() is invoked and each time step() is invoked.
     * Thus, the first time step() is invoked, stepIndex will have a value of 1.
     */
    stepIndex: 0,
    
    /**
     * The actual start time of the animation (milliseconds since the epoch, i.e., value returned by new Date().getTime()).
     * @type Number
     */
    startTime: null,

    /**
     * The calculated end time of the animation (milliseconds since the epoch, i.e., value returned by new Date().getTime()).
     * This value is the sum of <code>startTime</code> and <code>runTime</code>.  The animation will run until the system time
     * reaches or first exceeds this value.
     * @type Number
     */
    endTime: null,
    
    /**
     * Listener management object.
     * @type Core.ListenerList
     */
    _listenerList: null,
    
    /**
     * Runnable used to render animation over time.
     * @type Core.Web.Scheduler.Runnable
     */
    _runnable: null,
    
    $virtual: {
    
        /**
         * The runtime, in milliseconds of the animation.
         * @type Number
         */
        runTime: 0,
        
        /**
         * Sleep interval, in milliseconds.  The interval with which the animation should sleep between frames.  
         * Default value is 10ms.
         * @type Number
         */
        sleepInterval: 10
    },

    $abstract: {
    
        /**
         * Initializes the animation.  This method will always be invoked internally, it should not be manually invoked.
         * This method will be invoked before the <code>step()</code> method.  This method may never be invoked if
         * the animation is immediately aborted or the allotted run time has expired.
         */
        init: function() { },
        
        /**
         * Completes the animation.  This method will always be invoked internally, it should not be manually invoked.
         * This method will always be invoked to finish the animation and/or clean up its resources, even if the animation 
         * was aborted.  Implementations of this method should render the animation in its completed state.
         * 
         * @param {Boolean} abort a flag indicating whether the animation aborted, true indicating it was aborted, false indicating
         *        it completed without abort
         */
        complete: function(abort) { },
        
        /**
         * Renders a step within the animation.  This method will always be invoked internally, it should not be manually invoked.
         * The implementation should not attempt to check if the animation is finished, as this work should be done in the
         * <code>complete()</codE> method.
         * 
         * @param {Number} progress a decimal value between 0 and 1 indicating the progress of the animation.
         */
        step: function(progress) { }
    },
    
    /**
     * Invoked by runnable to process a step of the animation.
     */
    _doStep: function() {
        var currentTime = new Date().getTime();
        if (currentTime < this.endTime) {
            if (this.stepIndex === 0) {
                this.init();
            } else {
                this.step((currentTime - this.startTime) / this.runTime);
            }
            ++this.stepIndex;
            Core.Web.Scheduler.add(this._runnable);
        } else {
            this.complete(false);
            if (this._completeMethod) {
                this._completeMethod(false);
            }
        }
    },
    
    /**
     * Aborts an in-progress animation.  The <code>complete()</code> method will be invoked.
     */
    abort: function() {
        Core.Web.Scheduler.remove(this._runnable);
        this.complete(true);
        if (this._completeMethod) {
            this._completeMethod(true);
        }
    },
    
    /**
     * Starts the animation.
     * 
     * @param {Function} completeMethod a function to execute when the animation has completed (it will be passed a boolean
     *        value of true or false to indicate whether animation was aborted (true) or not (false))
     */
    start: function(completeMethod) {
        this._runnable = new Core.Web.Scheduler.MethodRunnable(Core.method(this, this._doStep),  this.sleepInterval, false);
        this.startTime = new Date().getTime();
        this.endTime = this.startTime + this.runTime;
        this._completeMethod = completeMethod;
        Core.Web.Scheduler.add(this._runnable);
    }
});/**
 * AccordionPane component: contains multiple children in vertically arranged
 * tabs that slide up and down to reveal a single child at a time. May contain
 * multiple children. May contain panes as children.
 * 
 * @cp {String} activeTabId the renderId of the active tab
 * @cp {Number} activeTabIndex the index of the active tab
 * @sp {Number} animationTime the duration (in milliseconds) for which the
 *     animation transition effect should be rendered A value of zero indicates
 *     an instantaneous transition
 * @sp {#Insets} defaultContentInsets the default inset margin to display around
 *     child components
 * @sp {#Color} tabBackground the tab background color
 * @sp {#FillImage} tabBackgroundImage the tab background image
 * @sp {#Border} tabBorder the tab border
 * @sp {#Font} tabFont the tab font
 * @sp {#Color} tabForeground the tab foreground color
 * @sp {#Insets} tabInsets the tab inset margin
 * @sp {#Color} tabRolloverBackground the tab rollover background color
 * @sp {#FillImage} tabRolloverBackgroundImage the tab rollover background image
 * @sp {#Border} tabRolloverBorder the tab rollover border
 * @sp {#Font} tabRolloverFont the tab rollover font
 * @sp {Boolean} tabRolloverEnabled flag indicating whether rollover effects are
 *     enabled
 * @sp {#Color} tabRolloverForeground the tab rollover foreground color
 * @ldp {#ImageReference} icon the icon to display within a tab
 * @ldp {String} title the text to display within a tab
 */
Extras.AccordionPane = Core.extend(Echo.Component, {
    
    $static: {
    
        /**
         * The default animation time, 350ms.
         * @type Number
         */
        DEFAULT_ANIMATION_TIME: 350
    },
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.AccordionPane", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.AccordionPane",

    /** @see Echo.Component#pane */
    pane: true,
    
    /**
     * Constructor.
     * @param properties associative mapping of initial property values (optional)
     */
    $construct: function(properties) {
        Echo.Component.call(this, properties);
        this.addListener("property", Core.method(this, this._tabChangeListener));
    },
    
    /**
     * Processes a user request to select a tab.
     * Notifies listeners of a "tabSelect" event.
     * 
     * @param {String} tabId the renderId of the child tab component
     */
    doTabSelect: function(tabId) {
        // Determine selected component.
        var tabComponent = this.application.getComponentByRenderId(tabId);
        if (!tabComponent || tabComponent.parent != this) {
            throw new Error("doTabSelect(): Invalid tab: " + tabId);
        }
        
        // Store active tab id.
        this.set("activeTabId", tabId);

        // Notify tabSelect listeners.
        this.fireEvent({ type: "tabSelect", source: this, tab: tabComponent, data: tabId });
    },
    
    /**
     * Internal property listener which synchronizes activeTabIndex and activeTabId properties when possible.
     * 
     * @param e a property event
     */
    _tabChangeListener: function(e) {
        var i;
        switch (e.propertyName) {
        case "activeTabId":
            if (this.application) {
                for (i = 0; i < this.children.length; ++i) {
                    if (this.children[i].renderId == e.newValue) {
                        if (this.get("activeTabIndex") != i) {
                            this.set("activeTabIndex", i);
                        }
                        return;
                    }
                }
            }
            break;
        case "activeTabIndex":
            i = parseInt(e.newValue, 10);
            if (this.application && this.children[i] && this.get("activeTabId") != this.children[i].renderId) {
                this.set("activeTabId", this.children[i].renderId);
            }
            break;
        }
    }
});
/**
 * BorderPane component: a container which renders a
 * <code>FillImageBorder</code> around its content. May contain only one
 * child. May contain a pane component as a child.
 * 
 * @sp {#FillImage} backgroundImage  the content background image
 * @sp {#FillImageBorder} border the border with which to surround the content
 * @sp {#Insets} insets the inset margin between border and content
 */
Extras.BorderPane = Core.extend(Echo.Component, {
    
    $static: {
    
        /**
         * Default border.
         * @type #FillImageBorder
         */
        DEFAULT_BORDER: { color: "#00007f", contentInsets: 20, borderInsets: 3 }
    },
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.BorderPane", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.BorderPane",

    /** @see Echo.Component#pane */
    pane: true
});/**
 * CalendarSelect component: an input component which allows selection of a single date.  Displays a representation of a calendar,
 * showing the currently selected month/year.  May not contain child components.
 *
 * @cp {Date} date the selected date
 * @sp {#Color} adjacentMonthDateBackground background color for dates in previous/next months
 * @sp {#Color} adjacentMonthDateForeground foreground color for dates in previous/next months
 * @sp {#Border} border the border wrapping the calendar
 * @sp {#FillImage} backgroundImage calendar background image
 * @sp {#Color} dateBackground default background color of date cells
 * @sp {#FillImage} dateBackgroundImage default background image of date cells (note that this image is displayed behind the 
 *     entire calendar date grid, rather than being repeated in each cell)
 * @sp {#Border} dateBorder default border of date cells
 * @sp {#Color} dateForeground default foreground color of date cells
 * @sp {Number} dayOfWeekNameAbbreviationLength number of characters to use in abbreviated day names (default 2)
 * @sp {#Color} headerBackground background color of the week header
 * @sp {#FillImage} headerBackgroundImage background image of the week header
 * @sp {#Color} headerForeground foreground color of the week header
 * @sp {#Color} rolloverDateBackground rollover background color of date cells
 * @sp {#Color} rolloverDateBorder rollover border of date cells
 * @sp {#FillImage} rolloverDateBackgroundImage rollover background image of date cells
 * @sp {#Color} rolloverDateForeground rollover foreground color of date cells
 * @sp {#Color} selectedDateBackground background color of selected date
 * @sp {#Border} selectedDateBorder border of selected date
 * @sp {#FillImage} selectedDateBackgroundImage background image of selected date
 * @sp {#Color} selectedDateForeground foreground color of selected date
 */
Extras.CalendarSelect = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.CalendarSelect", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.CalendarSelect"
});
/**
 * ColorSelect component: an input component which displays a hue selector and
 * an integrated value/saturation selector to enable the selection of a 24-bit
 * RGB color. May not contain child components.
 * 
 * @cp {#Color} color the selected color
 * @sp {Boolean} displayValue flag indicating whether hex color value should be displayed
 * @sp {#Extent} hueWidth the width of the hue selector
 * @sp {#Extent} saturationHeight the height of the saturation selector
 * @sp {#Extent} valueWidth the width of the value selector
 */
Extras.ColorSelect = Core.extend(Echo.Component, {
    
    $static: {
        /** Default value width: 12em. */
        DEFAULT_VALUE_WIDTH: "12em",

        /** Default saturation height: 12em. */
        DEFAULT_SATURATION_HEIGHT: "12em",

        /** Default hue width: 2em. */
        DEFAULT_HUE_WIDTH: "2em"
    },
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.ColorSelect", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.ColorSelect"
});
/**
 * DataGrid component: a model-based container which can display extremely large
 * amounts of content in a scrollable view. Content is retrieved from the model
 * only as necessary, enabling the component to contain more content than could
 * ever possibly be rendered. This component renders its content using cell
 * renderers, not child components. This component may not contain child
 * components.
 * 
 * This is an EXPERIMENTAL component, it should not be used at this point for
 * any purpose other than testing it.
 * 
 * @cp {Extras.DataGrid.Model} model the data model
 * @cp {Number} rowIndex displayed origin row index
 * @cp {Number} columnIndex displayed origin column index
 * @cp {Border} cellBorder default cell border
 * @sp {Number} fixedRowsTop the number of rows at the top which should not
 *     scroll
 * @sp {Number} fixedRowsBottom the number of rows at the bottom which should
 *     not scroll
 * @sp {Number} fixedColumnsRight the number of columns on the right side which
 *     should not scroll
 * @sp {Number} fixedColumnsLeft the number of columns on the left side which
 *     should not scroll
 * @sp {Array} columnWidth the widths of columns (as Extents)
 */
Extras.DataGrid = Core.extend(Echo.Component, {
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.DataGrid", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.DataGrid",
    
    /** @see Echo.Component#pane */
    pane: true
});

/**
 * Abstract base class for <code>DataGrid</code> models.
 */
Extras.DataGrid.Model = Core.extend({

    $abstract: {
    
        /**
         * Returns the data value contained in the model at the specified column and row.
         * The value will be provided to a renderer before it is displayed.
         * The returned value may be of any type.
         * 
         * @param {Number} column the column number (0-based)
         * @param {Number} row the row number (0-based)
         * @return the model value
         */
        get: function(column, row) { },
    
        /**
         * Returns the number of columns in the model
         * 
         * @return the number of columns in the model
         * @type Number
         */
        getColumnCount: function() { },
        
        /**
         * Returns the number of rows in the model
         * 
         * @return the number of rows in the model
         * @type Number
         */
        getRowCount: function() { }
    },
    
    $virtual: {
        
        /**
         * Invoked to notify model of a region of data which should be made available for display.
         * 
         * @param {Function} callback function which should be invoked by implementation when prefetching has completed
         *        this function may be invoked asynchronously, i.e., as a result of an event that is fired some time after the
         *        prefetch method has returned
         * @param {Number} firstColumn the first column to retrieve (inclusive)
         * @param {Number} firstRow the first row to retrieve (inclusive)
         * @param {Number} lastColumn the last column to retrieve (inclusive)
         * @param {Number} lastRow the last row to retrieve (inclusive)
         */
        prefetch: null
    }
});

/**
 * Drag source component.
 * 
 * @cp {Array} dropTargetIds array of strings specifying renderIds of valid drop target components
 */
Extras.DragSource = Core.extend(Echo.Component, {
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.DragSource", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.DragSource",

    /**
     * Programmatically performs a drop action.
     * 
     * @param {String} dropTarget the renderId of the valid drop target component on which the source component was dropped
     * @param {String} specificTarget the renderId of the most-specific component on which the source component was dropped 
     *        (must be a descendant of dropTargetComponent, may be equal to dropTarget)
     */
    doDrop: function(dropTarget, specificTarget) {
        this.fireEvent({ type: "drop", source: this, dropTarget: dropTarget, specificTarget: specificTarget, 
                data: specificTarget });
    }
});
/**
 * Group component: A container which renders a border consisting of images
 * around its content. Optionally draws a title in the top border. May contain
 * one child component. May not contain a pane component as a child.
 * 
 * @sp {#FillImage} backgroundImage background image to display behind content
 * @sp {Array} borderImage an array containing the top-left, top, top-right,
 *     left, right, bottom-left, bottom, and bottom-right images that make up
 *     the border (note this an array of ImageReferences, not FillImages
 * @sp {Number} borderInsets the inset margin used to provide space for the
 *     border (if the left border were 6 pixels wide, the left portion of the
 *     inset should be also be configured to 6 pixels; a zero inset would render
 *     the content over the border)
 * @sp {#Insets} insets the inset margin around the content.
 * @sp {String} title
 * @sp {#FillImage} titleBackgroundImage background image to display behind
 *     title
 * @sp {#Font} titleFont the title font
 * @sp {#Insets} titleInsets the title inset margin
 * @sp {#Extent} titlePosition the title position, relative to the top-left
 *     corner of the component
 */
Extras.Group = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.Group", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Extras.Group"
});
/**
 * Abstract base class for menu components. Provides common functionality.
 */
Extras.MenuComponent = Core.extend(Echo.Component, {
    
    $abstract: true,
    
    /** @see Echo.Component#modalSupport */
    modalSupport: true,
    
    /** @see Echo.Component#focusable */
    focusable: true,
    
    /**
     * Processes the user selection an item.
     * 
     * @param {Extras.ItemModel} itemModel the selected item
     */
    doAction: function(itemModel) {
        var path = itemModel.getItemPositionPath().join(".");
        if (itemModel instanceof Extras.ToggleOptionModel) {
            this._toggleItem(itemModel);
        }
        this.fireEvent({type: "action", source: this, data: path, modelId: itemModel.modelId});
    },
    
    /**
     * Toggles the state of an toggle option model.
     * 
     * @param {Extras.ToggleOptionModel} itemModel the option to toggle
     */
    _toggleItem: function(itemModel) {
        var model = this.get("model");
        var stateModel = this.get("stateModel");
        if (itemModel.groupId) {
            var groupItems = model.findItemGroup(itemModel.groupId);
            for (var i = 0; i < groupItems.length; ++i) {
                stateModel.setSelected(groupItems[i].modelId, false);
            }
        }
        if (stateModel) {
            stateModel.setSelected(itemModel.modelId, !stateModel.isSelected(itemModel.modelId));
        }
    }
    
});

/**
 * ContextMenu component. May not contain child components.
 * 
 * @sp {#FillImage} backgroundImage the background image that will be displayed
 *     within menus
 * @sp {#Border} border the border that will be displayed around the menus
 * @sp {#Color} disabledBackground the background color used to render disabled
 *     menu items
 * @sp {#FillImage} disabledBackgroundImage the background image used to render
 *     disabled menu items
 * @sp {#Color} disabledForeground the foreground color used to render disabled
 *     menu items
 * @sp {#ImageReference} menuExpandIcon the icon used to expand child menus
 * @sp {#Color} selectionBackground the background color used to highlight the
 *     currently selected menu item
 * @sp {#FillImage} selectionBackgroundImage the background image used to
 *     highlight the currently selected menu item
 * @sp {#Color} selectionForeground the foreground color used to highlight the
 *     currently selected menu item
 * @sp {Number} activationMode a flag indicating how the context menu may be
 *     activated, one or more of the following values ORed together:
 *     <ul>
 *     <li><code>ACTIVATION_MODE_CLICK</code>: activate menu when contents
 *     are clicked.</li>
 *     <li><code>ACTIVATION_MODE_CONTEXT_CLICK</code>: (the default)
 *     activate menu when contents are context-clicked.</li>
 *     </ul>
 */
Extras.ContextMenu = Core.extend(Extras.MenuComponent, {

    $static: {
    
        /**
         * Value for <code>activationMode</code> property, indicating that the
         * context menu should be activated whenever the contents are
         * (normal/left) clicked.
         * 
         * @type Number
         */
        ACTIVATION_MODE_CLICK: 1,

        /**
         * Value for <code>activationMode</code> property, indicating that the
         * context menu should be activated whenever the contents are context
         * (right) clicked.
         * 
         * @type Number
         */
        ACTIVATION_MODE_CONTEXT_CLICK: 2
    },

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.ContextMenu", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Extras.ContextMenu"
});

/**
 * DropDownMenu component. If the <code>selectionEnabled</code> property is
 * set, the component will display the last chosen menu item in its closed
 * state. May not contain child components.
 * 
 * @sp {Number} animationTime the animation time (in milliseconds) (A value of
 *     zero indicates animation is disabled.)
 * @sp {#FillImage} backgroundImage the background image that will be displayed
 *     in the drop down box (This image will also be used in child menus unless
 *     a value is specified for the <code>menuBackgroundImage</code>
 *     property.)
 * @sp {#Border} border the border that will be displayed around the drop down
 *     box (This border will also be used around child menus unless a value is
 *     specified for the <code>menuBorder</code> property.)
 * @sp {#Color} disabledBackground the background color used to render disabled
 *     menu items
 * @sp {#FillImage} disabledBackgroundImage the background image used to render
 *     disabled menu items
 * @sp {#ImageReference} disabledExpandIcon the expand icon displayed in the
 *     drop down box
 * @sp {#Color} disabledForeground the foreground color used to render disabled
 *     menu items
 * @sp {#ImageReference} expandIcon the expand icon displayed in the drop down
 *     box
 * @sp {#ImageReference} expandIconWidth the width of the expand icon displayed
 *     in the drop down box
 * @sp {#Extent} height the height of the drop down box
 * @sp {#Insets} insets the insets of the drop down box
 * @sp {Boolean} lineWrap flag indicating whether long lines should be wrapped
 * @sp {#Color} menuBackground the background color that will be shown in child
 *     menus
 * @sp {#FillImage} menuBackgroundImage the background image that will be drawn
 *     in child menus
 * @sp {#Border} menuBorder the border that will be drawn around child menus
 * @sp {#ImageReference} menuExpandIcon the icon used to expand child menus
 * @sp {#Font} menuFont the font that will be shown in child menus
 * @sp {#Color} menuForeground the foreground color that will be shown in child
 *     menus
 * @sp {#Extent} menuHeight the height of the expanded menu
 * @sp {#Extent} menuWidth the width of the expanded menu
 * @sp {#Color} selectionBackground the background color used to highlight the
 *     currently selected menu item
 * @sp {#FillImage} selectionBackgroundImage the background image used to
 *     highlight the currently selected menu item
 * @sp {Boolean} selectionEnabled flag indicating whether item selection is
 *     enabled
 * @sp {#Color} selectionForeground the foreground color used to highlight the
 *     currently selected menu item
 * @sp {String} selectionText the text displayed in the drop down box when no
 *     item is selected
 * @sp {#Extent} width the width of the drop down box
 */
Extras.DropDownMenu = Core.extend(Extras.MenuComponent, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.DropDownMenu", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Extras.DropDownMenu"
});

/**
 * MenuBarPane component: a menu bar containing "pull down" menus. This
 * component is a Pane, and is generally best used as the first child of a
 * <code>SplitPane</code> component whose <code>autoPositioned</code>
 * property is set to true. May not contain child components.
 * 
 * @sp {Number} animationTime the animation time (in milliseconds) ( A value of
 *     zero indicates animation is disabled)
 * @sp {#FillImage} backgroundImage the background image that will be displayed
 *     in the menu bar (This image will also be used in child menus unless a
 *     value is specified for the <code>menuBackgroundImage</code> property.)
 * @sp {#Border} border the border that will be displayed around the menu bar
 *     (This border will also be used around child menus unless a value is
 *     specified for the <code>menuBorder</code> property.)
 * @sp {#Color} disabledBackground the background color used to render disabled
 *     menu items
 * @sp {#FillImage} disabledBackgroundImage the background image used to render
 *     disabled menu items
 * @sp {#Color} disabledForeground the foreground color used to render disabled
 *     menu items
 * @sp {#Color} menuBackground the background color that will be displayed in
 *     child menus
 * @sp {#FillImage} menuBackgroundImage the background image that will be
 *     displayed in child menus
 * @sp {#Border} menuBorder the border that will be displayed around child menus
 * @sp {#ImageReference} menuExpandIcon the icon used to expand child menus
 * @sp {#Color} menuForeground the foreground color that will be displayed in
 *     child menus
 * @sp {Number} menuOpacity the opacity setting (percent) that will be used for
 *     the background color/image displayed in pulldown menus (Valid values are
 *     between 1 and 100. Some clients may not support this setting and will
 *     always render menus with 100% opacity)
 * @sp {#Color} selectionBackground the background color used to highlight the
 *     currently selected menu item
 * @sp {#FillImage} selectionBackgroundImage the background image used to
 *     highlight the currently selected menu item
 * @sp {#Color} selectionForeground the foreground color used to highlight the
 *     currently selected menu item
 */
Extras.MenuBarPane = Core.extend(Extras.MenuComponent, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.MenuBarPane", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.MenuBarPane"
});

/**
 * Abstract base class for menu model items.
 */
Extras.ItemModel = Core.extend({

    $abstract: true,
    
    /**
     * The unique identifier of the item model.
     * @type String
     */
    modelId: null,
    
    /**
     * The parent menu model.
     * @type Extras.ItemModel
     */
    parent: null
});

/**
 * Representation of a menu that may contain submenus, options, and separators.
 */
Extras.MenuModel = Core.extend(Extras.ItemModel, {
    
    /**
     * The menu title text.
     * @type String
     */
    text: null,
    
    /**
     * The menu icon.
     * @type #ImageReference
     */
    icon: null,
    
    /**
     * The child menu items, an array of <code>ItemModel</code>s.
     * @type Array
     */
    items: null,
    
    /**
     * Creates a new menu model
     * 
     * @param {String} modelId the id of the menu model
     * @param {String} text the title  text of the menu model which will appear in its
     *        parent menu when this menu is used as a submenu
     * @param {#ImageReference} icon the icon of the menu model which will appear in its
     *        parent menu when this menu is used as a submenu
     * @param {Array} items the child menu items, an array of <code>ItemModel</code>s
     *        (optional)
     */
    $construct: function(modelId, text, icon, items) {
        this.modelId = modelId;
        this.id = Extras.uniqueId++;
        this.parent = null;
        this.text = text;
        this.icon = icon;
        if (items) {
            for (var i = 0; i < items.length; ++i) {
                items[i].parent = this;
            }
        }
        this.items = items ? items : [];
    },
    
    /**
     * Adds an item to the MenuModel.
     *
     * @param {Extras.ItemModel} item the item (must be a MenuModel, OptionModel, or SeparatorModel.
     */
    addItem: function(item) {
        this.items.push(item);
        item.parent = this;
    },
    
    /**
     * Finds an item by id in the <code>MenuModel</code>, searching descendant <code>MenuModel</code>s as necessary.
     * 
     * @param id the id of the menu item to find
     * @return the item model, or null if it cannot be found
     * @type Extras.ItemModel
     */
    findItem: function(id) {
        var i;
        for (i = 0; i < this.items.length; ++i) {
            if (this.items[i].id == id) {
                return this.items[i];
            }
        }
        for (i = 0; i < this.items.length; ++i) {
            if (this.items[i] instanceof Extras.MenuModel) {
                var itemModel = this.items[i].findItem(id);
                if (itemModel) {
                    return itemModel;
                }
            }
        }
        return null;
    },
    
    /**
     * Finds all items with the specified group id in the <code>MenuModel</code>, searching descendant <code>MenuModel</code>s 
     * as necessary.
     * 
     * @param groupId the id of the group to find
     * @return an array of items with the specified group id (an empty array if no items exists)
     * @type Array
     */
    findItemGroup: function(groupId) {
        var groupItems = [];
        for (var i = 0; i < this.items.length; ++i) {
            if (this.items[i] instanceof Extras.MenuModel) {
                var subGroupItems = this.items[i].findItemGroup(groupId);
                for (var j = 0; j < subGroupItems.length; ++j) {
                    groupItems.push(subGroupItems[j]);
                }
            } else if (this.items[i].groupId == groupId) {
                groupItems.push(this.items[i]);
            }
        }
        return groupItems;
    },
    
    /**
     * Returns the <code>ItemModel</code> at a specific path within this menu model.
     * 
     * @param {Array} itemPositions array of integers describing path, e.g., [0,1,2] would
     *        indicate the third item in the second item in the first item in this menu model.
     * @return the found item
     * @type Extras.ItemModel 
     */
    getItemModelFromPositions: function(itemPositions) {
        var menuModel = this;
        for (var i = 0; i < itemPositions.length; ++i) {
            menuModel = menuModel.items[parseInt(itemPositions[i], 10)];
        }
        return menuModel;
    },
    
    /**
     * Determines the index of the specified menu item.
     *
     * @param {Extras.ItemModel} item the item to find
     * @return the index of the item, or -1 if it cannot be found
     * @type Number
     */
    indexOfItem: function(item) {
        for (var i = 0; i < this.items.length; ++i) {
            if (this.items[i] == item) {
                return i;
            }
        }
        return -1;
    },
    
    /** @see Object#toString */
    toString: function() {
        return "MenuModel \"" + this.text + "\" Items:" + this.items.length;
    }
});

/**
 * Representation of a menu option.
 */
Extras.OptionModel = Core.extend(Extras.ItemModel, {
    
    /**
     * The menu title.
     * @type String
     */
    text: null,
    
    /**
     * The menu icon.
     * @type #ImageReference
     */
    icon: null,
    
    /**
     * Creates a new menu option.
     *
     * @param {String} modelId the id of the menu model
     * @param {String} text the menu item title
     * @param {#ImageReference} icon the menu item icon
     */ 
    $construct: function(modelId, text, icon) {
        this.modelId = modelId;
        this.id = Extras.uniqueId++;
        this.parent = null;
        this.text = text;
        this.icon = icon;
    },
    
    /**
     * Returns an array containing the path of this model to its most distant ancestor, consisting of 
     * positions.
     * 
     * @return the array of positions
     * @type Array
     */
    getItemPositionPath: function() {
        var path = [];
        var itemModel = this;
        while (itemModel.parent != null) {
            path.unshift(itemModel.parent.indexOfItem(itemModel));
            itemModel = itemModel.parent;
        }
        return path;
    },
    
    /** @see Object#toString */
    toString: function() {
        return "OptionModel \"" + this.text + "\"";
    }
});

/**
 * Representation of a toggle button (checkbox) menu option.
 */
Extras.ToggleOptionModel = Core.extend(Extras.OptionModel, {

    /**
     * Creates a new toggle option.
     *
     * @param {String} modelId the id of the menu model
     * @param {String} text the menu item title
     */ 
    $construct: function(modelId, text) {
        Extras.OptionModel.call(this, modelId, text, null);
    }
});

/**
 * Representation of a radio button menu option.
 */
Extras.RadioOptionModel = Core.extend(Extras.ToggleOptionModel, {

    /**
     * The identifier of the group to which the radio button belongs.
     * Only one radio button in a group may be selected at a given time.
     * @type String 
     */
    groupId: null,
    
    /**
     * Creates a radio option.
     *
     * @param {String} modelId the id of the menu model
     * @param {String} text the menu item title
     * @param {String} groupId the group identifier (only one radio button in a group may be selected at a given time)
     */ 
    $construct: function(modelId, text, groupId) {
        Extras.ToggleOptionModel.call(this, modelId, text);
        this.groupId = groupId;
    }
});

/**
 * A representation of a menu separator.
 */
Extras.SeparatorModel = Core.extend(Extras.ItemModel, { });

/**
 * Representation of menu model state, describing which items are selected and/or disabled.
 */ 
Extras.MenuStateModel = Core.extend({

    /**
     * Disabled menu item ids.
     * @type Array
     */
    _disabledItems: null,
    
    /**
     * Selected menu item ids.
     * @type Array
     */
    _selectedItems: null,

    /**
     * Creates a new <code>MenuStateModel</code>.
     */
    $construct: function() {
        this._disabledItems = [];
        this._selectedItems = [];
    },
    
    /**
     * Determines if the specified menu item is enabled.
     *
     * @param {String} modelId the item model id
     * @return true if the item is enabled
     * @type Boolean
     */
    isEnabled: function(modelId) {
        if (modelId) {
            for (var i = 0; i < this._disabledItems.length; i++) {
                if (this._disabledItems[i] == modelId) {
                    return false;
                }
            }
        }
        return true;
    },
    
    /**
     * Determines if the specified menu item is selected.
     *
     * @param {String} modelId the item model id
     * @return true if the item is selected
     * @type Boolean
     */
    isSelected: function(modelId) {
        if (modelId) {
            for (var i = 0; i < this._selectedItems.length; i++) {
                if (this._selectedItems[i] == modelId) {
                    return true;
                }
            }
        }
        return false;
    },
    
    /**
     * Sets the enabled state of a menu item.
     *
     * @param {String} modelId the item model id
     * @param {Boolean} enabled the enabled state
     */
    setEnabled: function(modelId, enabled) {
        if (enabled) {
            Core.Arrays.remove(this._disabledItems, modelId);
        } else {
            if (Core.Arrays.indexOf(this._disabledItems, modelId) == -1) {
                this._disabledItems.push(modelId);
            }
        }
    },
    
    /**
     * Sets the selection state of a menu item.
     *
     * @param {String} modelId the item model id
     * @param {Boolean} selected the selection state
     */
    setSelected: function(modelId, selected) {
        if (selected) {
            if (Core.Arrays.indexOf(this._selectedItems, modelId) == -1) {
                this._selectedItems.push(modelId);
            }
        } else {
            Core.Arrays.remove(this._selectedItems, modelId);
        }
    }
});
/**
 * RichTextArea component: a rich text user input field which allows the user to
 * select text styles, and insert/manipulate objects such as links, images, enumerated
 * lists, or tables.  This component may not contain children.
 * 
 * Security warning: HTML input provided by this component should be considered
 * potentially malicious. Directly rendering the HTML entered by one user to
 * other users of a multi-user application without first "cleaning" it could be
 * disastrous to the other users. For example, a user could potentially embed
 * JavaScript code in URLs that would execute in the other users' browsers. Any
 * cleaning operations must be performed on the client that will render such
 * HTML (not the client sending it) or on a central trusted server.
 * 
 * @cp {String} text the content of the text area
 * @sp {#Border} border the border surrounding the text entry area
 * @sp {String} menuStyleName style name for menu bar
 * @sp {String} controlPaneStyleName style name for control panes used in
 *     dialogs
 * @sp {String} controlPaneRowStyleName style name for control pane row used in
 *     dialogs
 * @sp {String} controlPaneButtonStyleName style name for control pane buttons
 *     used in dialogs
 * @sp {String} toolbarButtonStyleName style name for main toolbar buttons
 * @sp {String} windowPaneStyleName style name for dialog
 *     <code>WindowPane</code>
 * @sp {Object} icons associative array mapping icon names to images
 * @sp {Object} features associative array describing which features should be
 *     enabled.
 * @event action An event fired when the enter/return key is pressed while the
 *        text area is focused.
 */
Extras.RichTextArea = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.RichTextArea", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.RichTextArea",

    /** @see Echo.Component#focusable */
    focusable: true,
    
    /**
     * Processes a user action (pressing enter within text entry area).
     */
    doAction: function() {
        this.fireEvent({source: this, type: "action"});
    },
    
    /**
     * Executes a rich-text editing command.
     * 
     * @param {String} commandName the command name
     * @param {String} value the (optional) value to send
     */
    execCommand: function(commandName, value) {
        this.fireEvent({type: "execCommand", source: this, commandName: commandName, value: value });
    },
    
    /**
     * Inserts HTML within the text area at the current cursor location.
     *
     * @param {String} html the HTML to be inserted 
     */
    insertHtml: function(html) {
        this.execCommand("insertHtml", html);
    }
});
/**
 * RichTextInput component.  A chrome-less cross browser rich text editing component.  Provides no toolbars/menus/features of
 * any kind.  Designed to be used within an application-rendered component, e.g., Extras.Sync.RichTextArea.
 * 
 * @cp {String} text the content of the text area
 * @sp {#Border} border the border surrounding the text entry area
 * @event action An event fired when the enter/return key is pressed while the
 *        text area is focused.
 * @event cursorStyleChange An event fired when the cursor is moved over text that may have a different style.
 * @event execCommand An event fired to provide notification of a rich-text editing command being executed.
 * @event insertHtml An event fired to provide notification of HTML insertion. 
 */
Extras.RichTextInput = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.RichTextInput", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.RichTextInput",
    
    /** @see Echo.Component#focusable */
    focusable: true,
    
    /**
     * Processes a user action (pressing enter within text entry area).
     */
    doAction: function() {
        this.fireEvent({source: this, type: "action"});
    },
    
    /**
     * Processes a cursor style change (cursor has moved over content which may have new style). 
     */
    doCursorStyleChange: function(style) {
        this.fireEvent({source: this, type: "cursorStyleChange", style: style});
    },
    
    /**
     * Executes a rich-text editing command.
     * 
     * @param {String} commandName the command name
     * @param {String} value the (optional) value to send
     */
    execCommand: function(commandName, value) {
        this.fireEvent({type: "execCommand", source: this, commandName: commandName, value: value });
    },
    
    /**
     * Inserts HTML within the text area at the current cursor location.
     *
     * @param {String} html the HTML to be inserted 
     */
    insertHtml: function(html) {
        this.execCommand("insertHtml", html);
    }
});/**
 * TabPane component: a container which displays children as an array of tabs, displaying only the component whose tab is selected
 * at a specific time.  May contain zero or more child components.  May contain pane components as children.
 *
 * @cp {String} activeTabId the renderId of the active tab
 * @cp {Number} activeTabIndex the index of the active tab
 * @sp {#Border} border the border surrounding the content of the tab pane (note that <code>tabActiveBorder</code> will be used
 *     for this purpose if this property is not configured) 
 * @sp {Number} borderType the border border type, one of the following values:
 *     <ul>
 *      <li><code>BORDER_TYPE_NONE</code></li>
 *      <li><code>BORDER_TYPE_ADJACENT_TO_TABS</code> (the default)</li>
 *      <li><code>BORDER_TYPE_PARALLEL_TO_TABS</code></li>
 *      <li><code>BORDER_TYPE_SURROUND</code></li>
 *     </ul> 
 * @sp {#Insets} defaultContentInsets the default content inset margin
 * @sp {#FillImageBorder} imageBorder the image border to display around the entire <code>TabPane</code>
 * @sp {#Insets} insets the inset margin around the entire <code>TabPane</code>
 * @sp {#ImageReference} rolloverScrollLeftIcon the rolled-over version of <code>scrollLeftIcon</code>
 * @sp {#ImageReference} rolloverScrollRightIcon the rolled-over version of <code>scrollRightIcon</code>
 * @sp {#ImageReference} scrollLeftIcon the scroll icon to display to enable scrolling of the header to the left
 * @sp {#ImageReference} scrollRightIcon the scroll icon to display to enable scrolling of the header to the right
 * @sp {#Color} tabActiveBackground the background color used to render active tabs
 * @sp {#FillImage} tabActiveBackgroundImage the background image used to render active tabs
 * @sp {#Insets} tabActiveBackgroundInsets the inset margin displayed around the background color/image used to render active tabs
 *     (rendered only when image borders are used)
 * @sp {#Border} tabActiveBorder the border surrounding the active tab and the content of the <code>TabPane</code>
 * @sp {#Font} tabActiveFont the font used to render active tabs
 * @sp {#Color} tabActiveForeground the foreground color used to render active tabs
 * @sp {#Extent} tabActiveHeightIncrease the height increase of active tabs
 * @sp {#FillImageBorder} tabActiveImageBorder the image border to display around active tabs
 * @sp {#Insets} tabActiveInsets the inset margin used to render active tabs
 * @sp {#Alignment} tabAlignment the alignment within an individual tab
 * @sp {#FillImage} tabBackgroundImage the background image displayed behind the tabs
 * @sp {Boolean} tabCloseEnabled flag indicating whether tabs may be closed
 * @sp {#ImageReference} tabCloseIcon the tab close icon
 * @sp {Boolean} tabCloseIconRolloverEnabled flag indicating whether tab close icon rollover effects are enabled
 * @sp {#ImageReference} tabDisabledCloseIcon the tab close icon for tabs that may not be closed
 * @sp {#Extent} tabHeight the minimum height of an individual (inactive) tab
 * @sp {#Color} tabInactiveBackground the background color used to render inactive tabs
 * @sp {#FillImage} tabInactiveBackgroundImage the background image used to render inactive tabs
 * @sp {#Insets} tabInactiveBackgroundInsets the inset margin displayed around the background color/image used to render inactive
 *     tabs (rendered only when image borders are used)
 * @sp {#Border} tabInactiveBorder the border surrounding inactive tabs
 * @sp {#Font} tabInactiveFont the font used to render inactive tabs
 * @sp {#Color} tabInactiveForeground the foreground color used to render inactive tabs
 * @sp {#FillImageBorder} tabInactiveImageBorder the image border to display around inactive tabs
 * @sp {#Insets} tabInactiveInsets the inset margin used to render inactive tabs
 * @sp {#Extent} tabIconTextMargin the margin size between the tab icon and the text
 * @sp {#Extent} tabInset the horizontal distance from which all tabs are inset from the edge of the <code>TabPane</code>
 * @sp {#Extent} tabMaximumWidth the maximum allowed width for a single tab (percent values may be used)
 * @sp {Number} tabPosition the position where the tabs are located relative to the pane content, one of the following values:
 * @sp {#Color} tabRolloverBackground the background used to render rolled over tabs
 * @sp {#FillImage} tabRolloverBackgroundImage the background image used to render rolled over tabs
 * @sp {#Insets} tabRolloverBackgroundInsets the inset margin displayed around the background color/image used to render rolled 
 *     over tabs (rendered only when image borders are used)
 * @sp {#Border} tabRolloverBorder the border used to render rolled over tabs
 * @sp {Boolean} tabRolloverEnabled flag indicating whether tab rollover effects are enabled
 * @sp {#Font} tabRolloverFont the font used to render rolled over tabs
 * @sp {#Color} tabRolloverForeground the foreground color used to render rolled over tabs
 * @sp {#FillImageBorder} tabRolloverImageBorder the image border used to render rolled over tabs
 * @sp {#ImageReference} tabRolloverCloseIcon the tab close rollover effect icon
 * @sp {#Extent} tabSpacing the horizontal space between individual tabs
 *     <ul>
 *      <li><code>TAB_POSITION_TOP</code></li>
 *      <li><code>TAB_POSITION_BOTTOM</code></li>
 *     </ul>
 * @sp {#Extent} tabWidth the width of an individual tab (setting tabMaximumWidth is generally preferred)
 * @ldp {#Color} activeBackground the active background color
 * @ldp {#FillImage} activeBackgroundImage the active background image
 * @ldp {#Insets} activeBackgroundInsets the inset margin displayed around the background color/image when the tab is active
 *      (rendered only when image borders are used)
 * @ldp {#Border} activeBorder the active border
 * @ldp {#Font} activeFont the active font
 * @ldp {#Color} activeForeground the active foreground color
 * @ldp {#ImageReference} activeIcon the active icon (icon property is used when inactive)
 * @ldp {#FillImageBorder} activeImageBorder the active image border
 * @ldp {#Insets} activeInsets the active insets
 * @ldp {Boolean} closeEnabled flag indicating whether close is enabled (default is true, only effective when containing
 *      <code>TabPane</code> allows closing tabs)
 * @ldp {#ImageReference} icon the icon to display within a tab
 * @ldp {#Color} inactiveBackground the inactive background color
 * @ldp {#FillImage} inactiveBackgroundImage the inactive background image
 * @ldp {#Insets} inactiveBackgroundInsets the inset margin displayed around the background color/image when the tab is inactive
 *      (rendered only when image borders are used)
 * @ldp {#Border} inactiveBorder the inactive border
 * @ldp {#Font} inactiveFont the inactive font
 * @ldp {#Color} inactiveForeground the inactive foreground color
 * @ldp {#FillImageBorder} inactiveImageBorder the inactive image border
 * @ldp {#Insets} inactiveInsets the inactive insets
 * @ldp {#Color} rolloverBackground the rollover background color
 * @ldp {#FillImage} rolloverBackgroundImage the rollover background image
 * @ldp {#Insets} rolloverBackgroundInsets the inset margin displayed around the background color/image when the tab is rolled over
 *      (rendered only when image borders are used)
 * @ldp {#Border} rolloverBorder the rollover border
 * @ldp {#Font} rolloverFont the rollover font
 * @ldp {#Color} rolloverForeground the rollover foreground color
 * @ldp {#ImageReference} rolloverIcon the rollover icon
 * @ldp {#FillImageBorder} rolloverImageBorder the rollover image border
 * @ldp {String} title the text to display within a tab
 * @ldp {String} toolTipText the tool tip text to display when a tab is rolled over
 * @event tabClose An event fired when the user requests to close a tab.
 * @event tabSelect An event fired when the user selects a tab. 
 */
Extras.TabPane = Core.extend(Echo.Component, {

    $static: {
    
        /**
         * Constant for the <code>borderType</code> property indicating that no 
         * border should be drawn around the content.
         * @type Number
         */
        BORDER_TYPE_NONE: 0,
        
        /**
         * Constant for the <code>borderType</code> property indicating that a
         * border should be drawn immediately adjacent to the tabs only.
         * If the tabs are positioned at the top of the <code>TabPane</code> the
         * border will only be drawn directly beneath the tabs with this setting.  
         * If the tabs are positioned at the bottom of the <code>TabPane</code> the
         * border will only be drawn directly above the tabs with this setting.
         * @type Number
         */
        BORDER_TYPE_ADJACENT_TO_TABS: 1,
        
        /**
         * Constant for the <code>borderType</code> property indicating that
         * borders should be drawn above and below the content, but not at its 
         * sides.
         * @type Number
         */
        BORDER_TYPE_PARALLEL_TO_TABS: 2,
        
        /**
         * Constant for the <code>borderType</code> property indicating that
         * borders should be drawn on all sides of the content.
         * @type Number
         */
        BORDER_TYPE_SURROUND: 3,
        
        /**
         * Constant for the <code>tabPosition</code> property indicating that
         * the tabs are positioned at the top of the <code>TabPane</code>.
         * @type Number
         */
        TAB_POSITION_TOP: 0,
        
        /**
         * Constant for the <code>tabPosition</code> property indicating that
         * the tabs are positioned at the bottom of the <code>TabPane</code>.
         * @type Number
         */
        TAB_POSITION_BOTTOM: 1
    },

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.TabPane", this);
    },

    /** @see Echo.Component#componentType */
    componentType: "Extras.TabPane",

    /** @see Echo.Component#pane */
    pane: true,
    
    /**
     * Constructor.
     * @param properties associative mapping of initial property values (optional)
     */
    $construct: function(properties) {
        Echo.Component.call(this, properties);
        this.addListener("property", Core.method(this, this._tabChangeListener));
    },
    
    /**
     * Processes a user request to close a tab.
     * Notifies listeners of a "tabClose" event.
     * 
     * @param {String} tabId the renderId of the child tab component
     */
    doTabClose: function(tabId) {
        // Determine selected component.
        var tabComponent = this.application.getComponentByRenderId(tabId);
        if (!tabComponent || tabComponent.parent != this) {
            throw new Error("doTabClose(): Invalid tab: " + tabId);
        }

        // Notify tabClose listeners.
        this.fireEvent({ type: "tabClose", source: this, tab: tabComponent, data: tabId });
    },

    /**
     * Processes a user request to select a tab.
     * Notifies listeners of a "tabSelect" event.
     * 
     * @param {String} tabId the renderId of the child tab component
     */
    doTabSelect: function(tabId) {
        // Determine selected component.
        var tabComponent = this.application.getComponentByRenderId(tabId);
        if (!tabComponent || tabComponent.parent != this) {
            throw new Error("doTabSelect(): Invalid tab: " + tabId);
        }
        
        // Store active tab id.
        this.set("activeTabId", tabId);
        
        // Notify tabSelect listeners.
        this.fireEvent({ type: "tabSelect", source: this, tab: tabComponent, data: tabId });
    },
    
    /**
     * Internal property listener which synchronizes activeTabIndex and activeTabId properties when possible.
     * 
     * @param e a property event
     */
    _tabChangeListener: function(e) {
        var i;
        switch (e.propertyName) {
        case "activeTabId":
            if (this.application) {
                for (i = 0; i < this.children.length; ++i) {
                    if (this.children[i].renderId == e.newValue) {
                        if (this.get("activeTabIndex") != i) {
                            this.set("activeTabIndex", i);
                        }
                        return;
                    }
                }
            }
            break;
        case "activeTabIndex":
            i = parseInt(e.newValue, 10);
            if (this.application && this.children[i] && this.get("activeTabId") != this.children[i].renderId) {
                this.set("activeTabId", this.children[i].renderId);
            }
            break;
        }
    }
});

/**
 * ToolTipContainer component: a container which may contain two children, the
 * first of which is always displayed and the second of which is displayed with
 * the mouse is hovered over the first. May contain zero, one, or two components
 * as children. Many not contain pane components.
 */
Extras.ToolTipContainer = Core.extend(Echo.Component, {
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.ToolTipContainer", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.ToolTipContainer"
});/**
 * TransitionPane component: a container pane which displays a single child pane
 * or component, rendering an animated transition effect when its content is
 * changed (when the child is removed and a new one is added). May contain zero
 * or one child components. May contain pane components as children.
 * 
 * @sp type the transition type, one of the following values:
 *     <ul>
 *     <li><code>TYPE_IMMEDIATE_REPLACE</code></li>
 *     <li><code>TYPE_CAMERA_PAN_LEFT</code></li>
 *     <li><code>TYPE_CAMERA_PAN_RIGHT</code></li>
 *     <li><code>TYPE_CAMERA_PAN_UP</code></li>
 *     <li><code>TYPE_CAMERA_PAN_DOWN</code></li>
 *     <li><code>TYPE_BLIND_BLACK_IN</code></li>
 *     <li><code>TYPE_BLIND_BLACK_OUT</code></li>
 *     <li><code>TYPE_FADE_TO_BLACK</code></li>
 *     <li><code>TYPE_FADE_TO_WHITE</code></li>
 *     <li><code>TYPE_FADE</code></li>
 *     </ul>
 * @sp {Number} duration the transition duration, in milliseconds
 */
Extras.TransitionPane = Core.extend(Echo.Component, {

    $static: {
    
        /**
         * Default duration time (350ms).
         */
        DEFAULT_DURATION: 350,
        
        /**
         * Default transition type (immediate replace).
         */
        DEFAULT_TYPE: 0,
        
        /**
         * Transition setting indicating new content should immediately 
         * final int replace old content with no visual effect.
         */
        TYPE_IMMEDIATE_REPLACE: 0,
            
        /**
         * Transition setting describing a visual effect where the
         * viewing area pans to the left to realize the new content.
         * Old content exits to the right side of the screen.
         * New content enters from the left side of the screen. 
         */
        TYPE_CAMERA_PAN_LEFT: 1,
        
        /**
         * Transition setting describing a visual effect where the
         * viewing area pans to the right to realize the new content.
         * Old content exits to the left side of the screen.
         * New content enters from the right side of the screen. 
         */
        TYPE_CAMERA_PAN_RIGHT: 2,
        
        /**
         * Transition setting describing a visual effect where the
         * viewing area pans up to realize the new content.
         * Old content exits to the bottom of the screen.
         * New content enters from the top of the screen. 
         */
        TYPE_CAMERA_PAN_UP: 3,
        
        /**
         * Transition setting describing a visual effect where the
         * viewing area pans to up to realize the new content.
         * Old content exits to the top of the screen.
         * New content enters from the bottom of the screen. 
         */
        TYPE_CAMERA_PAN_DOWN: 4,
        
        /**
         * Transition setting for a horizontal blind effect with a black background.
         * Top of blinds rotate inward.
         */
        TYPE_BLIND_BLACK_IN: 5,
        
        /**
         * Transition setting for a horizontal blind effect with a black background.
         * Top of blinds rotate outward.
         */
        TYPE_BLIND_BLACK_OUT: 6,
        
        /**
         * Transition setting to fade to black, fade in new content.
         */
        TYPE_FADE_TO_BLACK: 7,
    
        /**
         * Transition setting to fade to white, fade in new content.
         */
        TYPE_FADE_TO_WHITE: 8,

        /**
         * Fades to new content over old content.
         */
        TYPE_FADE: 9
    },

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.TransitionPane", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.TransitionPane",

    /** @see Echo.Component#pane */
    pane: true
});
/**
 * ItemModel PropertyTranslator singleton.  Not registered, but used by other translators.
 */
Extras.Serial.ItemModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {
    
        /**
         * Parses an icon contained in a menu model property element.
         * 
         * @param {Echo.Client} client the client
         * @param {Element} pElement the property "p" element
         */
        parseIcon: function(client, pElement) {
            var icon = Core.Web.DOM.getChildElementByTagName(pElement, "icon");
            if (icon) {
                return Echo.Serial.ImageReference.toProperty(client, icon);
            }
            return null;
        },
        
        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var type = pElement.getAttribute("t");
            if (type.indexOf(Extras.Serial.PROPERTY_TYPE_PREFIX) === 0) {
                type = type.substring(Extras.Serial.PROPERTY_TYPE_PREFIX.length);
            }
            var translator = Extras.Serial[type];
              if (translator) {
                  return translator.toProperty(client, pElement);
            } else {
                throw new Error("Unsupported model type: " + type);
            }
        }
    }
});

/**
 * MenuModel PropertyTranslator singleton.
 */
Extras.Serial.MenuModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var id = pElement.getAttribute("id");
            var text = pElement.getAttribute("text");
            var icon = Extras.Serial.ItemModel.parseIcon(client, pElement);
            var model = new Extras.MenuModel(id, text, icon);
            
            var children = Core.Web.DOM.getChildElementsByTagName(pElement, "item");
            for (var i = 0; i < children.length; i++) {
                var childElement = children[i];
                var subModel = Extras.Serial.ItemModel.toProperty(client, childElement);
                model.addItem(subModel);
           }
           return model;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.MenuModel", this);
    }
});

/**
 * OptionModel PropertyTranslator singleton.
 */
Extras.Serial.OptionModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var id = pElement.getAttribute("id");
            var text = pElement.getAttribute("text");
            var icon = Extras.Serial.ItemModel.parseIcon(client, pElement);
            return new Extras.OptionModel(id, text, icon);
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.OptionModel", this);
    }
});

/**
 * RadioOptionModel PropertyTranslator singleton.
 */
Extras.Serial.RadioOptionModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var id = pElement.getAttribute("id");
            var text = pElement.getAttribute("text");
            var icon = Extras.Serial.ItemModel.parseIcon(client, pElement);
            return new Extras.RadioOptionModel(id, text, icon);
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.RadioOptionModel", this);
    }
});

/**
 * ToggleOptionModel PropertyTranslator singleton.
 */
Extras.Serial.ToggleOptionModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var id = pElement.getAttribute("id");
            var text = pElement.getAttribute("text");
            var icon = Extras.Serial.ItemModel.parseIcon(client, pElement);
            return new Extras.ToggleOptionModel(id, text, icon);
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.ToggleOptionModel", this);
    }
});

/**
 * SeparatorModel PropertyTranslator singleton.
 */
Extras.Serial.SeparatorModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            return new Extras.SeparatorModel();
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.SeparatorModel", this);
    }
});

/**
 * MenuStateModel PropertyTranslator singleton.
 */
Extras.Serial.MenuStateModel = Core.extend(Echo.Serial.PropertyTranslator, {
    
    $static: {

        /** @see Echo.Serial.PropertyTranslator#toProperty */
        toProperty: function(client, pElement) {
            var stateModel = new Extras.MenuStateModel();
            var children = Core.Web.DOM.getChildElementsByTagName(pElement, "i");
            for (var i = 0; i < children.length; i++) {
                var childElement = children[i];
                var enabledValue = childElement.getAttribute("enabled");
                if (enabledValue != null) {
                    stateModel.setEnabled(childElement.getAttribute("id"), enabledValue == "true");
                }
                var selectedValue = childElement.getAttribute("selected");
                if (selectedValue != null) {
                    stateModel.setSelected(childElement.getAttribute("id"), selectedValue == "true");
                }
            }
            return stateModel;
        }
    },
    
    $load: function() {
        Echo.Serial.addPropertyTranslator("Extras.Serial.MenuStateModel", this);
    }
});
/**
 * Component rendering peer: AccordionPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.AccordionPane = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /**
         * Default component property settings, used when supported component object does not provide settings. 
         */
        _DEFAULTS: {
            tabBackground: "#cfcfcf",
            tabBorder: "1px outset #cfcfcf",
            tabForeground: "#000000",
            tabInsets: "2px 5px",
            tabContentInsets: 0
        }
    },
    
    $load: function() {
        Echo.Render.registerPeer("Extras.AccordionPane", this);
    },
    
    /**
     * Tab rotation animation runtime, in milliseconds.
     * @type Number
     */
    _animationTime: 0,
    
    /**
     * Root DIV.
     * @type Element
     */
    div: null,
    
    /**
     * renderId of currently active tab.
     * @type String
     */
    _activeTabId: null,

    /**
     * Flag indicating whether new images have been loaded, requiring a redraw/possible-resize of tabs.
     * @type Boolean
     */
    _newImagesLoaded: null,
    
    /**
     * Flag indicating whether renderDisplay is scheduled to be executed.
     * @type Boolean
     */
    _pendingRenderDisplay: false,
    
    /**
     * Animated rotation currently in progress (null when not animating).
     * @type Extras.Sync.AccordionPane.Rotation
     */
    rotation: null,
    
    /**
     * Array of Extras.Sync.AccordionPane.Tab instances representing individual tabs.
     * @type Array
     */
    tabs: null,
    
    /**
     * Flag indicating whether content overflow should be set to hidden during animation.
     * Set based on browser type, used to prevent rendering artifacts in certain browsers.
     * @type Boolean
     */
    resetOverflowForAnimation: false,
    
    /** 
     * Method reference to <code>_tabSelectListener</code> of instance.
     * @type Function 
     */
    _tabSelectListenerRef: null,
    
    /**
     * Method reference to image load monitoring function.
     * Rendering tabs register image loading listeners to this reference.
     * @type Function
     */
    imageMonitorRef: null,

    /** Constructor. */
    $construct: function() {
        this.tabs = [];
        this.resetOverflowForAnimation = Core.Web.Env.ENGINE_GECKO || Core.Web.Env.ENGINE_MSHTML;
        this._tabSelectListenerRef = Core.method(this, this._tabSelectListener);
        this.imageMonitorRef = Core.method(this, this._imageMonitor);
    },
    
    /**
     * Retrieves the tab instance with the specified tab id.
     * 
     * @param tabId the tab id
     * @return the tab, or null if no tab is present with the specified id
     */
    _getTabById: function(tabId) {
        for (var i = 0; i < this.tabs.length; ++i) {
            var tab = this.tabs[i];
            if (tab.childComponent.renderId == tabId) {
                return tab;
            }
        }
        return null;
    },
    
    /**
     * Determines the height of one or more tabs.
     *
     * If only beginIndex is specified, the height of the tab at index beginIndex will be returned.
     * Note that if endIndex is specified, the tab at index endIndex will NOT be included in the calculation,
     * that is, to measure the height of tabs 2, 3, and 4, it is necessary specify beginIndex as 2 and endIndex as 5 (not 4).
     *
     * @param {Number} beginIndex the begin index, inclusive
     * @param {Number} endIndex the end index, exclusive
     * @return the tab height(s), in pixels
     * @type Number
     */
    getTabHeight: function(beginIndex, endIndex) {
        if (endIndex == null || endIndex < beginIndex) {
            throw new Error("Invalid indices: begin=" + beginIndex + ",end=" + endIndex);
        } else {
            var tabHeight = 0;
            for (var i = beginIndex; i < endIndex; ++i) {
                tabHeight += this.tabs[i].tabDiv.offsetHeight;
            }
            return tabHeight;
        }
    },
    
    /**
     * Image monitor implementation.
     */
    _imageMonitor: function() {
        if (this._newImagesLoaded) {
            return;
        }
        this._newImagesLoaded = true;
        Core.Web.Scheduler.run(Core.method(this, function() {
            if (this.client && !this._pendingRenderDisplay) {
                this.redrawTabs(false);
            }
            this._newImagesLoaded = false;
        }));
    },
    
    /**
     * Immediately redraws tabs in the appropriate positions, exposing the content of the 
     * selected tab.  Any active animated rotation is aborted.
     * 
     * @param {Boolean} notifyComponentUpdate flag indicating whether child component should be notified to perform
     *        renderDisplay() operations
     */
    redrawTabs: function(notifyComponentUpdate) {
        if (this.rotation) {
            this.rotation.abort();
        }
        
        if (this._activeTabId == null || this._getTabById(this._activeTabId) == null) {
            if (this.tabs.length > 0) {
                this._activeTabId = this.tabs[0].childComponent.renderId;
            } else {
                this._activeTabId = null;
            }
        }
        
        var selectionPassed = false;
        for (var i = 0; i < this.tabs.length; ++i) {
            if (selectionPassed) {
                this.tabs[i].tabDiv.style.top = "";
                this.tabs[i].tabDiv.style.bottom = this.getTabHeight(i + 1, this.tabs.length ) + "px";
            } else {
                this.tabs[i].tabDiv.style.bottom = "";
                this.tabs[i].tabDiv.style.top = this.getTabHeight(0, i) + "px";
            }
    
            this.tabs[i].containerDiv.style.height = "";
            
            if (this._activeTabId == this.tabs[i].childComponent.renderId) {
                selectionPassed = true;
                this.tabs[i].containerDiv.style.display = "block";
                this.tabs[i].containerDiv.style.top = this.getTabHeight(0, i + 1) + "px";
                this.tabs[i].containerDiv.style.bottom = this.getTabHeight(i + 1, this.tabs.length) + "px";
                this.tabs[i].contentDiv.style.top = 0;
                this.tabs[i].contentDiv.style.bottom = 0;
                this.tabs[i].contentDiv.style.height = "";
                Core.Web.VirtualPosition.redraw(this.tabs[i].contentDiv);
            } else {
                this.tabs[i].containerDiv.style.display = "none";
            }
        }
        
        if (notifyComponentUpdate) {
            Echo.Render.notifyResize(this.component);
            this.renderDisplayTabs();
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.component.addListener("tabSelect", this._tabSelectListenerRef);
        
        this._animationTime = this.component.render("animationTime", Extras.AccordionPane.DEFAULT_ANIMATION_TIME);
        this._activeTabId = this.component.get("activeTabId");
        
        this.div = document.createElement("div");
        this.div.id = this.component.renderId;
        this.div.style.cssText = "position:absolute;width:100%;height:100%;";
        Echo.Sync.renderComponentDefaults(this.component, this.div);
        
        var componentCount = this.component.getComponentCount();
        for (var i = 0; i < componentCount; ++i) {
            var child = this.component.getComponent(i);
            var tab = new Extras.Sync.AccordionPane.Tab(child, this);
            this.tabs.push(tab);
            tab.render(update);
            this.div.appendChild(tab.tabDiv);
            this.div.appendChild(tab.containerDiv);
        }
        
        parentElement.appendChild(this.div);
        
        this._pendingRenderDisplay = true;
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        this._pendingRenderDisplay = false;
        if (!this.rotation) {
            this.redrawTabs(false);
        }
        this.renderDisplayTabs();
    },
    
    /**
     * Invokes renderDisplay() implementations on tabs.
     */
    renderDisplayTabs: function() {
        for (var i = 0; i < this.tabs.length; ++i) {
            this.tabs[i].renderDisplay();
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this.component.removeListener("tabSelect", this._tabSelectListenerRef);

        if (this.rotation) {
            this.rotation.abort();
        }
        this._activeTabId = null;
        for (var i = 0; i < this.tabs.length; i++) {
            this.tabs[i].dispose();
        }
        this.tabs = [];
        this.div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var fullRender;

        if (update.hasUpdatedLayoutDataChildren() || update.hasAddedChildren() || update.hasRemovedChildren()) {
            // Add/remove/layout data change: full render.
            fullRender = true;
        } else {
            var propertyNames = update.getUpdatedPropertyNames();
            if (propertyNames.length == 1 && propertyNames[0] == "activeTabId") {
                this._selectTab(update.getUpdatedProperty("activeTabId").newValue);
                fullRender = false;
            } else {
                fullRender = true;
            }
        }

        if (fullRender) {
            var element = this.div;
            var containerElement = element.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(element);
            this.renderAdd(update, containerElement);
        }

        return fullRender;
    },
    
    /**
     * "Rotates" the AccordionPane to display the specified tab.
     *
     * @param {String} oldTabId the currently displayed tab id
     * @param {String} newTabId the id of the tab that will be displayed
     */
    _rotateTabs: function(oldTabId, newTabId) {
        var oldTab = this._getTabById(oldTabId);
        if (oldTab == null) {
            // Old tab has been removed.
            this.redrawTabs(true);
            return;
        }
        if (this.rotation) {
            // Rotation was already in progress, cancel
            this.rotation.abort();
            this.redrawTabs(true);
        } else {
            // Start new rotation.
            var newTab = this._getTabById(newTabId);
            this.rotation = new Extras.Sync.AccordionPane.Rotation(this, oldTab, newTab);
            this.rotation.runTime = this._animationTime;
            this.rotation.start();
        }
    },
    
    /**
     * Selects a specific tab.
     * 
     * @param {String} tabId the id of the tab to select
     */
    _selectTab: function(tabId) {
        if (tabId == this._activeTabId) {
            return;
        }
        
        var oldTabId = this._activeTabId;
        this._activeTabId = tabId;
        if (oldTabId != null && this._animationTime > 0) {
            this._rotateTabs(oldTabId, tabId);
        } else {
            this.redrawTabs(true);
        }
    },
    
    /**
     * Event listener to component instance for user tab selections.
     * 
     * @param e the event
     */
    _tabSelectListener: function(e) {
        this._selectTab(e.tab.renderId);
    }
});

/**
 * Representation of a single tab (child component) within the accordion pane.
 * Provides tab-specific rendering functionality.
 */
Extras.Sync.AccordionPane.Tab = Core.extend({
    
    /**
     * DIV element containing the tab header
     * @type Element
     */
    tabDiv: null,
    
    /**
     * The AccordionPane synchronization peer.
     * @type Extras.Sync.AccordionPane
     */
    _parent: null,
    
    /**
     * The content container DIV (contains content DIV).
     * @type Element
     */
    containerDiv: null,
    
    /**
     * The content DIV (contains child component rendering).
     * @type Element
     */
    contentDiv: null,
    
    /**
     * The child component which will be rendered within the tab.
     * @type Echo.Component
     */
    childComponent: null,
    
    /**
     * Creates a new Tab instance.
     * 
     * @param {Echo.Component} childComponent the child component which will be rendered within the tab
     * @param {Extras.Sync.AccordionPane} parent the AccordionPane synchronization peer
     */
    $construct: function(childComponent, parent) {
        this.childComponent = childComponent;
        this._parent = parent;
    },
    
    /**
     * Adds event listeners to the tab to handle click and mouse events.
     */
    _addEventListeners: function() {
        Core.Web.Event.add(this.tabDiv, "click", Core.method(this, this._processClick), false);
        if (this._parent.component.render("tabRolloverEnabled", true)) {
            Core.Web.Event.add(this.tabDiv, 
                    Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseenter" : "mouseover", 
                    Core.method(this, this._processEnter), false);
            Core.Web.Event.add(this.tabDiv, 
                    Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseleave" : "mouseout", 
                    Core.method(this, this._processExit), false);
        }
        Core.Web.Event.Selection.disable(this.tabDiv);
    },
    
    /**
     * Disposes of the tab, releasing any resources.
     */
    dispose: function() {
        Core.Web.Event.removeAll(this.tabDiv);
        this._parent = null;
        this.childComponent = null;
        this.tabDiv = null;
        this.containerDiv = null;
    },
    
    /**
     * Determine content inset margin.
     * 
     * @return the content inset margin
     * @type #Insets
     */
    getContentInsets: function() {
        if (this.childComponent.pane) {
            return 0;
        } else {
            var insets = this._parent.component.render("defaultContentInsets");
            return insets ? insets : Extras.Sync.AccordionPane._DEFAULTS.tabContentInsets;
        }
    },
    
    /**
     * Tab click handler.
     * 
     * @param e the click event
     */
    _processClick: function(e) {
        if (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component)) {
            return;
        }
        this._parent.component.doTabSelect(this.childComponent.renderId);
    },
    
    /**
     * Tab rollover enter handler.
     * 
     * @param e the mouse event
     */
    _processEnter: function(e) {
        if (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component)) {
            return;
        }
        this._renderState(true);
    },
    
    /**
     * Tab rollover exit handler.
     * 
     * @param e the mouse event
     */
    _processExit: function(e) {
        if (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component)) {
            return;
        }
        this._renderState(false);
    },
    
    /**
     * Renders the tab.
     * 
     * @param {Echo.Update.ComponentUpdate} update the component update 
     */
    render: function(update) {
        var layoutData = this.childComponent.render("layoutData") || {};
        
        this.tabDiv = document.createElement("div");
        this.tabDiv.id = this._parent.component.renderId + "_tab_" + this.childComponent.renderId;
        this.tabDiv.style.cssText = "cursor:pointer;position:absolute;left:0;right:0;overflow:hidden;";
        
        Echo.Sync.Insets.render(this._parent.component.render("tabInsets", Extras.Sync.AccordionPane._DEFAULTS.tabInsets), 
                this.tabDiv, "padding");
        
        if (layoutData.icon) {
            //FIXME Temporary implementation.  Need proper layout for common icon + text case.
            var img = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(layoutData.icon, img);
            img.style.paddingRight = "3px";
            this.tabDiv.appendChild(img);
            
            Core.Web.Image.monitor(this.tabDiv, this._parent.imageMonitorRef);
        }
        
        this.tabDiv.appendChild(document.createTextNode(layoutData.title ? layoutData.title : "\u00a0"));
    
        this.containerDiv = document.createElement("div");
        this.containerDiv.style.cssText = "display:none;position:absolute;left:0;right:0;overflow:hidden;";
        
        this.contentDiv = document.createElement("div");
        this.contentDiv.style.cssText = "position:absolute;left:0;right:0;overflow:auto;";
        Echo.Sync.Insets.render(this.getContentInsets(), this.contentDiv, "padding");
        
        Echo.Render.renderComponentAdd(update, this.childComponent, this.contentDiv);
        
        this.containerDiv.appendChild(this.contentDiv);
        
        this._renderState(false);
        this._addEventListeners();
    },
    
    /**
     * Renders the tab active or inactive, updating header state.
     * 
     * @param {Boolean} rollover the rollover state of the tab, true for active, false for inactive
     */
    _renderState: function(rollover) {
        var tabDiv = this.tabDiv,
            border = this._parent.component.render("tabBorder", Extras.Sync.AccordionPane._DEFAULTS.tabBorder),
            borderData,
            borderDataBottom,
            background = this._parent.component.render("tabBackground", Extras.Sync.AccordionPane._DEFAULTS.tabBackground);
            
        if (rollover) {
            var rolloverBackground = this._parent.component.render("tabRolloverBackground");
            if (!rolloverBackground) {
                rolloverBackground = Echo.Sync.Color.adjust(background, 20, 20, 20);
            }
            Echo.Sync.Color.render(rolloverBackground, tabDiv, "backgroundColor");
            var backgroundImage = this._parent.component.render("tabRolloverBackgroundImage");
            if (backgroundImage) {
                tabDiv.style.backgroundImage = "";
                tabDiv.style.backgroundPosition = "";
                tabDiv.style.backgroundRepeat = "";
                Echo.Sync.FillImage.render(backgroundImage, tabDiv, null);
            }
            var foreground = this._parent.component.render("tabRolloverForeground");
            if (foreground) {
                Echo.Sync.Color.render(foreground, tabDiv, "color");
            }
            Echo.Sync.Font.render(this._parent.component.render("tabRolloverFont"), tabDiv);
            var rolloverBorder = this._parent.component.render("tabRolloverBorder");
            if (!rolloverBorder) {
                rolloverBorder = border;
                if (Echo.Sync.Border.isMultisided(rolloverBorder)) {
                    borderData = Echo.Sync.Border.parse(rolloverBorder.top);
                    borderDataBottom = Echo.Sync.Border.parse(rolloverBorder.bottom);
                    rolloverBorder = {
                            top: Echo.Sync.Border.compose(borderData.size, borderData.style,
                                    Echo.Sync.Color.adjust(borderData.color, 20, 20, 20)),
                            bottom: Echo.Sync.Border.compose(borderDataBottom.size, borderDataBottom.style,
                                    Echo.Sync.Color.adjust(borderDataBottom.color, 20, 20, 20))
                    };
                } else {
                    borderData = Echo.Sync.Border.parse(rolloverBorder);
                    rolloverBorder = Echo.Sync.Border.compose(borderData.size, borderData.style,
                            Echo.Sync.Color.adjust(borderData.color, 20, 20, 20));
                }
            }
        } else {
            Echo.Sync.Color.render(background, tabDiv, "backgroundColor");
            Echo.Sync.Color.render(this._parent.component.render("tabForeground", 
                    Extras.Sync.AccordionPane._DEFAULTS.tabForeground), tabDiv, "color");
            Echo.Sync.Font.renderClear(this._parent.component.render("tabFont"), tabDiv);
            tabDiv.style.backgroundImage = "";
            tabDiv.style.backgroundPosition = "";
            tabDiv.style.backgroundRepeat = "";
            Echo.Sync.FillImage.render(this._parent.component.render("tabBackgroundImage"), tabDiv);
        }

        if (Echo.Sync.Border.isMultisided(border)) {
            Echo.Sync.Border.render(border.top, tabDiv, "borderTop");
            Echo.Sync.Border.render(border.bottom, tabDiv, "borderBottom");
        } else {
            Echo.Sync.Border.render(border, tabDiv, "borderTop");
            Echo.Sync.Border.render(border, tabDiv, "borderBottom");
        }
    },
    
    /**
     * Tab-specific renderDisplay() tasks.
     */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this.tabDiv);
        Core.Web.VirtualPosition.redraw(this.containerDiv);
        Core.Web.VirtualPosition.redraw(this.contentDiv);
    }
});

/**
 * Manages the rotation animation of an AccordionPane.
 */
Extras.Sync.AccordionPane.Rotation = Core.extend(Extras.Sync.Animation, {
    
    /**
     * The AccordionPane peer.
     * @type Extras.Sync.AccordionPane
     */
    _parent: null,

    /**
     * The old tab.
     * @type Extras.Sync.AccordionPane.Tab 
     */
    _oldTab: null,
    
    /**
     * The new tab.
     * @type Extras.Sync.AccordionPane.Tab 
     */
    _newTab: null,
    
    /**
     * Index of old tab.
     * @type Number
     */
    _oldTabIndex: null,
    
    /**
     * Index of new tab.
     * @type Number
     */
    _newTabIndex: null,
    
    /**
     * Flag indicating whether tabs will be rotating downward (true) or upward (false).
     * @type Boolean
     */
    _directionDown: null,
    
    /**
     * Number of tabs which are rotating.
     * @type Number
     */
    _rotatingTabCount: null,
    
    /**
     * Height of accordion pane.
     * @type Number
     */
    _regionHeight: null,
    
    /**
     * Numbers of tabs above that will not be moving.
     * @type Number
     */
    _numberOfTabsAbove: null,
    
    /**
     * Number of tabs below that will not be moving.
     * @type Number
     */
    _numberOfTabsBelow: null,
    
    /** 
     * Initial position of extreme edge of first moving tab.
     * For downward moves, this value is the top edge of the top tab.
     * For upward moves, this value is the bottom edge of the bottom tab.
     * @param Number
     */
    _startPosition: null,
    
    /**
     * Number of pixels across which animation will occur.
     * @type Number
     */
    _animationDistance: null,
    
    /**
     * Creates a new rotation.
     *
     * @param {Extras.Sync.AccordionPane} parent the AccordionPane peer
     * @param {Extras.Sync.AccordionPane.Tab} oldTab the old (current) tab
     * @param {Extras.Sync.AccordionPane.Tab} newTab the new tab to display
     */
    $construct: function(parent, oldTab, newTab) {
        this._parent = parent;
        this._oldTab = oldTab;
        this._newTab = newTab;
        
        // Calculate and store parameters for rotation.
        this._regionHeight = this._parent.div.offsetHeight;
        this._oldTabIndex = Core.Arrays.indexOf(this._parent.tabs, this._oldTab);
        this._newTabIndex = Core.Arrays.indexOf(this._parent.tabs, this._newTab);
        this._rotatingTabCount = Math.abs(this._newTabIndex - this._oldTabIndex);
        this._directionDown = this._newTabIndex < this._oldTabIndex;
        if (this._directionDown) {
            this._numberOfTabsAbove = this._newTabIndex + 1;
            this._numberOfTabsBelow = this._parent.tabs.length - 1 - this._newTabIndex;
            this._startPosition = this._parent.getTabHeight(0, this._newTabIndex + 1);
            this._animationDistance = this._regionHeight - 
                    this._parent.getTabHeight(this._newTabIndex + 1, this._parent.tabs.length) - this._startPosition;
        } else {
            this._numberOfTabsAbove = this._newTabIndex;
            this._numberOfTabsBelow = this._parent.tabs.length - 1 - this._newTabIndex;
            this._startPosition = this._parent.getTabHeight(this._newTabIndex + 1, this._parent.tabs.length);
            this._animationDistance = this._regionHeight - this._parent.getTabHeight(0, this._newTabIndex + 1) - 
                    this._startPosition;
        }
    },
    
    /** @see Extras.Sync.Animation#complete */
    complete: function() {
        this._parent.rotation = null;

        // Complete Rotation.
        var parent = this._parent;
        
        if (this._parent.resetOverflowForAnimation) {
            this._oldTab.contentDiv.style.overflow = "auto";
            this._newTab.contentDiv.style.overflow = "auto";
        }

        var renderId = this._parent.component.renderId;
        this._parent = null;
        this._oldTab = null;
        this._newTab = null;
        
        parent.redrawTabs(true);
    },
    
    /** @see Extras.Sync.Animation#init */
    init: function() {
        this._newTab.containerDiv.style.height = "";
        if (this._directionDown) {
            this._oldTab.containerDiv.style.bottom = "";
            this._newTab.containerDiv.style.top = this._parent.getTabHeight(0, this._newTabIndex + 1) + "px";
        } else {
            this._newTab.containerDiv.style.top = "";
            this._newTab.containerDiv.style.bottom = 
                    this._parent.getTabHeight(this._newTabIndex + 1, this._parent.tabs.length) + "px";
        }
        this._newTab.containerDiv.style.display = "block";

        // Set size of tab content to be equivalent to available space.
        var regionContentHeight = this._parent.div.offsetHeight - this._parent.getTabHeight(0, this._parent.tabs.length);
        var oldTabInsets = Echo.Sync.Insets.toPixels(this._oldTab.getContentInsets());
        var newTabInsets = Echo.Sync.Insets.toPixels(this._newTab.getContentInsets());
        var oldContentHeight = regionContentHeight - oldTabInsets.top - oldTabInsets.bottom;
        var newContentHeight = regionContentHeight - newTabInsets.top - newTabInsets.bottom;
        oldContentHeight = oldContentHeight > 0 ? oldContentHeight : 0;
        newContentHeight = newContentHeight > 0 ? newContentHeight : 0;

        if (this._parent.resetOverflowForAnimation) {
            this._oldTab.contentDiv.style.overflow = "hidden";
            this._newTab.contentDiv.style.overflow = "hidden";
        }

        this._oldTab.contentDiv.style.bottom = "";
        this._newTab.contentDiv.style.bottom = "";
        this._oldTab.contentDiv.style.height = oldContentHeight + "px";
        this._newTab.contentDiv.style.height = newContentHeight + "px";
    },

    /** @see Extras.Sync.Animation#step */
    step: function(progress) {
        var i,
            oldContainerHeight,
            newContainerHeight,
            stepPosition = Math.round(progress * this._animationDistance);

        if (this._directionDown) {
            // Move each moving tab to next step position.
            for (i = this._oldTabIndex; i > this._newTabIndex; --i) {
                this._parent.tabs[i].tabDiv.style.top = (stepPosition + this._startPosition + 
                        this._parent.getTabHeight(this._newTabIndex + 1, i)) + "px";
            }

            // Adjust height of expanding new tab content to fill expanding space.
            newContainerHeight = stepPosition;
            if (newContainerHeight < 0) {
                newContainerHeight = 0;
            }
            this._newTab.containerDiv.style.height = newContainerHeight + "px";

            // Move top of old content downward.
            var oldTop = stepPosition + this._startPosition + 
                    this._parent.getTabHeight(this._newTabIndex + 1, this._oldTabIndex + 1);
            this._oldTab.containerDiv.style.top = oldTop + "px";

            // Reduce height of contracting old tab content to fit within contracting space.
            oldContainerHeight = this._regionHeight - this._parent.getTabHeight(this._newTabIndex, this._oldTabIndex);
            if (oldContainerHeight < 0) {
                oldContainerHeight = 0;
            }
            this._oldTab.containerDiv.style.height = oldContainerHeight + "px";
        } else {
            // Move each moving tab to next step position.
            for (i = this._oldTabIndex + 1; i <= this._newTabIndex; ++i) {
                this._parent.tabs[i].tabDiv.style.bottom = (stepPosition + this._startPosition + 
                        this._parent.getTabHeight(i + 1, this._newTabIndex + 1)) + "px";
            }

            // Reduce height of contracting old tab content to fit within contracting space.
            oldContainerHeight = this._regionHeight - stepPosition - 
                    this._parent.getTabHeight(this._oldTabIndex, this._newTabIndex); 
            if (oldContainerHeight < 0) {
                oldContainerHeight = 0;
            }
            this._oldTab.containerDiv.style.height = oldContainerHeight + "px";

            // Increase height of expanding tab content to fit within expanding space.
            newContainerHeight = stepPosition;
            if (newContainerHeight < 0) {
                newContainerHeight = 0;
            }
            this._newTab.containerDiv.style.height = newContainerHeight + "px";
        }
    }
});
/**
 * Component rendering peer: BorderPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.BorderPane = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Extras.BorderPane", this);
    },

    /**
     * The main DIV element.
     * @type Element
     */
    _div: null,
    
    /**
     * The content containing DIV element.
     * @type Element
     */
    _content: null,
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = Echo.Sync.FillImageBorder.renderContainer(this.component.render("border", Extras.BorderPane.DEFAULT_BORDER),
                { absolute: true, content: true });
        this._div.id = this.component.renderId;
        this._div.style.top = this._div.style.right = this._div.style.bottom = this._div.style.left = 0;
        
        this._content = Echo.Sync.FillImageBorder.getContainerContent(this._div);
        
        Echo.Sync.renderComponentDefaults(this.component, this._content);
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this._content);
    
        var componentCount = this.component.getComponentCount();
        if (componentCount == 1) {
            var child = this.component.getComponent(0);
            var insets = child.pane ? null : this.component.render("insets");
            if (insets) {
                Echo.Sync.Insets.render(insets, this._content, "padding");
            }
            Echo.Render.renderComponentAdd(update, child, this._content);
        } else if (componentCount > 1) {
            throw new Error("Too many children: " + componentCount);
        }
        
        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        Echo.Sync.FillImageBorder.renderContainerDisplay(this._div);
        Core.Web.VirtualPosition.redraw(this._content);
        Core.Web.VirtualPosition.redraw(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._content = null;
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});
/**
 * Component rendering peer: CalendarSelect.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.CalendarSelect = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
            border: "1px outset #cfcfcf",
            background: "#cfcfcf",
            foreground: "#000000",
            font: {
                size: "10pt"
            },
            dateForeground: "#000000",
            dateBackground: "#dfdfdf",
            dateBorder: {
                top: "1px solid #efefef",
                left: "1px solid #efefef",
                right: "1px solid #bfbfbf",
                bottom: "1px solid #bfbfbf"
            },
            selectedDateForeground: "#ffffff",
            selectedDateBackground: "#2f2f6f",
            adjacentMonthDateForeground: "#8f8f8f"
        },
    
        /**
         * Minimum year to display (1582, beginning of Gregorian calendar).
         * @type Number
         */
        MINIMUM_YEAR: 1582,

        /**
         * Maximum year to display (9999).
         * @type Number
         */
        MAXIMUM_YEAR: 9999,

        /**
         * Array-map mapping month numbers (indices) to numbers of days in the month.
         * February is not specified due to it requiring calculation based on year.
         * @type Array
         */
        _DAYS_IN_MONTH: [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        
        /**
         * Localization resource bundle.
         */
        resource: new Core.ResourceBundle({
            "DayOfWeek.0":     "Sunday",
            "DayOfWeek.1":     "Monday",
            "DayOfWeek.2":     "Tuesday",
            "DayOfWeek.3":     "Wednesday",
            "DayOfWeek.4":     "Thursday",
            "DayOfWeek.5":     "Friday",
            "DayOfWeek.6":     "Saturday",
            "Month.0":         "January",
            "Month.1":         "February",
            "Month.2":         "March",
            "Month.3":         "April",
            "Month.4":         "May",
            "Month.5":         "June",
            "Month.6":         "July",
            "Month.7":         "August",
            "Month.8":         "September",
            "Month.9":         "October",
            "Month.10":        "November",
            "Month.11":        "December",
            "FirstDayOfWeek":  0
        }),
        
        /**
         * Animation used for sliding new months/years into place.  The foreground color of the old content is also adjusted
         * gradually during the transition.
         */
        Animation: Core.extend(Extras.Sync.Animation, {
        
            /**
             * The container element.
             * @type Element
             */
            _container: null,
            
            /**
             * Measured bounds of <code>_container</code>.
             * @type Core.Web.Measure.Bounds
             */
            _containerBounds: null,
            
            /**
             * The old content DIV.
             * @type Element
             */
            _oldContent: null,

            /**
             * The new content DIV.
             * @type Element
             */
            _newContent: null,
            
            /**
             * Boolean flag indicating a vertical (true) or horizontal (false) direction of animation.
             * @type Boolean
             */
            _vertical: null,
            
            /**
             * Boolean flag indicating a downward/rightward (true) or upward/leftward (false) direction of animation.
             * @type Boolean
             */
            _forward: null,
            
            /**
             * Distance the animated effect will move the next content, in pixels.  May not be same as measured dimension
             * in case of overlap.
             * @type Number
             */
            _travel: null,
            
            /**
             * Number of pixels to overlap new content over old content (used when animating months vertically such that shared 
             * weeks are retained during animation).
             * @type Number
             */
            _overlap: null,
            
            /**
             * Old foreground color for old content.
             * @type #Color
             */
            _oldColor: null,
            
            /**
             * New foreground color for old content.
             * @type #Color
             */
            _newColor: null,
            
            /**
             * CSS positioning property being adjusted to perform animation (top/bottom/left/right). 
             * @type String
             */
            _adjust: null,
        
            /** @see Extras.Sync.Animation#runtime */
            runTime: 500,

            /**
             * Constructor.
             * 
             * @param {Element} container the container element
             * @param {Element} oldContent the old content DIV
             * @param {Element} newContent the new content DIV
             * @param {Boolean} vertical boolean flag indicating a vertical (true) or horizontal (false) direction of animation
             * @param {Boolean} forward boolean flag indicating a downward/rightward (true) or upward/leftward (false) direction
             *                  of animation
             * @param {Number} overlap number of pixels to overlap new content over old content (used when animating months
             *                 vertically such that shared weeks are retained during animation)
             * @param {#Color} oldColor old foreground color for old content
             * @param {#Color} newColor new foreground color for old content
             */
            $construct: function(container, oldContent, newContent, vertical, forward, overlap, oldColor, newColor) {
                this._container = container;
                this._oldContent = oldContent;
                this._newContent = newContent;
                this._vertical = vertical;
                this._forward = forward;
                this._overlap = overlap || 0;
                this._oldColor = oldColor;
                this._newColor = newColor;
            },
        
            /** @see Extras.Sync.Animation#init */
            init: function() {
                this._containerBounds = new Core.Web.Measure.Bounds(this._container);
                this._travel = (this._vertical ? this._containerBounds.height : this._containerBounds.width) - this._overlap;
                this._adjust = this._vertical ? (this._forward ? "top" : "bottom") : (this._forward ? "left" : "right"); 
                this._newContent.style[this._adjust] = this._travel + "px";
                this._container.appendChild(this._newContent);
            },

            /** @see Extras.Sync.Animation#step */
            step: function(progress) {
                var position = Math.round(this._travel * (1 - progress));
                this._oldContent.style.color = Echo.Sync.Color.blend(this._oldColor, this._newColor, 2 * progress);
                this._oldContent.style[this._adjust] = (position - this._travel) + "px";
                this._newContent.style[this._adjust] = position + "px";
            },

            /** @see Extras.Sync.Animation#complete */
            complete: function(abort) {
                this._newContent.style.left = this._newContent.style.top = 
                        this._newContent.style.right = this._newContent.style.bottom = "";
                if (this._oldContent.parentNode) {
                    this._oldContent.parentNode.removeChild(this._oldContent);
                }
            }
        }),
        
        /**
         * Data object describing a month of a specific year in a specific locale (first day of week setting).
         * Determines additional information about the month used for rendering.
         */
        MonthData: Core.extend({
            
            /**
             * First day of week of the month, Sunday = 0.
             * @type Number
             */
            firstDayOfMonth: null,
            
            /**
             * Number of days in the month.
             * @type Number
             */
            daysInMonth: null,
            
            /**
             * Number of days in the previous month.
             * @type Number
             */
            daysInPreviousMonth: null,
            
            /** 
             * The year.
             * @type Number
             */
            year: null,
            
            /**
             * The month.
             * @type Number
             */
            month: null,
            
            /**
             * Number of full or partial weeks in the month.  Varies by firstDayOfWeek value.  
             * @type Number
             */
            weekCount: null,
            
            /**
             * Cell position of day 1 of the month (0 = leftmost cell, 6 = rightmost cell).
             * @type Number
             */
            firstCellPosition: null,
            
            /**
             * Constructor.
             * 
             * @param {Number} year the year
             * @param {Number} month the month
             * @param {Number} first day of week to use when rendering the month (0 = Sunday)
             */
            $construct: function(year, month, firstDayOfWeek) {
                this.year = year;
                this.month = month;
                var firstDate = new Date(year, month, 1);
                this.firstDayOfMonth = firstDate.getDay();

                this.daysInMonth = Extras.Sync.CalendarSelect.getDaysInMonth(year, month);
                this.daysInPreviousMonth = month === 0 ? Extras.Sync.CalendarSelect.getDaysInMonth(year - 1, 11) :
                        this._daysInPreviousMonth = Extras.Sync.CalendarSelect.getDaysInMonth(year, month - 1);
                
                this.firstCellPosition = (7 + this.firstDayOfMonth - firstDayOfWeek) % 7;
                this.nextMonthWeek = Math.floor((this.firstCellPosition + this.daysInMonth) / 7); 
                this.weekCount = Math.ceil((this.firstCellPosition + this.daysInMonth) / 7);
            },
            
            /**
             * Determines the date of the cell at the specified index.
             * 
             * @param {Number} cellIndex the cell index, 0 = top left cell
             * @return an object describing the date at the specified cell, containing numeric month, day, and year properties
             * @type Object
             */
            getCellDate: function(cellIndex) {
                var date;
                if (cellIndex < this.firstCellPosition) {
                    date = this.month === 0 ? { month: 11, year: this.year - 1 } :
                            { month: this.month - 1, year: this.year };
                    date.day = this.daysInPreviousMonth - this.firstDayOfMonth + cellIndex + 1;
                } else if (cellIndex >= (this.firstDayOfMonth + this.daysInMonth)) {
                    date = this.month === 11 ? { month: 0, year: this.year + 1 } :
                            { month: this.month + 1, year: this.year };
                    date.day = cellIndex - this.firstDayOfMonth - this.daysInMonth + 1;
                } else {
                    date = { month: this.month, year: this.year, day: cellIndex - this.firstDayOfMonth + 1 };
                }
                return date;
            },
            
            /**
             * Determines the cell index of the specified day in the month.
             * 
             * @param {Number} day the day of the month
             * @return the cell index
             * @type Number 
             */
            getCellIndex: function(day) {
                return day + this.firstCellPosition - 1;
            },
            
            /**
             * Determines if the specified cell index lies in the current month or an adjacent month.
             * 
             * @return true if the cell index lies in an adjacent month, false if not
             * @type Boolean
             */
            isCellAdjacent: function(cellIndex) {
                return cellIndex < this.firstCellPosition || cellIndex >= (this.firstDayOfMonth + this.daysInMonth);
            }
        }),
        
        /**
         * Determines the number of days in a specific month.
         *
         * @param year the year of the month
         * @param month the month
         * @return the number of days in the month
         */
        getDaysInMonth: function(year, month) {
            if (month == 1) {
                if (year % 400 === 0) {
                    return 29;
                } else if (year % 100 === 0) {
                    return 28;
                } else if (year % 4 === 0) {
                    return 29;
                } else {
                    return 28;
                }
            } else {
                return this._DAYS_IN_MONTH[month];
            }
        }
    },

    $load: function() {
        Echo.Render.registerPeer("Extras.CalendarSelect", this);
    },
    
    /**
     * Main outer DIV element.
     * @type Element
     */
    _div: null,
    
    /**
     * Container element for month/year fields.
     */
    _monthYearInput: null,
    
    /**
     * Month SELECT field.
     * @type Element
     */
    _monthSelect: null,
    
    /**
     * Year INPUT field.
     * @type element
     */
    _yearField: null,
    
    /**
     * Date rollover background color.
     * @type #Color
     */
    _dateRolloverBackground: null,
    
    /**
     * Date rollover background image.
     * @type #FillImage
     */
    _dateRolloverBackgroundImage: null,

    /**
     * Date rollover border.
     * @type #Border
     */
    _dateRolloverBorder: null,

    /**
     * Date rollover foreground color.
     * @type #Color
     */
    _dateRolloverForeground: null,
    
    /**
     * Date selection background color.
     * @type #Color
     */
    _dateSelectedBackground: null,

    /**
     * Date selection background image.
     * @type #FillImage
     */
    _dateSelectedBackgroundImage: null,

    /**
     * Date selection border.
     * @type #Border
     */
    _dateSelectedBorder: null,

    /**
     * Date selection foreground color.
     * @type #Color
     */
    _dateSelectedForeground: null,
    
    /**
     * Index of currently rolled over cell. 
     * @type Number
     */
    _rolloverCellIndex: null,
    
    /**
     * Currently displayed month.
     * @type Number
     */
    _displayedMonth: null,

    /**
     * Currently displayed year.
     * @type Number
     */
    _displayedYear: null,

    /**
     * First day of week for displayed localization (0 = Sunday).
     * @type Number
     */
    _firstDayOfWeek: null,
    
    /**
     * Currently selected date.  An object with month, day, and year numeric properties.
     * @type Object
     */
    _date: null,
    
    /**
     * Localization data map.
     * @type Object
     */
    _msg: null,
    
    /**
     * Custom icons map.
     * @type object
     */
    _icons: null,
    
    /**
     * Performs an animated update of the calendar.
     *
     * @param {Boolean} vertical transition new content in vertically (true) or horizontally (false)
     * @param {Boolean} forward transition new content in rightward/downward (true) or upward/leftward (false)
     * @param {Number} rowOverlap number of rows to overlap (applicable only in vertical transition)
     */
    _animateUpdate: function(vertical, forward, rowOverlap) {
        if (this._animation) {
            this._animation.abort();
        }
        
        var newDayContainerDiv = this._createDayContainer();
        var overlap = rowOverlap ? (rowOverlap * this._cellHeight + (rowOverlap - 1) * this._vCellSpacing) : 0;
        this._animation = new Extras.Sync.CalendarSelect.Animation(this._scrollContainer, this._dayContainerDiv, newDayContainerDiv, 
                vertical, forward, overlap, this._dateForeground, this._dateAdjacentForeground);
        this._animation.start(Core.method(this, function(abort) {
            this._dayContainerDiv = newDayContainerDiv;
            this._animation = null;
        }));
    },
    
    /**
     * Creates a day-container DIV element, which will hold the days of the calendar.  These elements are added to and removed
     * from the calendar using animation (if desired).
     * 
     * @return the day container element
     * @type Element
     */
    _createDayContainer: function() {
        var dayContainerDiv = document.createElement("div");
        dayContainerDiv.style.cssText = "position:absolute;";
        dayContainerDiv.style.width = this._rowWidth + "px";
        dayContainerDiv.style.height = (this._ySize * this._cellHeight + (this._ySize - 1) * this._vCellSpacing) + "px";
        for (var y = 0; y < this._ySize; ++y) {
            var rowDiv = this._createWeek(y);
            rowDiv.style.top = (y * (this._cellHeight + this._vCellSpacing)) + "px";
            dayContainerDiv.appendChild(rowDiv);
        }
        return dayContainerDiv;
    },
    
    /**
     * Creates the month and year input controls positioned above the calendar.
     * 
     * @return an element containing the month/year controls.
     * @type Element
     */
    _createMonthYearInput: function() {
        var i, option, img,
            enabled = this.component.isRenderEnabled(),
            span = document.createElement("span");
        
        this._monthSelect = document.createElement("select");
        for (i = 0; i < 12; ++i) {
            option = document.createElement("option");
            option.appendChild(document.createTextNode(this._msg["Month." + i]));
            this._monthSelect.appendChild(option);
        }
        if (!enabled) {
            this._monthSelect.disabled = true;
        }
        span.appendChild(this._monthSelect);

        span.appendChild(document.createTextNode(" "));
        
        this._yearDecSpan = document.createElement("span");
        this._yearDecSpan.style.cursor = "pointer";
        img = document.createElement("img");
        img.src = this._icons.decrement ? this._icons.decrement :
                this.client.getResourceUrl("Extras", "image/calendar/Decrement.gif");
        img.alt = "-";
        this._yearDecSpan.appendChild(img);
        span.appendChild(this._yearDecSpan);
        
        this._yearField = document.createElement("input");
        this._yearField.type = "text";
        this._yearField.style.textAlign = "center";
        this._yearField.maxLength = 4;
        this._yearField.size = 5;
        if (!enabled) {
            this._yearField.readOnly = true;
        }
        span.appendChild(this._yearField);

        this._yearIncSpan = document.createElement("span");
        this._yearIncSpan.style.cursor = "pointer";
        img = document.createElement("img");
        img.src = this._icons.increment ? this._icons.increment :
                this.client.getResourceUrl("Extras", "image/calendar/Increment.gif");
        img.alt = "+";
        this._yearIncSpan.appendChild(img);
        span.appendChild(this._yearIncSpan);
        
        return span;
    },

    /**
     * Creates a DIV containing a single week of days.
     *
     * @return the created DIV
     * @type Element
     */
    _createWeek: function(line) {
        var day = 1 - this._monthData.firstCellPosition + (7 * line);
        var rowDiv = document.createElement("div");
        rowDiv.style.cssText = "position:absolute;overflow:hidden;cursor:pointer;";
        rowDiv.style.width = this._rowWidth + "px";
        rowDiv.style.height = this._cellHeight + "px";
        for (var x = 0; x < this._xSize; ++x, ++day) {
            var cellDiv = document.createElement("div");
            cellDiv._cellIndex = 7 * line + x;
            cellDiv.style.cssText = "position:absolute;text-align:right;";
            cellDiv.style.left = (x * (this._cellWidth + this._hCellSpacing)) + "px";
            cellDiv.style.width = this._renderedCellWidth + "px";
            cellDiv.style.height = this._renderedCellHeight + "px";
            Echo.Sync.Border.render(this._dateBorder, cellDiv);
            cellDiv.style.padding = "2px 4px";
            cellDiv.style.overflow = "hidden";
            
            var displayDay;
            if (day < 1) {
                cellDiv.style.color = this._dateAdjacentForeground;
                displayDay = this._monthData.daysInPreviousMonth + day;
            } else if (day > this._monthData.daysInMonth) {
                cellDiv.style.color = this._dateAdjacentForeground;
                displayDay = day - this._monthData.daysInMonth;
            } else {
                if (this._date.day == day) {
                    Echo.Sync.Color.render(this._dateSelectedBackground, cellDiv, "backgroundColor");
                    Echo.Sync.Color.render(this._dateSelectedForeground, cellDiv, "color");
                    Echo.Sync.FillImage.render(this._dateSelectedBackgroundImage, cellDiv);
                    Echo.Sync.Border.render(this._dateSelectedBorder, cellDiv);
                }
                displayDay = day;
            }
            
            cellDiv.appendChild(document.createTextNode(displayDay));

            rowDiv.appendChild(cellDiv);
        }
        return rowDiv;
    },
    
    /**
     * Returns the cell DIV for the specified cell index.
     * 
     * @param {Number} cellIndex the cell index (0 = upper left)
     * @return the DIV element
     * @type Element
     */
    _getCell: function(cellIndex) {
        return this._dayContainerDiv.childNodes[Math.floor(cellIndex / 7)].childNodes[cellIndex % 7];
    },
    
    /**
     * Loads rendering information from component into local object.
     * Calculates required sizes for day elements.
     */
    _loadRenderData: function() {
        this._font = this.component.render("font", Extras.Sync.CalendarSelect.DEFAULTS.font);
        
        // Default Cell Style
        this._dateBackground = this.component.render("dateBackground", Extras.Sync.CalendarSelect.DEFAULTS.dateBackground);
        this._dateBorder = this.component.render("dateBorder", Extras.Sync.CalendarSelect.DEFAULTS.dateBorder);
        this._dateBackgroundImage = this.component.render("dateBackgroundImage");
        this._dateForeground = this.component.render("dateForeground", Extras.Sync.CalendarSelect.DEFAULTS.dateForeground);
        
        // Selected Cell Style
        this._dateSelectedBackground = this.component.render("selectedDateBackground", 
                Extras.Sync.CalendarSelect.DEFAULTS.selectedDateBackground);
        this._dateSelectedBackgroundImage = this.component.render("selectedDateBackgroundImage");
        this._dateSelectedBorder = this.component.render("selectedDateBorder");
        this._dateSelectedForeground = this.component.render("selectedDateForeground",
                Extras.Sync.CalendarSelect.DEFAULTS.selectedDateForeground);
        
        // Rollover Cell Style
        this._dateRolloverBackground = this.component.render("rolloverDateBackground");
        this._dateRolloverBackgroundImage = this.component.render("rolloverDateBackgroundImage");
        this._dateRolloverBorder = this.component.render("rolloverDateBorder");
        this._dateRolloverForeground = this.component.render("rolloverDateForeground");
        if (!this._dateRolloverBackground) {
            this._dateRolloverBackground = Echo.Sync.Color.adjust(this._dateBackground, 0x20, 0x20, 0x20);
        }
        
        // Adjacent Cell Style
        this._dateAdjacentForeground = this.component.render("adjacentMonthDateForeground", 
                Extras.Sync.CalendarSelect.DEFAULTS.adjacentMonthDateForeground);
        this._dateAdjacentBackground = this.component.render("adjacentMonthDateBackground");
        
        // Measure size of date cell text
        var cellMeasure = document.createElement("span");
        cellMeasure.appendChild(document.createTextNode("96"));
        Echo.Sync.Font.render(this._font, cellMeasure);
        var cellBounds = new Core.Web.Measure.Bounds(cellMeasure);

        // FIXME hardcoded
        this._padding = { top: 2, bottom: 2, left: 4, right: 4 };
        this._borderSize = { top: 1, bottom: 1, left: 1, right: 1 };
        
        // Calculate cell size
        this._cellWidth = cellBounds.width + this._padding.left + this._padding.right + 
                this._borderSize.left + this._borderSize.right;
        if (this._cellWidth * 7 < this._monthYearWidth) {
            this._cellWidth = Math.ceil(this._monthYearWidth / 7);
        }
        this._cellHeight = cellBounds.height + this._padding.top + this._padding.bottom +
                this._borderSize.top + this._borderSize.bottom;
        this._hCellSpacing = 0;
        this._vCellSpacing = 0;
        this._headerHeight = cellBounds.height;
        this._headerMargin = 0;
        
        this._xSize = 7;
        this._ySize = 6;
        
        this._rowWidth = this._xSize * this._cellWidth + (this._xSize - 1) * this._hCellSpacing;
        this._calendarHeight = this._ySize * this._cellHeight + (this._ySize - 1) * this._vCellSpacing + 
                this._headerHeight + this._headerMargin;
        
        this._renderedCellWidth = this._cellWidth - this._borderSize.left - this._borderSize.right - 
                this._padding.left - this._padding.right;
        this._renderedCellHeight = this._cellHeight - this._borderSize.top - this._borderSize.bottom - 
                this._padding.top - this._padding.bottom;
    },
    
    /**
     * Processes a date rollover enter event.
     * 
     * @param e the event
     */
    _processDateRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || e.target._cellIndex == null || this._animation) {
            return;
        }
        if (this._rolloverCellIndex != null) {
            this._setCellStyle(this._rolloverCellIndex, false);
        }
        this._rolloverCellIndex = e.target._cellIndex;
        this._setCellStyle(this._rolloverCellIndex, true);
    },
    
    /**
     * Processes a date rollover exit event.
     * 
     * @param e the event
     */
    _processDateRolloverExit: function(e) {
        if (this._rolloverCellIndex) {
            this._setCellStyle(this._rolloverCellIndex, false);
            this._rolloverCellIndex = null;
        }
    },
    
    /**
     * Processes a date selection (click) event.
     * 
     * @param e the event
     */
    _processDateSelect: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || e.target._cellIndex == null || this._animation) {
            return;
        }
        this._setDate(this._monthData.getCellDate(e.target._cellIndex));
    },
    
    /**
     * Processes a month selection event.
     * 
     * @param e the event
     */
    _processMonthSelect: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            this._monthSelect.selectedIndex = this._date.month;
            return;
        }        
        this._setDate({ year: this._date.year, month: this._monthSelect.selectedIndex, day: this._date.day });
    },
    
    /**
     * Processes a year input field change event.
     * 
     * @param e the event
     */
    _processYearChange: function(e) {
        var newValue = parseInt(this._yearField.value, 10);
        if (!this.client || !this.client.verifyInput(this.component) || isNaN(newValue)) {
            this._yearField.value = this._date.year;
            return;
        }
        this._setDate({ year: newValue, month: this._date.month, day: this._date.day });
    },

    /**
     * Processes a year input field key-up event.
     * 
     * @param e the event
     */
    _processYearKeyUp: function(e) {
        if (e.keyCode == 13) {
            this._processYearChange(e);
        }
    },
    
    /**
     * Processes a year decrement button click event.
     * 
     * @param e the event
     */
    _processYearDecrement: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        this._setDate({ year: this._date.year - 1, month: this._date.month, day: this._date.day });
    },

    /**
     * Processes a year increment button click event.
     * 
     * @param e the event
     */
    _processYearIncrement: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        this._setDate({ year: this._date.year + 1, month: this._date.month, day: this._date.day });
    },
    
    /**
     * Validates the specified date object (containing month/year/day properties to be within the constrained range.
     * The date will be adjusted (if necessary) to comply with the constrained range.
     * 
     * @param date a date object containing month/day/year numeric properties
     */
    _rangeCheck: function(date) {
        if (date.year < Extras.Sync.CalendarSelect.MINIMUM_YEAR) {
            date.year = Extras.Sync.CalendarSelect.MINIMUM_YEAR;
        } else if (date.year > Extras.Sync.CalendarSelect.MAXIMUM_YEAR) {
            date.year = Extras.Sync.CalendarSelect.MAXIMUM_YEAR;
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        update = null; // Update is forcibly set to null, as this method may in some circumstances be invoked internally with
                       // a null update.
        
        this._msg = Extras.Sync.CalendarSelect.resource.get(this.component.getRenderLocale());
        this._icons = { };

        var i, j, td, tr, x, cellDiv, dayOfWeekName, monthYearDiv, headerWidth,
            enabled = this.component.isRenderEnabled(),
            dayOfWeekNameAbbreviationLength = parseInt(this.component.render("dayOfWeekNameAbbreviationLength", 2), 10),
            date = this.component.get("date");

        this._firstDayOfWeek = parseInt(this._msg["FirstDayOfWeek"], 10) || 0;

        if (!date) {
            date = new Date();
        }

        this._date = { 
             year: date.getFullYear(), 
             month: date.getMonth(), 
             day: date.getDate()
        };
        this._monthData = new Extras.Sync.CalendarSelect.MonthData(this._date.year, this._date.month, this._firstDayOfWeek);    

        this._monthYearInput = this._createMonthYearInput();
        this._monthYearWidth = new Core.Web.Measure.Bounds(this._monthYearInput).width + 10; //FIXME hardcoded.
    
        this._loadRenderData();

        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.style.cssText = "width:" + (this._cellWidth * this._xSize) + "px;";
        
        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this._div);
        Echo.Sync.Font.render(this._font, this._div);
        Echo.Sync.Color.render(this.component.render("foreground", Extras.Sync.CalendarSelect.DEFAULTS.foreground), this._div,
                "color");
        Echo.Sync.Color.render(this.component.render("background", Extras.Sync.CalendarSelect.DEFAULTS.background), this._div,
                "backgroundColor");
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), this._div);
        Echo.Sync.Border.render(this.component.render("border",  Extras.Sync.CalendarSelect.DEFAULTS.border), this._div);
        Echo.Sync.Font.render(this.component.render("font"), this._div);
        
        monthYearDiv = document.createElement("div");
        monthYearDiv.align = "center";
        monthYearDiv.style.cssText = "padding:2px 5px;white-space:nowrap;overflow:hidden;"; //FIXME hardcoded
        monthYearDiv.appendChild(this._monthYearInput);
        this._div.appendChild(monthYearDiv);
        
        this._calendarDiv = document.createElement("div");
        this._calendarDiv.style.cssText = "position:relative;";

        this._calendarDiv.style.width = this._rowWidth + "px";
        this._calendarDiv.style.height = this._calendarHeight + "px";
        this._div.appendChild(this._calendarDiv);
        
        this._currentRowDivs = [];
        
        var headerDiv = document.createElement("div");
        headerDiv.style.cssText = "position:absolute;";
        headerDiv.style.width = (this._cellWidth * 7) + "px";
        headerDiv.style.height = this._headerHeight + "px";
        Echo.Sync.Color.render(this.component.render("headerForeground", Extras.Sync.CalendarSelect.DEFAULTS.foreground), headerDiv,
                "color");
        Echo.Sync.Color.render(this.component.render("headerBackground", Extras.Sync.CalendarSelect.DEFAULTS.background), headerDiv,
                "backgroundColor");
        Echo.Sync.FillImage.render(this.component.render("headerBackgroundImage"), headerDiv);
        this._calendarDiv.appendChild(headerDiv);
        
        for (x = 0; x < this._xSize; ++x) {
            cellDiv = document.createElement("div");
            cellDiv.style.cssText = "position:absolute;text-align:center;";
            cellDiv.style.left = (x * (this._cellWidth + this._hCellSpacing)) + "px";
            cellDiv.style.width = this._cellWidth + "px";
            cellDiv.style.height = this._headerHeight + "px";
            cellDiv.style.overflow = "hidden";
            
            dayOfWeekName = this._msg["DayOfWeek." + ((this._firstDayOfWeek + x) % 7)];
            if (dayOfWeekNameAbbreviationLength > 0) {
                dayOfWeekName = dayOfWeekName.substring(0, dayOfWeekNameAbbreviationLength);
            }
            cellDiv.appendChild(document.createTextNode(dayOfWeekName));
            
            headerDiv.appendChild(cellDiv);
        }
        
        this._scrollContainer = document.createElement("div");
        this._scrollContainer.style.cssText = "position:absolute;overflow:hidden;";
        this._scrollContainer.style.top = (this._headerHeight + this._headerMargin) + "px";
        this._scrollContainer.style.height = (this._ySize * this._cellHeight + (this._ySize - 1) * this._vCellSpacing) + "px";
        this._scrollContainer.style.width = this._rowWidth + "px";
        Echo.Sync.Color.render(this._dateForeground, this._scrollContainer, "color");
        Echo.Sync.Color.render(this._dateBackground, this._scrollContainer, "backgroundColor");
        Echo.Sync.FillImage.render(this._dateBackgroundImage, this._scrollContainer);
        this._calendarDiv.appendChild(this._scrollContainer);
        
        this._dayContainerDiv = this._createDayContainer();
        this._scrollContainer.appendChild(this._dayContainerDiv);
                
        parentElement.appendChild(this._div);

        Core.Web.Event.add(this._monthSelect, "change", Core.method(this, this._processMonthSelect), false);
        Core.Web.Event.add(this._yearField, "change", Core.method(this, this._processYearChange), false);
        Core.Web.Event.add(this._yearField, "keyup", Core.method(this, this._processYearKeyUp), false);
        Core.Web.Event.add(this._yearDecSpan, "click", Core.method(this, this._processYearDecrement), false);
        Core.Web.Event.add(this._yearIncSpan, "click", Core.method(this, this._processYearIncrement), false);
        Core.Web.Event.add(this._calendarDiv, "click", Core.method(this, this._processDateSelect), false);
        Core.Web.Event.add(this._calendarDiv, "mouseover", Core.method(this, this._processDateRolloverEnter), false);
        Core.Web.Event.add(this._calendarDiv, "mouseout", Core.method(this, this._processDateRolloverExit), false);

        this._updateMonthYearSelection();
        
        Core.Web.Image.monitor(this._div, Core.method(this, function() {
            this._renderSizeUpdate();
        }));
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        update = null; // Update is forcibly set to null, as this method may in some circumstances be invoked internally with
                       // a null update.

        Core.Web.Event.removeAll(this._monthSelect);
        Core.Web.Event.removeAll(this._yearField);
        Core.Web.Event.removeAll(this._yearDecSpan);
        Core.Web.Event.removeAll(this._yearIncSpan);
        Core.Web.Event.removeAll(this._calendarDiv);
    
        this._div = null;
        this._monthSelect = null;
        this._yearField = null;
        this._dayContainerDiv = null;
        this._scrollContainer = null;
        this._calendarDiv = null;
        this._monthYearInput = null;
    },
    
    /**
     * Detects if the CalendarSelect is properly sized (i.e., as a result of additional images having been loaded) and
     * re-renders it if required.
     */
    _renderSizeUpdate: function() {
        var monthYearWidth = new Core.Web.Measure.Bounds(this._monthYearInput).width + 10;  //FIXME hardcoded.
        if (this._monthYearWidth === monthYearWidth) {
            return;
        }
        
        // Perform full render if required.
        var element = this._div;
        var containerElement = element.parentNode;
        this.renderDispose(null);
        containerElement.removeChild(element);
        this.renderAdd(null, containerElement);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update && update.isUpdatedPropertySetIn({date: true })) {
            var date = this.component.get("date") || new Date();
            if (this._date.month == date.getMonth() && this._date.day == date.getDate() && this._date.year == date.getFullYear()) {
                 return false;
            }
        }

        // Full Render
        if (this._animation) {
            this._animation.abort();
        }
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return false;
    },
    
    /**
     * Sets the style of a specific day cell.
     * 
     * @param {Number} cellIndex the cell index (0 = upper-left)
     * @param {Boolean} rollover flag indicating whether the mouse is currently rolled over the cell
     * @param {Boolean} reset flag indicating whether the cell should be reset to its default state
     */
    _setCellStyle: function(cellIndex, rollover, reset) {
        var date = this._monthData.getCellDate(cellIndex);
        var cell = this._getCell(cellIndex);
        if (!reset && date.day == this._date.day && date.month == this._date.month && date.year == this._date.year) {
            // Render selected
            Echo.Sync.Color.renderClear(this._dateSelectedBackground, cell, "backgroundColor");
            Echo.Sync.Color.renderClear(this._dateSelectedForeground, cell, "color");
            Echo.Sync.FillImage.render(this._dateSelectedBackgroundImage, cell);
            Echo.Sync.Border.render(this._dateSelectedBorder, cell);
        } else if (!reset && rollover) {
            // Render rollover
            Echo.Sync.Color.renderClear(this._dateRolloverBackground, cell, "backgroundColor");
            Echo.Sync.Color.renderClear(this._dateRolloverForeground, cell, "color");
            Echo.Sync.FillImage.render(this._dateRolloverBackgroundImage, cell);
            Echo.Sync.Border.render(this._dateRolloverBorder, cell);
        } else {
            if (this._monthData.isCellAdjacent(cellIndex)) {
                // Render adjacent
                Echo.Sync.Color.renderClear(this._dateAdjacentBackground, cell, "backgroundColor");
                Echo.Sync.Color.renderClear(this._dateAdjacentForeground, cell, "color");
            } else {
                // Render default
                Echo.Sync.Border.renderClear(this._dateBorder, cell);
                cell.style.backgroundImage = "";
                cell.style.backgroundColor = "";
                cell.style.color = "";
            }
        }
    },
    
    /**
     * Sets the selected date.  Updates month/year fields and animates in new month/year if required.
     * 
     * @param newValue an object providing month, day, and year numeric properties
     */
    _setDate: function(newValue) {
        var oldValue = this._date,
            oldCellIndex = this._monthData.getCellIndex(this._date.day),
            newCellIndex,
            overlap;

        this._setCellStyle(oldCellIndex, false, true);
        
        this._rangeCheck(newValue);
        this._date = newValue;

        this._monthData = new Extras.Sync.CalendarSelect.MonthData(newValue.year, newValue.month, this._firstDayOfWeek);

        if (newValue.year == oldValue.year) {
            if (newValue.month == oldValue.month) {
                // Day Change
                newCellIndex = this._monthData.getCellIndex(this._date.day);
                this._setCellStyle(newCellIndex, false);
            } else {
                // Month/Day Change
                if (oldValue.month - newValue.month == 1) {
                    // Displaying previous month.
                    overlap = this._monthData.nextMonthWeek == 4 ? 2 : 1;
                } else if (oldValue.month - newValue.month == -1) {
                    // Displaying next month.
                    var oldMonthData = new Extras.Sync.CalendarSelect.MonthData(oldValue.year, oldValue.month,
                            this._firstDayOfWeek);
                    overlap = oldMonthData.nextMonthWeek == 4 ? 2 : 1;
                } else {
                    overlap = 0;
                }
                this._animateUpdate(true, oldValue.month < newValue.month, overlap);
            }
        } else {
            // Year/Month/Day Change
            this._animateUpdate(false, oldValue.year < newValue.year);
        }
        
        this._updateMonthYearSelection();
        
        this._storeValue();
    },
    
    /**
     * Stores the selected date in the <code>Echo.Component</code> instance.
     */
    _storeValue: function() {
        this.component.set("date", new Date(this._date.year, this._date.month, this._date.day));
    },
    
    /**
     * Updates the month/year field selection values.
     */
    _updateMonthYearSelection: function() {
        if (parseInt(this._yearField.value, 10) !== this._date.year) {
            this._yearField.value = this._date.year;
        }
        if (this._monthSelect.selectedIndex != this._date.month) {
            this._monthSelect.selectedIndex = this._date.month;
        }
    }
});    
/**
 * Component rendering peer: ColorSelect.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.ColorSelect = Core.extend(Echo.Render.ComponentSync, {
    
    $static: {
    
        /**
         * Representation of an RGB color.
         */
        RGB: Core.extend({
            
            /** 
             * Red value, 0-255.
             * @type Number
             */
            r: null,
            
            /** 
             * Green value, 0-255.
             * @type Number
             */
            g: null,
            
            /** 
             * Blue value, 0-255.
             * @type Number
             */
            b: null,
        
            /**
             * Creates a new RGB color.
             * 
             * @param {Number} r the red value (0-255)
             * @param {Number} g the green value (0-255)
             * @param {Number} b the blue value (0-255)
             */
            $construct: function(r, g, b) {
                this.r = this._clean(r);
                this.g = this._clean(g);
                this.b = this._clean(b);
            },
            
            /**
             * Bounds the specified value between 0 and 255.
             * 
             * @param {Number} value a color value
             * @return the bounded value
             * @type Number  
             */
            _clean: function(value) {
                value = value ? parseInt(value, 10) : 0;
                if (value < 0) {
                    return 0;
                } else if (value > 255) {
                    return 255;
                } else {
                    return value;
                }
            },
            
            /**
             * Renders the RGB value as a hexadecimal triplet, e.g., #1a2b3c.
             * 
             * @return the hex triplet
             * @type String
             */
            toHexTriplet: function() {
                var rString = this.r.toString(16);
                if (rString.length == 1) {
                    rString = "0" + rString;
                }
                var gString = this.g.toString(16);
                if (gString.length == 1) {
                    gString = "0" + gString;
                }
                var bString = this.b.toString(16);
                if (bString.length == 1) {
                    bString = "0" + bString;
                }
                return "#" + rString + gString + bString;
            },
            
            /** @see Object#toString */
            toString: function() {
                return this.toHexTriplet();
            }
        })
    },

    $load: function() {
        Echo.Render.registerPeer("Extras.ColorSelect", this);
    },
    
    /**
     * Currently selected color hue.  Range: 0 <= h < 360.
     * @type Number
     */
    _h: 0,

    /**
     * Currently selected color saturation.  Range: 0 <= s <= 1
     * @type Number
     */
    _s: 0,

    /**
     * Currently selected color value.  Range: 0 <= v <= 1.
     * @type Number
     */
    _v: 0,

    /**
     * Method reference to _processHMouseMove.
     * @type Function
     */
    _processHMouseMoveRef: null,

    /**
     * Method reference to _processHMouseUp.
     * @type Function
     */
    _processHMouseUpRef: null,

    /**
     * Method reference to _processSVMouseMove.
     * @type Function
     */
    _processSVMouseMoveRef: null,

    /**
     * Method reference to _processSVMouseUp.
     * @type Function
     */
    _processSVMouseUpRef: null,

    $construct: function() {
        this._processHMouseMoveRef = Core.method(this, this._processHMouseMove);
        this._processHMouseUpRef = Core.method(this, this._processHMouseUp);
        this._processSVMouseMoveRef = Core.method(this, this._processSVMouseMove);
        this._processSVMouseUpRef = Core.method(this, this._processSVMouseUp);
    },
        
    /**
     * Converts an HSV color to an RGB color.
     * 
     * @param {Number} h the color hue
     * @param {Number} s the color saturation
     * @param {Number} v the color value
     * @return an RGB color
     * @type Extras.Sync.ColorSelect.RGB 
     */
    _hsvToRgb: function(h, s, v) {
        var r, g, b;
        if (s === 0) {
            r = g = b = v;
        } else {
            h /= 60;
            var i = Math.floor(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));
            switch (i) {
            case 0:  r = v; g = t; b = p; break;
            case 1:  r = q; g = v; b = p; break;
            case 2:  r = p; g = v; b = t; break;
            case 3:  r = p; g = q; b = v; break;
            case 4:  r = t; g = p; b = v; break;
            default: r = v; g = p; b = q; break;
            }
        }
        return new Extras.Sync.ColorSelect.RGB(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
    },
    
    /**
     * Processes a hue selector mouse down event.
     * 
     * @param e the event
     */
    _processHMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return;
        }
        Core.Web.Event.add(this._hListenerDiv, "mousemove", this._processHMouseMoveRef, false);
        Core.Web.Event.add(this._hListenerDiv, "mouseup", this._processHMouseUpRef, false);
        this._processHUpdate(e);
    },
    
    /**
     * Processes a hue selector mouse move event.
     * 
     * @param e the event
     */
    _processHMouseMove: function(e) {
        this._processHUpdate(e);
    },
    
    /**
     * Processes a hue selector mouse up event.
     * 
     * @param e the event
     */
    _processHMouseUp: function(e) {
        Core.Web.Event.remove(this._hListenerDiv, "mousemove", this._processHMouseMoveRef, false);
        Core.Web.Event.remove(this._hListenerDiv, "mouseup", this._processHMouseUpRef, false);
        this._storeColor();
    },
    
    /**
     * Processes a mouse event which will update the selected hue (invoked by mouse/down move events).
     * 
     * @param e the event
     */
    _processHUpdate: function(e) {
        var offset = Core.Web.DOM.getEventOffset(e);
        this._h = (this._saturationHeight - (offset.y - 7)) * 360 / this._saturationHeight;
        this._updateDisplayedColor();
    },
    
    /**
     * Processes a saturation-value selector mouse down event.
     * 
     * @param e the event
     */
    _processSVMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return;
        }
        Core.Web.Event.add(this._svListenerDiv, "mousemove", this._processSVMouseMoveRef, false);
        Core.Web.Event.add(this._svListenerDiv, "mouseup", this._processSVMouseUpRef, false);
        this._processSVUpdate(e);
    },
    
    /**
     * Processes a saturation-value selector mouse move event.
     * 
     * @param e the event
     */
    _processSVMouseMove: function(e) {
        this._processSVUpdate(e);
    },
    
    /**
     * Processes a saturation-value selector mouse up event.
     * 
     * @param e the event
     */
    _processSVMouseUp: function(e) {
        Core.Web.Event.remove(this._svListenerDiv, "mousemove", this._processSVMouseMoveRef, false);
        Core.Web.Event.remove(this._svListenerDiv, "mouseup", this._processSVMouseUpRef, false);
        this._storeColor();
    },
    
    /**
     * Processes a mouse event which will update the selected saturation/value (invoked by mouse/down move events).
     * 
     * @param e the event
     */
    _processSVUpdate: function(e) {
        var offset = Core.Web.DOM.getEventOffset(e);
        this._v = (offset.x - 7) / this._valueWidth;
        this._s = 1 - ((offset.y - 7) / this._saturationHeight);
        this._updateDisplayedColor();
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._valueWidth = Echo.Sync.Extent.toPixels(
                this.component.render("valueWidth", Extras.ColorSelect.DEFAULT_VALUE_WIDTH), true);
        this._saturationHeight = Echo.Sync.Extent.toPixels(
                this.component.render("saturationHeight", Extras.ColorSelect.DEFAULT_SATURATION_HEIGHT), false);
        this._hueWidth = Echo.Sync.Extent.toPixels(
                this.component.render("hueWidth", Extras.ColorSelect.DEFAULT_HUE_WIDTH), true);
        var displayHeight = Core.Web.Measure.extentToPixels("1em", false);
    
        var svGradientImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectSVGradient.png");
        var hGradientImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectHGradient.png");
        var arrowDownImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectArrowDown.gif");
        var arrowUpImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectArrowUp.gif");
        var arrowRightImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectArrowRight.gif");
        var arrowLeftImageSrc = this.client.getResourceUrl("Extras", "image/colorselect/ColorSelectArrowLeft.gif");
        
        // Create main container div element, relatively positioned.
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.style.cssText = "position:relative;left:0;top:0;overflow:hidden;";
        this._div.style.width = (this._valueWidth + this._hueWidth + 29) + "px";
        this._div.style.height = (this._saturationHeight + 18 + displayHeight) +"px";
        
        // Create saturation / value selector.
        this._svDiv = document.createElement("div");
        this._svDiv.style.cssText = "position:absolute;left:7px;top:7px;background-color:#ff0000";
        this._svDiv.style.width = this._valueWidth + "px";
        this._svDiv.style.height = this._saturationHeight + "px";
        this._div.appendChild(this._svDiv);
        
        if (svGradientImageSrc) {
            if (Core.Web.Env.PROPRIETARY_IE_PNG_ALPHA_FILTER_REQUIRED) {
                this._svDiv.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(" +
                        "src='" + svGradientImageSrc + "', sizingMethod='scale');";
            } else {
                var svGradientImg = document.createElement("img");
                svGradientImg.src = svGradientImageSrc;
                svGradientImg.style.width = this._valueWidth + "px";
                svGradientImg.style.height = this._saturationHeight + "px";
                this._svDiv.appendChild(svGradientImg);
            }
        }
        
        // Create container for value selecion bar.
        this._vLineDiv = document.createElement("div");
        this._vLineDiv.style.cssText = "position:absolute;left:2px;top:0;width:11px;overflow:hidden;";
        this._vLineDiv.style.height = (this._saturationHeight + 14) + "px";
        this._div.appendChild(this._vLineDiv);
    
        // Create value selection bar top arrow.
        if (arrowDownImageSrc) {
            var vLineTopImg = document.createElement("img");
            vLineTopImg.src = arrowDownImageSrc;
            vLineTopImg.style.cssText = "position:absolute;left:0;top:0;";
            this._vLineDiv.appendChild(vLineTopImg);
        }
        
        // Create value selection bar line.
        var vLineBarDiv = document.createElement("div");
        vLineBarDiv.style.cssText = "position:absolute;top:7px;left:5px;width:1px;background-color:#000000;";
        vLineBarDiv.style.height = this._saturationHeight + "px";
        this._vLineDiv.appendChild(vLineBarDiv);
    
        // Create value selection bar bottom arrow.
        if (arrowUpImageSrc) {
            var vLineBottomImg = document.createElement("img");
            vLineBottomImg.src = arrowUpImageSrc;
            vLineBottomImg.style.cssText = "position:absolute;left:0;";
            vLineBottomImg.style.top = (this._saturationHeight + 7) + "px";
            this._vLineDiv.appendChild(vLineBottomImg);
        }
        
        // Create saturation selection bar container.
        this._sLineDiv = document.createElement("div");
        this._sLineDiv.style.cssText = "position:absolute;left:0;height:11px;overflow:hidden;";
        this._sLineDiv.style.top = (this._saturationHeight + 2) + "px";
        this._sLineDiv.style.width = (this._valueWidth + 14) + "px";
        this._div.appendChild(this._sLineDiv);
        
        // Create saturation selection bar left arrow.
        if (arrowRightImageSrc) {
            var sLineLeftImg = document.createElement("img");
            sLineLeftImg.src = arrowRightImageSrc;
            sLineLeftImg.style.cssText = "position:absolute;left:0;top:0;";
            this._sLineDiv.appendChild(sLineLeftImg);
        }
        
        // Create saturation selection bar line.
        var sLineBarDiv = document.createElement("div");
        sLineBarDiv.style.cssText = 
                "position:absolute;left:7px;top:5px;height:1px;font-size:1px;border-top:1px #000000 solid;line-height:0;";
        sLineBarDiv.style.width = this._valueWidth + "px";
        this._sLineDiv.appendChild(sLineBarDiv);
    
        // Create saturation selection bar right arrow.
        if (arrowLeftImageSrc) {
            var sLineRightImg = document.createElement("img");
            sLineRightImg.src = arrowLeftImageSrc;
            sLineRightImg.style.cssText = "position:absolute;top:0;";
            sLineRightImg.style.left = this._valueWidth + 7 + "px";
            this._sLineDiv.appendChild(sLineRightImg);
        }
        
        // Create hue selector.
        var hDiv = document.createElement("div");
        hDiv.style.cssText = "position:absolute;top:7px;";
        hDiv.style.left = (this._valueWidth + 22) + "px";
        hDiv.style.width = this._hueWidth + "px";
        hDiv.style.height = this._saturationHeight + "px";
        this._div.appendChild(hDiv);
    
        if (hGradientImageSrc) {
            var hGradientImg = document.createElement("img");
            hGradientImg.src = hGradientImageSrc;
            hGradientImg.style.cssText = "position:absolute;left:0;top:0;";
            hGradientImg.style.width = this._hueWidth + "px";
            hGradientImg.style.height = this._saturationHeight + "px";
            hDiv.appendChild(hGradientImg);
        }
        
        this._hLineDiv = document.createElement("div");
        this._hLineDiv.style.cssText = "position:absolute;height:11px;overflow:hidden;";
        this._hLineDiv.style.left = (this._valueWidth + 15) + "px";
        this._hLineDiv.style.top = (this._saturationHeight + 2) + "px";
        this._hLineDiv.style.width = (this._hueWidth + 14) + "px";
        this._div.appendChild(this._hLineDiv);
        
        if (arrowRightImageSrc) {
            var hLineLeftImg = document.createElement("img");
            hLineLeftImg.src = arrowRightImageSrc;
            hLineLeftImg.style.cssText = "position:absolute;left:0;top:0;";
            this._hLineDiv.appendChild(hLineLeftImg);
        }
    
        if (arrowLeftImageSrc) {
            var hLineRightImg = document.createElement("img");
            hLineRightImg.src = arrowLeftImageSrc;
            hLineRightImg.style.cssText = "position:absolute;top:0;";
            hLineRightImg.style.left = (this._hueWidth + 7) + "px";
            this._hLineDiv.appendChild(hLineRightImg);
        }
        
        var hLineBarDiv = document.createElement("div");
        hLineBarDiv.style.cssText =
                "position:absolute;left:7px;top:5px;height:1px;font-size:1px;border-top:1px #000000 solid;line-height:0;";
        hLineBarDiv.style.width = this._hueWidth + "px";
        this._hLineDiv.appendChild(hLineBarDiv);
        
        this._colorDiv = document.createElement("div");
        this._colorDiv.style.cssText = 
                "position:absolute;left:7px;color:#ffffff;background-color:#000000;text-align:center;vertical-align:middle;" +
                "overflow:hidden;border:1px #000000 outset;font-family:monospace;text-align:center;";
        this._colorDiv.style.height = displayHeight + "px";
        this._colorDiv.style.top = (this._saturationHeight + 16) + "px";
        this._colorDiv.style.width = (this._valueWidth + this._hueWidth + 13) + "px";
        if (this.component.render("displayValue")) {
            this._colorDiv.appendChild(document.createTextNode("#000000"));
        }
        this._div.appendChild(this._colorDiv);
        
        this._svListenerDiv = document.createElement("div");
        this._svListenerDiv.style.cssText = "position:absolute;z-index:1;left:0;top:0;cursor:crosshair;";
        this._svListenerDiv.style.width = (this._valueWidth + 14) + "px";
        this._svListenerDiv.style.height = (this._saturationHeight + 14) + "px";
        this._svListenerDiv.style.backgroundImage = "url(" +
                this.client.getResourceUrl("Echo", "resource/Transparent.gif") + ")";
        this._div.appendChild(this._svListenerDiv);
        
        this._hListenerDiv = document.createElement("div");
        this._hListenerDiv.style.cssText = "position:absolute;z-index:1;top:0;cursor:crosshair;";
        this._hListenerDiv.style.left = (this._valueWidth + 15) + "px";
        this._hListenerDiv.style.width = (this._hueWidth + 14) + "px";
        this._hListenerDiv.style.height = (this._saturationHeight + 16) + "px";
        this._hListenerDiv.style.backgroundImage = "url(" +
                this.client.getResourceUrl("Echo", "resource/Transparent.gif") + ")";
        this._div.appendChild(this._hListenerDiv);
    
        parentElement.appendChild(this._div);
        
        Core.Web.Event.add(this._svListenerDiv, "mousedown", Core.method(this, this._processSVMouseDown), false);
        Core.Web.Event.add(this._hListenerDiv, "mousedown", Core.method(this, this._processHMouseDown), false);
        this._setColor(this.component.get("color"));
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) { 
        Core.Web.Event.removeAll(this._svListenerDiv);
        Core.Web.Event.removeAll(this._hListenerDiv);
        this._div = null;
        this._svDiv = null;
        this._svListenerDiv = null;
        this._hListenerDiv = null;
        this._hLineDiv = null;
        this._sLineDiv = null;
        this._vLineDiv = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var div = this._div;
        var parentElement = div.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        parentElement.removeChild(div);
        this.renderAdd(update, parentElement);
        return false;
    },
    
    /**
     * Sets the selected color.
     *
     * @param rgb the color to select as an 24 bit hexadecimal string color value
     * @private
     */
    _setColor: function(color) {
        var r, g, b;
        
        if (color) {
            // Remove leading #.
            color = color.substring(1); 
            r = Math.floor(parseInt(color, 16) / 0x10000) / 255;
            g = (Math.floor(parseInt(color, 16) / 0x100) % 0x100) / 255;
            b = (parseInt(color, 16) % 0x100) / 255;
        } else {
            r = g = b = 0;
        }
        
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        this._v = max;
        
        var delta = max - min;
        if (max === 0 || delta === 0) {
            this._s = 0;
        } else {
            this._s = delta / max;
            if (r == max) {
                this._h = 60 * ((g - b) / delta);
            } else if (g == max) {
                this._h = 60 * (2 + (b - r) / delta);
            } else {
                this._h = 60 * (4 + (r - g) / delta);
            }
            if (this._h < 0) {
                this._h += 360;
            }
        }


        this._updateDisplayedColor();
    },
    
    /**
     * Stores color value in _h, _s, and _v in the component object.
     * @private
     */
    _storeColor: function() {
        var renderColor = this._hsvToRgb(this._h, this._s, this._v);
        var renderHexTriplet = renderColor.toHexTriplet();
        this.component.set("color", renderHexTriplet);
    },
    
    /**
     * Updates the displayed color.
     */
    _updateDisplayedColor: function() {
        var baseColor;
        if (this.component.isRenderEnabled()) {
            baseColor = this._hsvToRgb(this._h, 1, 1);
        } else {
            // Use a dull base color to enable a disabled effect.
            baseColor = this._hsvToRgb(this._h, 0.3, 0.7);
        }
        this._svDiv.style.backgroundColor = baseColor.toHexTriplet();
    
        var renderColor = this._hsvToRgb(this._h, this._s, this._v);
        
        var renderHexTriplet = renderColor.toHexTriplet();
        this._colorDiv.style.backgroundColor = renderHexTriplet;
        this._colorDiv.style.borderColor = renderHexTriplet;
        this._colorDiv.style.color = this._v < 0.67 ? "#ffffff" : "#000000";
        if (this.component.render("displayValue")) {
            this._colorDiv.childNodes[0].nodeValue = renderHexTriplet;
        }
        
        var sLineTop = Math.floor((1 - this._s) * this._saturationHeight) + 2;
        if (sLineTop < 2) {
             sLineTop = 2;
        } else if (sLineTop > this._saturationHeight + 2) {
            sLineTop = this._saturationHeight + 2;
        }
        this._sLineDiv.style.top = sLineTop + "px";
        
        var vLineLeft = Math.floor(this._v * this._valueWidth) + 2;
        if (vLineLeft < 2) {
            vLineLeft = 2;
        } else if (vLineLeft > this._valueWidth + 2) {
            vLineLeft = this._valueWidth + 2;
        }
        this._vLineDiv.style.left = vLineLeft + "px";
        
        var hLineTop = Math.floor((360 - this._h) / 360 * this._saturationHeight) + 2;
        if (hLineTop < 2) {
            hLineTop = 2;
        } else if (hLineTop > this._saturationHeight + 2) {
            hLineTop = this._saturationHeight + 2;
        }
        this._hLineDiv.style.top = hLineTop + "px";
    }
});

/**
 * Component rendering peer: DataGrid.
 * This class should not be extended by developers, the implementation is subject to change.
 *
 * This is an EXPERIMENTAL component, it should not be used at this point for any purpose other than testing it.
 */
Extras.Sync.DataGrid = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Extras.DataGrid", this);
    },
    
    $static: {
                
        /**
         * Horizontal/Vertical constant for left direction.
         */
        LEFT: { h: -1, v: 0 },
        
        /**
         * Horizontal/Vertical constant for right direction.
         */
        RIGHT: { h: 1, v: 0 },
        
        /**
         * Horizontal/Vertical constant for up direction.
         */
        UP: { h: 0, v: -1 },

        /**
         * Horizontal/Vertical constant for down direction.
         */
        DOWN: { h: 0, v: 1 },

        REGION_LOCATIONS: {
            topLeft:     { h: -1, v: -1 },
            top:         { h:  0, v: -1 },
            topRight:    { h:  1, v: -1 },
            left:        { h: -1, v:  0 },
            center:      { h:  0, v:  0 },
            right:       { h:  1, v:  0 },
            bottomLeft:  { h: -1, v:  1 },
            bottom:      { h:  0, v:  1 },
            bottomRight: { h:  1, v:  1 }
        },
        
        /**
         * Determines if two segments in a line share any points.
         *
         * @param {Number} a1 first point of segment A
         * @param {Number} a2 second point of segment A
         * @param {Number} b1 first point of segment B
         * @param {Number} b2 second point of segment B
         * @return true if the segments share any points
         */
        intersect: function(a1, a2, b1, b2) {
            return (b1 <= a1 && a1 <= b2) || (a1 <= b1 && b1 <= a2);
        },
        
        /**
         * Abstract base class for cell renderers.
         */
        CellRenderer: Core.extend({
            
            $abstract: {
            
                /**
                 * Returns an HTML representation of a DataGrid cell.
                 * 
                 * @param {Extras.Sync.DataGrid.RenderContext} context contextual information
                 *        (provides reference to DataGrid instance, capabilities to get/set state object for cell)
                 * @param value the value provided by the model
                 * @param {Number} column the column index
                 * @param {Number} row the row index 
                 * 
                 * @return a rendered node which should be added to the DOM in the cell (may return null)
                 * @type Node
                 */
                render: function(context, value, column, row) { }
            },
            
            $virtual: {

                /**
                 * Optional disposal method to deallocate resources used by a rendered DataGrid cell.
                 * May be used for purposes such as unregistering listeners on interactive cell renderings.
                 * A state object must have been set in the RenderContext in order for this method to be invoked.
                 * 
                 * @param {Extras.Sync.DataGrid.RenderContext} context contextual information
                 *        (provides reference to DataGrid instance, capabilities to get/set state object for cell) 
                 * @param {Number} column
                 * @param {Number} row 
                 */
                dispose: null
            }
        }),
        
        /**
         * Contextual data used by cell renderers.
         * Provides capability to get/set state of cell, access to DataGrid instance.
         * RenderContexts are created and disposed with tiles.
         */
        RenderContext: Core.extend({
            
            _states: null,
            
            /**
             * The relevant DataGrid.
             * @type Extras.DataGrid
             */
            dataGrid: null,
            
            /**
             * Creates a new RenderContext.
             * 
             * @param {Extras.DataGrid} dataGrid the relevant DataGrid.
             */
            $construct: function(dataGrid) {
                this.dataGrid = dataGrid;
                this._states = {};
            },
            
            /**
             * Invoked by the tile when it is disposed.  Should never be manually invoked.
             */
            dispose: function() {
                for (var x in this._states) {
                    //FIXME implement cell disposal
                }
            },
            
            /**
             * Retrieves the state object for a rendered cell.
             * 
             * @param {Number} column the cell column index
             * @param {Number} row the cell row index 
             * @return the state object
             */
            getState: function(column, row) {
                return this._states[column + "," + row];
            },
            
            /**
             * Sets the state object for a rendered cell.
             * State objects are arbitrary renderer-defined objects containing state information about a cell.
             * A typical use for a state object would be for an interactive cell to store elements such that listeners 
             * may be removed from them when a cell is disposed.
             * 
             * @param {Number} column the cell column index
             * @param {Number} row the cell row index
             * @param state the state object, an arbitrary renderer-defined object containing state information about the
             *        cell  
             */
            setState: function(column, row, state) {
                this._states[column + "," + row] = state;
            }
        }),

        /**
         * Representation of a "tile", a sub-table that renders a portion of the DataGrid.
         * Tiles are contained within Regions.
         */
        Tile: Core.extend({
            
            /** 
             * The containing DataGrid instance. 
             * @type Extras.Sync.DataGrid
             */
            dataGrid: null,
            
            /** 
             * Flag indicating whether the tile is displayed. 
             * @type Boolean
             */
            displayed: false,
            
            /** 
             * The div element.  Outermost element of a tile, contains the <code>_table</code> element as its only child.
             * @type Element
             */
            div: null,
            
            /** 
             * The table element.  Contained within the <code>div</code> element.
             * @type Element
             */
            _table: null,
            
            /** 
             * The region containing the tile. 
             * @type Extras.Sync.DataGrid.Region
             */
            region: null,
            
            /**
             * Edge information object.  Contains boolean "top", "right", "left", and "bottom" properties, 
             * each of which evaluates to true if the tile is at that extreme edge.
             */
            edge: null,
            
            /**
             * Cell index information object.  Contains integer "top", "right", "left", and "bottom" properties, 
             * each of which indicates the index of cells at that edge of the tile.  
             *
             * As an example, if the DataGrid's tile size were 12 columns by 6 rows, then for the tile in the second column 
             * of the second row, this value would be { top: 6, left: 12, bottom: 11, right: 23 } assuming that the the data 
             * grid had at least  12 rows and 24 columns.  If the data grid only had 9 rows and 18 columns, this value would 
             * be { top: 6, left: 12, bottom: 8, right: 17 }.
             */
            cellIndex: null,
            
            /**
             * Tile index information object.  Contains row and column properties indicating the row/column of the tile
             * within the grid of tiles.  The upper left tile would be at column 0, row 0.  The tile to the right would 
             * be at column 1, row 0.
             */
            tileIndex: null,

            /**
             * The rendered bounds of the tile.  Contains "top", "left", "width", and "height" properties describing
             * rendered bounds of the tile.  Initialized when the tile is displayed.
             */
            bounds: null,
            
            /**
             * The RenderContext instance specific to this tile.
             * @type Extras.Sync.DataGrid.RenderContext
             */
            _renderContext: null,
            
            /**
             * Creates a new <code>Tile</code>.
             *
             * @param {Extras.Sync.DataGrid} dataGrid the containing data grid peer
             * @param {Extras.Sync.DataGrid.Region} region the containing region
             * @param {Number} tileColumnIndex the column index of the tile
             * @param {Number} tileRowIndex the row index of the tile
             */
            $construct: function(dataGrid, region, tileColumnIndex, tileRowIndex) {
                this.dataGrid = dataGrid;
                this._renderContext = new Extras.Sync.DataGrid.RenderContext(dataGrid);
                this.containerElement = region.element;
                this.tileIndex = { column: tileColumnIndex, row: tileRowIndex };
                this.region = region;
                
                this.edge = { 
                    left: this.tileIndex.column === 0,
                    top: this.tileIndex.row === 0
                };
                
                this.cellIndex = { };
                
                // Determine horizontal data.
                switch (this.region.location.h) {
                case -1:
                    this.cellIndex.left = this.tileIndex.column * this.dataGrid.tileSize.columns;
                    this.cellIndex.right = this.cellIndex.left + this.dataGrid.tileSize.columns - 1;
                    if (this.cellIndex.right >= this.dataGrid.fixedCells.left) {
                        this.cellIndex.right = this.dataGrid.fixedCells.left - 1;
                        this.edge.right = true;
                    }
                    break;
                case 0: 
                    this.cellIndex.left = this.tileIndex.column * this.dataGrid.tileSize.columns + this.dataGrid.fixedCells.left;
                    this.cellIndex.right = this.cellIndex.left + this.dataGrid.tileSize.columns - 1;
                    if (this.cellIndex.right >= this.dataGrid.size.columns - this.dataGrid.fixedCells.right - 1) {
                        this.cellIndex.right = this.dataGrid.size.columns - this.dataGrid.fixedCells.right - 1;
                        this.edge.right = true;
                    }
                    break;
                case 1:
                    this.cellIndex.left = this.dataGrid.size.columns - this.dataGrid.fixedCells.right - 
                            (this.tileIndex.column * this.dataGrid.tileSize.columns);
                    this.cellIndex.right = this.cellIndex.left + this.dataGrid.tileSize.columns - 1;
                    if (this.cellIndex.right >= this.dataGrid.size.columns - 1) {
                        this.cellIndex.right = this.dataGrid.size.columns - 1;
                        this.edge.right = true;
                    }
                    break;
                }
                
                // Determine vertical data.
                switch (this.region.location.v) {
                case -1:
                    this.cellIndex.top = this.tileIndex.row * this.dataGrid.tileSize.rows;
                    this.cellIndex.bottom = this.cellIndex.top + this.dataGrid.tileSize.rows - 1;
                    if (this.cellIndex.bottom >= this.dataGrid.fixedCells.top) {
                        this.cellIndex.bottom = this.dataGrid.fixedCells.top - 1;
                        this.edge.bottom = true;
                    }
                    break;
                case 0: 
                    this.cellIndex.top = this.tileIndex.row * this.dataGrid.tileSize.rows + this.dataGrid.fixedCells.top;
                    this.cellIndex.bottom = this.cellIndex.top + this.dataGrid.tileSize.rows - 1;
                    if (this.cellIndex.bottom >= this.dataGrid.size.rows - this.dataGrid.fixedCells.bottom - 1) {
                        this.cellIndex.bottom = this.dataGrid.size.rows - this.dataGrid.fixedCells.bottom - 1;
                        this.edge.bottom = true;
                    }
                    break;
                case 1:
                    this.cellIndex.top = this.dataGrid.size.rows - this.dataGrid.fixedCells.bottom - 
                            (this.tileIndex.row * this.dataGrid.tileSize.rows);
                    this.cellIndex.bottom = this.cellIndex.top + this.dataGrid.tileSize.rows - 1;
                    if (this.cellIndex.bottom >= this.dataGrid.size.rows - 1) {
                        this.cellIndex.bottom = this.dataGrid.size.rows - 1;
                        this.edge.bottom = true;
                    }
                    break;
                }

            },
            
            /**
             * Adjusts the position of the tile.
             * Has no effect in directions in which the cell is fixed (per region location property).
             *
             * @param {Number} h the number of pixels to adjust the tile horizontally
             * @param {Number} v the number of pixels to adjust the tile vertically
             */
            adjustPositionPx: function(h, v) {
                if (this.div) {
                    if (h && !this.region.location.h) {
                        this.bounds.left += h;
                        this.div.style.left = this.bounds.left + "px";
                    }
                    if (v && !this.region.location.v) {
                        this.bounds.top += v;
                        this.div.style.top = this.bounds.top + "px";
                    }
                }
                
                if (!this.isOnScreen()) {
                    this.remove();
                }
            },
            
            /**
             * Renders the tile.  Sets the div and _table element properties, measures rendered tile and sets
             * bounds property.
             */
            create: function() {
                var tr, td, row, column;

                var columnWidths = [];
                
                this.bounds = { };
                
                this.bounds.width = 0;
                for (column = this.cellIndex.left; column <= this.cellIndex.right; ++column) {
                    this.bounds.width += columnWidths[column] = this.dataGrid._getColumnWidth(column);
                }

                this.div = document.createElement("div");
                this.div.style.cssText = "position:absolute;";

                this._table = this.dataGrid.getPrototypeTable().cloneNode(true);
                this._table.style.width = this.bounds.width + "px";

                this.div.appendChild(this._table);

                for (row = this.cellIndex.top; row <= this.cellIndex.bottom; ++row) {
                    tr = document.createElement("tr");
                    for (column = this.cellIndex.left; column <= this.cellIndex.right; ++column) {
                        td = document.createElement("td");
                        td.style.padding = 0;
                        Echo.Sync.Border.render(this.dataGrid._cellBorder, td);
                        if (row === this.cellIndex.top) {
                            td.style.width = columnWidths[column] + "px";
                        }
                        var value = this.dataGrid._model.get(column, row);
                        if (value == null) {
                            // FIXME Temporary fix for zero-height cells causing rendering to take forever.
                            // Remove when bounding is working properly.
                            value = "\u00a0";
                        }
                        td.appendChild(document.createTextNode(value));
                        tr.appendChild(td);
                    }
                    this._table.firstChild.appendChild(tr);
                }
                
                this.bounds.height = new Core.Web.Measure.Bounds(this.div).height;
                
                this.div.style.width = this.bounds.width + "px";
            },
            
            /**
             * Displays the tile at the specified coordinates.
             * Does nothing if the tile is already displayed.
             *
             * @param {Number} left the left pixel coordinate of the tile within the region
             * @param {Number} top the top pixel coordinate of the tile within the region
             */
            display: function(left, top) {
                if (this.displayed) {
                    return;
                }
                if (!this.div) {
                    this.create();
                }
                this.bounds.top = top;
                this.bounds.left = left;
                this.div.style.top = top + "px";
                this.div.style.left = left + "px";
                
                this.containerElement.appendChild(this.div);
                this.displayed = true;
            },
            
            /**
             * Disposes resources used by the tile.
             * Must be invoked before the tile is discarded.
             */
            dispose: function() {
                this._renderContext.dispose();
                this.div = this._table = null;
            },
            
            /**
             * Determines if this tile is currently covering the bottom edge of the screen (pixel 0).
             */ 
            isEdgeBottom: function() {
                return this.edge.bottom || (this.bounds.top < this.region.bounds.height && 
                        this.bounds.top + this.bounds.height >= this.region.bounds.height);
            },
            
            /**
             * Determines if this tile is currently covering the left edge of the screen (pixel 0).
             */ 
            isEdgeLeft: function() {
                return this.edge.left || this.tileIndex.column === 0 || 
                        (this.bounds.left <= 0 && this.bounds.left + this.bounds.width > 0);
            },
            
            /**
             * Determines if this tile is currently covering the left edge of the screen (pixel 0).
             */ 
            isEdgeRight: function() {
                return this.edge.right || (this.bounds.left < this.region.bounds.width && 
                        this.bounds.left + this.bounds.width >= this.region.bounds.width);
            },
            
            /**
             * Determines if this tile is currently covering the top edge of the screen (pixel 0).
             */ 
            isEdgeTop: function() {
                return this.edge.top || this.tileIndex.row === 0 || 
                        (this.bounds.top <= 0 && this.bounds.top + this.bounds.height > 0);
            },
        
            /**
             * Determines if any portion of this tile is currently on screen.
             */
            isOnScreen: function() {
                if (!this.displayed) {
                    return false;
                }
                return Extras.Sync.DataGrid.intersect(this.bounds.left, this.bounds.left + this.bounds.width,
                        0, this.region.bounds.width) &&
                        Extras.Sync.DataGrid.intersect(this.bounds.top, this.bounds.top + this.bounds.height,
                        0, this.region.bounds.height);
            },

            /**
             * Disposes of resources used by the tile.
             */
            remove: function() {
                if (this.displayed) {
                    this.div.parentNode.removeChild(this.div);
                    this.displayed = false;
                }
            },
            
            /** @see Object#toString */
            toString: function() {
                return "Tile (" + this.tileIndex.column + "," + this.tileIndex.row + ")";
            }
        }),
        
        /**
         * Represents a region of the DataGrid.  A DataGrid may have up to nine regions, arranged as three
         * rows and three columns.  Regions in the center row can be vertically scrolled, while the top and bottom rows
         * are vertically fixed.  Regions in the center column can be horizontally scrolled , while the left and right
         * columns are horizontally fixed.
         */
        Region: Core.extend({

            /**
             * The containing Extras.Sync.DataGrid instance.
             * @type Extras.Sync.DataGrid
             */
            dataGrid: null,
            
            /**
             * Object containing all <code>Tile</code> instances held within the region.
             * This object maps tile row indices to tile column maps.
             * The tile column maps map column indices to actual tiles.
             * The indices used are the indices of tiles, not the indices of the cells they contain.
             * This object is organized like a two dimensional array, with rows as the first dimension and columns as the seccond,
             * e.g., requesting _tiles[4][2] would return the tile at row 4 (the fifth row) and column 2 (the third column).
             * Before making such a query one would have to ensure that _tiles[4] is defined.
             */
            _tiles: null,
            
            /**
             * 
             */
            bounds: null,

            /**
             * The region name one of the following values: 
             * topLeft, top, topRight, left, center, right, bottomLeft, bottom, bottomRight
             * @type String
             */
            name: null,
            
            /** 
             * The location of the region, an object containing h and v properties.
             * These h and v properties may have values of -1, 0, or 1.
             * A value of 0 indicates center, -1 indicates left/top, 1 indicates right/bottom.
             */
            location: null,
            
            /**
             * Creates a new Region.
             *
             * @param {Extras.Sync.DataGrid} dataGrid the containing data grid synchronization peer
             * @param {String} name the region name, one of the following values: 
             *        topLeft, top, topRight, left, center, right, bottomLeft, bottom, bottomRight
             */
            $construct: function(dataGrid, name) {
                this.dataGrid = dataGrid;
                this.name = name;
                this._tiles = { };
                this.location = Extras.Sync.DataGrid.REGION_LOCATIONS[name];

                this.element = document.createElement("div");
                this.element.style.cssText = "position:absolute;overflow:hidden;";
                
                if (this.location.h === -1) {
                    this.element.style.left = 0;
                } else if (this.location.h === 1) {
                    this.element.style.right = 0;
                }
                if (this.location.v === -1) {
                    this.element.style.top = 0;
                } else if (this.location.h === 1) {
                    this.element.style.bottom = 0;
                }
            },

            /**
             * Adjusts the positions of tiles within the region, additionally filling in any areas that become
             * unoccupied as a result of the adjustment.
             *
             * @param {Number} x the number of horizontal pixels to shift the tiles (positive values indicate to the right)
             * @param {Number} y the number of vertical pixels to shift the tiles (positive values indicate downward)
             */
            adjustPositionPx: function(x, y) {
                if (this.location.h && this.location.y) {
                    // This operation has no effect on corner tiles.
                    return;
                }
            
                x = this.location.h ? 0 : x;
                y = this.location.v ? 0 : y;
                var row, tile;
                for (var rowIndex in this._tiles) {
                    row = this._tiles[rowIndex];
                    for (var columnIndex in row) {
                        tile = row[columnIndex];
                        tile.adjustPositionPx(x, y);
                    }
                }
                this.fill(y > 0);
            },
            
            /**
             * Clears the region of tiles, removing/disposing all tile objects in the process.
             */
            clear: function() {
                for (var rowIndex in this._tiles) {
                    var row = this._tiles[rowIndex];
                    for (var columnIndex in row) {
                        var tile = row[columnIndex];
                        tile.remove();
                        tile.dispose();
                    }
                }
                this._tiles = { };
            },

            /**
             * Displays a tile immediately adjacent to a tile.
             *
             * @param {Echo.Sync.DataGrid.Tile} tile the origin tile
             * @param direction the adjacent direction, one of the following values (defined in Extras.Sync.DataGrid):
             *        <ul>
             *         <li><code>LEFT</code></li>
             *         <li><code>RIGHT</code></li>
             *         <li><code>UP</code></li>
             *         <li><code>DOWN</code></li>
             *        </ul>
             * @return the adjacent tile
             * @type Echo.Sync.DataGrid.Tile
             */
            displayTileAdjacent: function(tile, direction) {
                if (!tile.displayed) {
                    throw new Error("Tile not displayed, cannot position adjacent tile: " + tile);
                }
                
                var adjacentTile = this.getTile(tile.tileIndex.column + direction.h, tile.tileIndex.row + direction.v);
                if (adjacentTile == null) {
                    return null;
                }
                adjacentTile.display(tile.bounds.left + (tile.bounds.width * direction.h), 
                        tile.bounds.top + (tile.bounds.height * direction.v));
                return adjacentTile;
            },
            
            /**
             * Ensures the region is filled with content.  Invoked after the viewport has been scrolled.
             *
             * @param {Boolean} fromBottom flag indicating whether filling should start from the bottom (true) or top (false)
             */
            fill: function(fromBottom) {
                // Find top/bottommost tile.
                var originTile = this._findVerticalEdgeTile(fromBottom);

                // Move left, displaying tiles until left edge tile is reached.
                while (!originTile.isEdgeLeft()) {
                    originTile = this.displayTileAdjacent(originTile, Extras.Sync.DataGrid.LEFT);
                }
                
                if (originTile == null) {
                    //FIXME impl.
                    alert("FIXME...can't find origin tile, scenario not handled yet.");
                } else {
                    do {
                        // Move right.
                        var tile = originTile;
                        while (tile.isOnScreen() && !tile.isEdgeRight()) {
                            tile = this.displayTileAdjacent(tile, Extras.Sync.DataGrid.RIGHT);
                        }
                        
                        // Move down/up.
                        originTile = this.displayTileAdjacent(originTile, fromBottom ? 
                                Extras.Sync.DataGrid.UP : Extras.Sync.DataGrid.DOWN);
                    } while (originTile != null && originTile.isOnScreen());
                }
            },
            
            /**
             * Finds the topmost or bottommost tile that is on screen.  The found tile may be anywhere in the row.
             *
             * @param {Boolean} bottom flag indicating whether topmost (false) or bottommost (true) tile should be returned
             */
            _findVerticalEdgeTile: function(bottom) {
                var row, tile, topRowIndex = null, rowIndex;
                for (rowIndex in this._tiles) {
                    if (topRowIndex == null || (bottom ? (rowIndex > topRowIndex) : (rowIndex < topRowIndex))) {
                        row = this._tiles[rowIndex];
                        for (var columnIndex in row) {
                            if (row[columnIndex].isOnScreen()) {
                                tile = row[columnIndex];
                                topRowIndex = rowIndex;
                                break;
                            }
                        }
                    }
                }
                return tile;
            },
            
            getTile: function(columnIndex, rowIndex) {
                if (columnIndex < 0 || rowIndex < 0 ||
                        rowIndex > this.dataGrid.size.rows / this.dataGrid.tileSize.rows ||
                        columnIndex > this.dataGrid.size.columns / this.dataGrid.tileSize.columns) {
                    return null;
                }
                var cachedRow = this._tiles[rowIndex];
                if (!cachedRow) {
                    cachedRow = { };
                    this._tiles[rowIndex] = cachedRow;
                }

                var tile = cachedRow[columnIndex];
                if (!tile) {
                    tile = new Extras.Sync.DataGrid.Tile(this.dataGrid, this, columnIndex, rowIndex);
                    cachedRow[columnIndex] = tile;
                }
                return tile;
            },

            /**
             * Sets the position of the region.  Invocation will clear all existing tiles.
             *
             * @param {Number} x the horizontal position of the region
             * @param {Number} y the vertical position of the region
             */
            setPosition: function(x, y) {
                var tileRowIndex, tileColumnIndex, initTileColumnIndex,
                    cursorXPx, cursorYPx, tile;

                this.clear();
                
                initTileColumnIndex = Math.floor(x / this.dataGrid.tileSize.columns);
                tileRowIndex = Math.floor(y / this.dataGrid.tileSize.rows);

                cursorYPx = 0;
                while (cursorYPx < this.bounds.height) {
                    tileColumnIndex = initTileColumnIndex;
                    cursorXPx = 0;
                    while (cursorXPx < this.bounds.width) {
                        tile = this.getTile(tileColumnIndex, tileRowIndex);
                        tile.display(cursorXPx, cursorYPx);
                        if (tile.isEdgeRight()) {
                            break;
                        }
                        cursorXPx += tile.bounds.width;
                        ++tileColumnIndex;
                    }
                    if (tile.isEdgeBottom()) {
                        break;
                    }
                    cursorYPx += tile.bounds.height;
                    ++tileRowIndex;
                }
            },
            
            /**
             * Updates the rendered bounds of the region.  The values passed always indicate the pixel bounds of the
             * center region of the DataGrid.
             *
             * @param {Number} left the offset from the left edge of the DataGrid to the left edge of the center region
             * @param {Number} top the offset from the top edge of the DataGrid to the top edge of the center region
             * @param {Number} right the offset from the right edge of the DataGrid to the right edge of the center region
             * @param {Number} bottom the offset from the bottom edge of the DataGrid to the bottom edge of the center region
             */
            updateBounds: function(left, top, right, bottom) {
                this.bounds = { };
                switch (this.location.h) {
                case -1: 
                    this.element.style.width = left + "px"; 
                    this.bounds.width = left;
                    break;
                case  0: 
                    this.element.style.left = left + "px"; 
                    this.element.style.right = right + "px"; 
                    this.bounds.width = this.dataGrid.scrollContainer.bounds.width - left - right;
                    break;
                case  1: 
                    this.element.style.width = right + "px"; 
                    this.bounds.width = right;
                    break;
                }
                switch (this.location.v) {
                case -1: 
                    this.element.style.height = top + "px"; 
                    this.bounds.height = top;
                    break;
                case  0: 
                    this.element.style.top = top + "px"; 
                    this.element.style.bottom = bottom + "px"; 
                    this.bounds.height = this.dataGrid.scrollContainer.bounds.height - top - bottom;
                    break;
                case  1: 
                    this.element.style.height = bottom + "px"; 
                    this.bounds.height = bottom;
                    break;
                }
            }
        })
    },
    
    /**
     * Number of rows per tile.  The last tile may have fewer rows.
     */
    tileSize: {
        columns: 12,
        rows: 6
    },
    
    _fullRenderRequired: null,
    
    /**
     * Root DIV element of rendered component.
     */ 
    _div: null,
    
    /**
     * Current displayed index position.  Contains x and y numeric properties.
     */
    position: null,
    
    regions: null,
    
    /**
     * Data model.
     */ 
    _model: null,

    /**
     * Size of grid in rows and columns.  Contains numeric rows and columns properties.
     */
    size: null,
    
    /**
     * Number of fixed cells in left, top, right, and bottom sides of the DataGrid.
     * Contains numeric left, top, right, and bottom properties.
     */
    fixedCells: null,
    
    fixedCellSizes: null,
    
    /**
     * The ScrollContainer.
     */
    scrollContainer: null,
    
    $construct: function() {
        this._div = null;
        this.position = { x: 0, y: 0 };
    },
    
    _adjustIndexByPx: function(px, horizontal) {
        if (px === 0) {
            return;
        }
        
        var index = horizontal ? this.position.x : this.position.y,
            dist = Math.abs(px),
            inc = px < 0 ? 1 : -1,
            value = 0,
            getSize = horizontal ? this._getColumnWidth : this._getRowHeight;
           
Core.Debug.consoleWrite("px=" + px);        
        while (value < dist) {
            var size = getSize(index);
            if (value + size > dist) {
Core.Debug.consoleWrite("dist-value = " + (dist - value)); 
                index += inc * ((dist - value) / size); 
                value = dist;
            } else {
                value += size;
                index += inc;
            }
        }
        
        if (horizontal) {
            this.position.x = index;
        } else {
            this.position.y = index;
        }

Core.Debug.consoleWrite("Position: " + Core.Debug.toString(this.position));
    },
    
    adjustPositionPx: function(xPx, yPx) {
        // FIXME Temporary bounds restrictions.
        if (this.position.x < 0 && xPx > 0) {
            xPx = 0;
        }
        if (this.position.y < 0 && yPx > 0) {
            yPx = 0;
        }
        
        this._adjustIndexByPx(xPx, true);
        this._adjustIndexByPx(yPx, false);
        
        Core.Debug.consoleWrite(Core.Debug.toString(this.position));
        
        for (var name in this.regions) {
            this.regions[name].adjustPositionPx(xPx, yPx);
        }
        
        this.scrollContainer.setPosition(this.position.x / this.size.columns, this.position.y / this.size.rows);
        
        Core.Debug.consoleWrite("ScrollPos: " + (this.position.y / this.size.rows));
    },

    _createRegions: function() {
        this.regions = { };
    
        if (this.fixedCells.top) {
            if (this.fixedCells.left) {
                this.regions.topLeft = new Extras.Sync.DataGrid.Region(this, "topLeft");
            }
            this.regions.top = new Extras.Sync.DataGrid.Region(this, "top");
            if (this.fixedCells.right) {
                this.regions.topRight = new Extras.Sync.DataGrid.Region(this, "topRight");
            }
        }
        
        if (this.fixedCells.bottom) {
            if (this.fixedCells.left) {
                this.regions.bottomLeft = new Extras.Sync.DataGrid.Region(this, "bottomLeft");
            }
            this.regions.bottom = new Extras.Sync.DataGrid.Region(this, "bottom");
            if (this.fixedCells.right) {
                this.regions.bottomRight = new Extras.Sync.DataGrid.Region(this, "bottomRight");
            }
        }
        
        if (this.fixedCells.left) {
            this.regions.left = new Extras.Sync.DataGrid.Region(this, "left");
        }

        this.regions.center = new Extras.Sync.DataGrid.Region(this, "center");

        if (this.fixedCells.right) {
            this.regions.right = new Extras.Sync.DataGrid.Region(this, "right");
        }
        
        for (var name in this.regions) {
            this.scrollContainer.contentElement.appendChild(this.regions[name].element);
        }
        
        this._updateRegionBounds();
    },
    
    _getCellBorderHeight: function(column, row) {
        return 2;
    },
    
    _getCellBorderWidth: function(column, row) {
        return 2;
    },
    
    _getColumnWidth: function(column) {
        return 80;
    },
    
    getPrototypeTable: function() {
        if (!this._prototypeTable) {
            this._prototypeTable = document.createElement("table");
            this._prototypeTable.cellPadding = this._prototypeTable.cellSpacing = 0;
            this._prototypeTable.style.cssText = "table-layout:fixed;padding:0;border:0px none;";
            var tbody = document.createElement("tbody");
            this._prototypeTable.appendChild(tbody);
        }
        return this._prototypeTable;
    },
    
    _getRowHeight: function(row) {
        return 17; //FIXME
    },

    _loadProperties: function() {
        this._cellBorder = this.component.render("cellBorder");
        this._model = this.component.get("model");
        this.fixedCells = {
            left: parseInt(this.component.render("fixedColumnsLeft", 0), 10),
            top: parseInt(this.component.render("fixedRowsTop", 0), 10),
            right: parseInt(this.component.render("fixedColumnsRight", 0), 10),
            bottom: parseInt(this.component.render("fixedRowsBottom", 0), 10)
        };

        // FIXME temporary
        this.fixedCellSizes = { 
            left: this.fixedCells.left * this._getColumnWidth(),
            top: this.fixedCells.top * this._getRowHeight(),
            right: this.fixedCells.right * this._getColumnWidth(),
            bottom: this.fixedCells.bottom * this._getRowHeight()
        };
    },
    
    _processScroll: function(e) {
        if (e.verticalIncrement) {
            this._scrollIncrementalVertical(e.verticalIncrement);
        }
        if (e.horizontalIncrement) {
            this._scrollIncrementalHorizontal(e.horizontalIncrement);
        }
        Core.Debug.consoleWrite(this.y);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = document.createElement("div");
        this._div.style.cssText = "position:absolute;top:0;left:0;right:0;bottom:0;";
        this._div.id = this.component.renderId;
        
        this.scrollContainer = new Extras.Sync.DataGrid.ScrollContainer();
        this.scrollContainer.configure(10, 10);
        this.scrollContainer.onScroll = Core.method(this, this._processScroll);
        this._div.appendChild(this.scrollContainer.rootElement);
        
        this._loadProperties();
        this._fullRenderRequired = true;

        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this._div);
        this.scrollContainer.renderDisplay();
        
        if (this._fullRenderRequired) {
        
            this._createRegions();

            if (this._model == null) {
                this.size = {
                    columns: 0,
                    rows: 0
                };
            } else {
                this.size = {
                    columns: this._model.getColumnCount(),
                    rows: this._model.getRowCount()
                };
                var topRowIndex = Math.floor(this.position.y);
                var leftColumnIndex = Math.floor(this.position.x);
                this.setPosition(this.component.get("columnIndex") || 0, this.component.get("rowIndex") || 0);
            }
            this._fullRenderRequired = false;
        }

        this._updateRegionBounds();
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._cachedTileRows = { };
        this._prototypeTable = null;
        this.regions = null;
        this._div = null;
    },

    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    },
    
    /**
     * Scrolls the viewable area left or right by a percentage of the viewable area width.
     */
    _scrollIncrementalHorizontal: function(percent) {
        var scrollPixels = Math.round(this.scrollContainer.bounds.width * percent / 10);
        this.adjustPositionPx(0 - scrollPixels, 0);
        
    },
    
    /**
     * Scrolls the viewable area up or down by a percentage of the viewable area height.
     */
    _scrollIncrementalVertical: function(percent) {
        var scrollPixels = Math.round(this.scrollContainer.bounds.height * percent / 10);
        this.adjustPositionPx(0, 0 - scrollPixels);
        
    },
    
    _scrollRowPercentVertical: function(percent) {
        var row = this.size.rows * percent / 100;
    },
    
    /**
     * Sets the position of the viewport.  Invocation will clear all existing tiles.
     */
    setPosition: function(x, y) {
        for (var name in this.regions) {
            this.regions[name].setPosition(x, y);
        }
    },

    _updateRegionBounds: function() {
        var i, name, left = 0, top = 0, right = 0, bottom = 0;
        
        if (this.fixedCells.top) {
            for (i = 0; i < this.fixedCells.top; ++i) {
                top += this._getRowHeight(i);
            }
        }

        if (this.fixedCells.bottom) {
            for (i = 0; i < this.fixedCells.bottom; ++i) {
                bottom += this._getRowHeight(this.size.rows - i - 1);
            }
        }

        if (this.fixedCells.left) {
            for (i = 0; i < this.fixedCells.left; ++i) {
                left += this._getColumnWidth(i);
            }
        }
        
        if (this.fixedCells.right) {
            for (i = 0; i < this.fixedCells.right; ++i) {
                right += this._getColumnWidth(this.size.columns - i - 1);
            }
        }
        
        for (name in this.regions) {
            this.regions[name].updateBounds(left, top, right, bottom);
        }
    }
});

/**
 * Renders a scrolling container for the DataGrid, processing scroll events and managing scroll bar positions.
 * Features an "accumulator" so as not to fire events overly frequently, e.g., mousewheel scrolling must stop for a (very) 
 * brief period of time before a scroll event is fired.
 */
Extras.Sync.DataGrid.ScrollContainer = Core.extend({

    _hScrollAccumulator: 0,
    _vScrollAccumulator: 0,
    
    bounds: null,

    rootElement: null,
    contentElement: null,
    _lastScrollSetTime: 0,
    
    size: 5,
    
    /**
     * Horizontal scroll position, a value between 0 and 1.
     * @type Number
     */
    scrollX: 0,

    /**
     * Vertical scroll position, a value between 0 and 1.
     * @type Number
     */
    scrollY: 0,
    
    /**
     * Singleton listener to invoke when scroll position changes.
     * @type Function
     */
    onScroll: null,

    /**
     * Creates a ScrollContainer.  The dispose() method should be invoked when the ScrollContainer will no longer be used.
     *
     * @param horizontal
     * @param vertical
     */
    $construct: function(horizontal, vertical) {
        this.rootElement = document.createElement("div");
        this.rootElement.style.cssText = "position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;";
        
        
        this._vScrollContainer = document.createElement("div");
        this._vScrollContainer.style.cssText = "position:absolute;top:0;bottom:0;right:0;overflow:scroll;";
        this._vScrollContainer.style.width = (1 + Core.Web.Measure.SCROLL_WIDTH) + "px";
        this._vScrollContent = document.createElement("div");
        this._vScrollContent.style.cssText = "width:1px;height:" + (this.size * 100) + "%;";
        this._vScrollContainer.appendChild(this._vScrollContent);
        this.rootElement.appendChild(this._vScrollContainer);
        
        this._hScrollContainer = document.createElement("div");
        this._hScrollContainer.style.cssText = "position:absolute;;bottom:0;left:0;right:0;overflow:scroll;";
        this._hScrollContainer.style.height = (1 + Core.Web.Measure.SCROLL_HEIGHT) + "px";
        this._hScrollContent = document.createElement("div");
        this._hScrollContent.style.cssText = "height:1px;width:" + (this.size * 100) + "%;";
        this._hScrollContainer.appendChild(this._hScrollContent);
        this.rootElement.appendChild(this._hScrollContainer);
        
        this.contentElement = document.createElement("div");
        this.contentElement.style.cssText = "position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;background:white;";
        this.rootElement.appendChild(this.contentElement);
        
        Core.Web.Event.add(this._vScrollContainer, "scroll", Core.method(this, this._processScrollV), true);
        Core.Web.Event.add(this._hScrollContainer, "scroll", Core.method(this, this._processScrollH), true);
        Core.Web.Event.add(this.rootElement, Core.Web.Env.BROWSER_MOZILLA ? "DOMMouseScroll" :  "mousewheel",
                Core.method(this, this._processWheel), true);
    },
    
    _accumulatedScroll: function() {
        if (this._vScrollAccumulator || this._hScrollAccumulator) {
            var v = this._vScrollAccumulator;
            this._vScrollAccumulator = 0;
            var h = this._hScrollAccumulator;
            this._hScrollAccumulator = 0;
            if (this.onScroll) {
                // FIXME
                this.onScroll({source: this, type: "scroll", horizontalIncrement: h, verticalIncrement:  v });
            }
        }
    },
    
    configure: function(horizontal, vertical) {
        if (horizontal > 1) {
            this._vScrollContainer.style.bottom = this.contentElement.style.bottom = Core.Web.Measure.SCROLL_HEIGHT + "px";
        } else {
            this._vScrollContainer.style.bottom = this.contentElement.style.bottom = 0;
        }
        if (vertical > 1) {
            this._hScrollContainer.style.right = this.contentElement.style.right = Core.Web.Measure.SCROLL_WIDTH + "px";
        } else {
            this._hScrollContainer.style.right = this.contentElement.style.right = 0;
        }
    },
    
    /**
     * Disposes of the ScrollContainer, releasing any resources in use.
     */
    dispose: function() {
        Core.Web.Event.removeAll(this._hScrollContainer);
        Core.Web.Event.removeAll(this._vScrollContainer);
        Core.Web.Event.removeAll(this.rootElement);
    
        this.rootElement = null;
        this.contentElement = null;
    },
    
    /**
     * Determines if a just-received scroll event is the result of a user adjusting a scroll bar or a result of the
     * scroll bar having been adjusted programmatically.  
     */
    _isUserScroll: function() {
        return (new Date().getTime() - this._lastScrollSetTime) > 100; 
    },
    
    /**
     * Process a horizontal scroll bar drag adjustment event.
     *
     * @param e the event
     */
    _processScrollH: function(e) {
        if (!this._isUserScroll()) {
            return;
        }

        this.scrollX = this._hScrollContainer.scrollLeft / ((this.size - 1) * this.bounds.width);
        
        //FIXME Implement
        Core.Debug.consoleWrite("hscroll:" + this.scrollX);
        if (this.onScroll) {
        }
    },
    
    /**
     * Process a vertical scroll bar drag adjustment event.
     *
     * @param e the event
     */
    _processScrollV: function(e) {
        if (!this._isUserScroll()) {
            return;
        }
        
        this.scrollY = this._vScrollContainer.scrollTop / ((this.size - 1) * this.bounds.height);
        
        Core.Debug.consoleWrite("vscroll:" + this.scrollY);
        //FIXME Implement
        if (this.onScroll) {
        }
    },
    
    /**
     * Processes a scroll wheel event.
     *
     * @param e the event
     */
    _processWheel: function(e) {
        // Convert scroll wheel direction/distance data into uniform/cross-browser format:
        // A value of 1 indicates one notch scroll down, -1 indicates one notch scroll up.
        var wheelScroll;
        if (e.wheelDelta) {
            wheelScroll = e.wheelDelta / -120;
        } else if (e.detail) {
            wheelScroll = e.detail / 3;
        } else {
            return;
        }
        
        if (e.shiftKey) {
            // Scroll horizontally.
            this._hScrollAccumulator += wheelScroll;
        } else {
            // Scroll vertically.
            this._vScrollAccumulator += wheelScroll;
        }
        Core.Web.Scheduler.run(Core.method(this, this._accumulatedScroll), 10);
        
        // Prevent default scrolling action, or in the case of modifier keys, font adjustments, etc.
        Core.Web.DOM.preventEventDefault(e);
        
        return true;
    },
    
    /**
     * Executes operations which should be performed when the containing component synchronize peer's <code>renderDisplay</code>
     * method is invoked.
     */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this.rootElement);
        Core.Web.VirtualPosition.redraw(this.contentElement);
        Core.Web.VirtualPosition.redraw(this._hScrollContainer);
        Core.Web.VirtualPosition.redraw(this._vScrollContainer);
        
        this.bounds = new Core.Web.Measure.Bounds(this.contentElement);
        this._scrollHeight = new Core.Web.Measure.Bounds(this._hScrollContent).height;
        this._scrollWidth = new Core.Web.Measure.Bounds(this._vScrollContent).width;
        Core.Debug.consoleWrite(this.bounds);
    },
    
    setPosition: function(scrollX, scrollY) {
        this.scrollX = scrollX;
        this.scrollY = scrollY;
        
        this._hScrollContainer.scrollLeft = this.scrollX * ((this.size - 1) * this.bounds.width);
        this._vScrollContainer.scrollTop = this.scrollY * ((this.size - 1) * this.bounds.height);
    }
});
/**
 * Component rendering peer: DragSource.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.DragSource = Core.extend(Echo.Render.ComponentSync, {
    
    $load: function() {
        Echo.Render.registerPeer("Extras.DragSource", this);
    },
    
    /**
     * The dragging element.  This element is created by cloning the rendered DIV (and its descendants), reducing their
     * opacity, and then absolutely positioning it adjacent the mouse cursor position.
     * @type Element
     */
    _dragDiv: null,
    
    /**
     * Rendered DIV element.
     * @type Element 
     */
    _div: null,
    
    /**
     * Overlay DIV which covers other elements (such as IFRAMEs) when dragging which may otherwise suppress events.
     * @type Element
     */
    _overlayDiv: null,
    
    /**
     * Method reference to <code>_processMouseMove()</code>.
     * @type Function
     */
    _processMouseMoveRef: null,

    /**
     * Method reference to <code>_processMouseUp()</code>.
     * @type Function
     */
    _processMouseUpRef: null,

    /**
     * Constructor.
     */
    $construct: function() {
        this._processMouseMoveRef = Core.method(this, this._processMouseMove);
        this._processMouseUpRef = Core.method(this, this._processMouseUp);
    },
    
    /**
     * Start a drag operation.
     * 
     * @param the e relevant mouse down event which started the drag operation
     */
    _dragStart: function(e) {
        this._dragStop();
        
        this._overlayDiv = document.createElement("div");
        this._overlayDiv.style.cssText = "position:absolute;z-index:30000;width:100%;height:100%;cursor:pointer;";
        Echo.Sync.FillImage.render(this.client.getResourceUrl("Echo", "resource/Transparent.gif"), this._overlayDiv);

        this._dragDiv = this._div.cloneNode(true);
        this._dragDiv.style.position = "absolute";
        this._setDragOpacity(0.75);
        this._overlayDiv.appendChild(this._dragDiv);

        document.body.appendChild(this._overlayDiv);

        Core.Web.Event.add(document.body, "mousemove", this._processMouseMoveRef, true);
        Core.Web.Event.add(document.body, "mouseup", this._processMouseUpRef, true);
        
        this._dragUpdate(e);
    },
    
    /**
     * Performs a drop operation.
     * 
     * @param e the relevant mouse up event describing where the dragged item was dropped
     */
    _dragDrop: function(e) {
        var i,
            specificTarget = null,
            dropTarget, 
            testTarget,
            dropTargetIds,
            targetElement = this._findElement(this.client.domainElement, e.clientX, e.clientY);
        
        // Find specific target component.
        while (!specificTarget && targetElement && targetElement != this.client.domainElement) {
            if (targetElement.id) {
                specificTarget = this.client.application.getComponentByRenderId(targetElement.id);
            }
            targetElement = targetElement.parentNode;
        }
        
        // Return if specific target component could not be found.
        if (!specificTarget) {
            return;
        }

        // Retrieve valid drop target renderIds from component.
        dropTargetIds = this.component.get("dropTargetIds");
        if (!dropTargetIds) {
            dropTargetIds = [];
        }
        
        // Find actual drop target.
        testTarget = specificTarget;
        while (testTarget && !dropTarget) {
            for (i = 0; i < dropTargetIds.length; ++i) {
                if (dropTargetIds[i] == testTarget.renderId) {
                    // Drop target found.
                    dropTarget = testTarget;
                    break;
                }
            }
            testTarget = testTarget.parent;
        }
        
        // Return immediately if target is not a descendent of a drop target.
        if (!dropTarget) {
            return;
        }
        
        this.component.doDrop(dropTarget.renderId, specificTarget.renderId);
    },
    
    /**
     * Stop a drag operation.
     */
    _dragStop: function() {
        Core.Web.Event.remove(document.body, "mousemove", this._processMouseMoveRef, true);
        Core.Web.Event.remove(document.body, "mouseup", this._processMouseUpRef, true);

        if (this._overlayDiv) {
            document.body.removeChild(this._overlayDiv);
            this._overlayDiv = null;
        }
        this._dragDiv = null;
    },
    
    /**
     * Updates the position of the dragged object in response to mouse movement.
     * 
     * @param e the relevant mouse move event which necessitated the drag update
     */
    _dragUpdate: function(e) {
        this._dragDiv.style.top = e.clientY + "px";
        this._dragDiv.style.left = e.clientX + "px";
    },
    
    /**
     * Finds the highest-level (z-index) element at the specified x/y coordinate.
     * 
     * @param {Element} searchElement the element at which to begin searching
     * @param {Number} x the x coordinate
     * @param {Number} y the y coordinate
     * @return the element
     * @type Element
     */
    _findElement: function(searchElement, x, y) {
        if (searchElement.style.display == "none" || searchElement.style.visibility == "hidden" || 
                (searchElement.nodeName && searchElement.nodeName.toLowerCase() == "colgroup")) {
            // Ignore non-displayed elements, hidden elements, and COLGROUP elements.
            return null;
        }

        var searchElementIsCandidate = false;
        if (!(searchElement.nodeName && searchElement.nodeName.toLowerCase() == "tr")) {
            var bounds = new Core.Web.Measure.Bounds(searchElement);
            if (this._isBoundsDefined(bounds)) {
                // Only take action if bounds is defined, as elements without positioning can contain positioned elements.
            
                if (this._isInBounds(bounds, x, y)) {
                    // Mark search element as being in candidate.
                    // This flag will be used to ensure that elements with undefined bounds are not returned as candidate.
                    // In any case, it is necessary to continue to search them for children that might be candidates though.
                    searchElementIsCandidate = true;
                } else {
                    // Out of bounds.
                    return null;
                }
            }
        }
        
        var candidates = null;

        // At this point, element is still a candidate.  Now we look for child elements with greater specificity.
        for (var i = 0; i < searchElement.childNodes.length; ++i) {
            if (searchElement.childNodes[i].nodeType != 1) {
                continue;
            }
            
            var resultElement = this._findElement(searchElement.childNodes[i], x, y);
            if (resultElement) {
                if (candidates == null) {
                    candidates = [];
                }
                candidates.push(resultElement);
            }
        }
        
        if (candidates != null) {
            if (candidates.length == 1) {
                return candidates[0];
            } else {
                return this._findHighestCandidate(searchElement, candidates);
            }
        }
        
        // The 'searchElement' is the best candidate found.  Return it only in the case where its bounds are actually defined.
        return searchElementIsCandidate ? searchElement : null;
    },
    
    /**
     * Determine which element amongst candidates is displayed above others (based on z-index).
     * 
     * @param {Element} searchElement the highest-level element from which all candidate elements descend
     * @param {Array} candidates an array of candidate elements to test
     * @return the highest candidate element
     * @type Element
     */
    _findHighestCandidate: function(searchElement, candidates) {
        var candidatePaths = [];
        var candidateIndex;
        for (candidateIndex = 0; candidateIndex < candidates.length; ++candidateIndex) {
            candidatePaths[candidateIndex] = [];
            var element = candidates[candidateIndex];
            if (element.style.zIndex) {
                candidatePaths[candidateIndex].unshift(element.style.zIndex);
            }
            while (element != searchElement) {
                element = element.parentNode;
                if (element.style.zIndex) {
                    candidatePaths[candidateIndex].unshift(element.style.zIndex);
                }
            }
        }
        
        var elementIndex = 0;
        var elementsFoundOnIteration;
        do {
            elementsFoundOnIteration = false;
            var highestZIndex = 0;
            var highestCandidateIndices = [];
            for (candidateIndex = 0; candidateIndex < candidatePaths.length; ++candidateIndex) {
                if (elementIndex < candidatePaths[candidateIndex].length) {
                    var zIndex = candidatePaths[candidateIndex][elementIndex];
                    if (zIndex && zIndex > 0 && zIndex >= highestZIndex) {
                        if (zIndex == highestZIndex) {
                            // Value is equal to previous highest found, add to list of highest.
                            highestCandidateIndices.push(candidateIndex);
                        } else {
                            // Value is greater than highest found, clear list of highest and add.
                            highestCandidateIndices = [];
                            highestCandidateIndices.push(candidateIndex);
                        }
                    }
                    elementsFoundOnIteration = true;
                }
            }
            
            if (highestCandidateIndices.length == 1) {
                // Only one candidate remains: return it.
                return candidates[highestCandidateIndices[0]];
            } else if (highestCandidateIndices.length > 0) {
                // Remove candidates that are now longer in contention.
                var remainingCandidates = [];
                for (var i = 0; i < highestCandidateIndices.length; ++i) {
                    remainingCandidates[i] = candidates[highestCandidateIndices[i]];
                }
                candidates = remainingCandidates;
            }
        } while (elementsFoundOnIteration);
        
        return candidates[candidates.length - 1];
    },
    
    /**
     * Determines if the specified bounding area is defined (has contained pixels).
     * 
     * @param {Core.Web.Measure.Bounds} bounds the bounding region
     * @return true if the bounds has a defined, nonzero area
     * @type Boolean
     */
    _isBoundsDefined: function(bounds) {
        return bounds.width !== 0 && bounds.height !== 0;
    },

    /**
     * Determines if a point is within a bounding region.
     * 
     * @param {Core.Web.Measure.Bounds} bounds the bounding region
     * @param {Number} x the horizontal coordinate of the point
     * @param {Number} y the vertical coordinate of the point
     * @return true if the point is in the bounding region
     * @type Boolean
     */
    _isInBounds: function(bounds, x, y) {
        return x >= bounds.left && y >= bounds.top && x <= bounds.left + bounds.width && y <= bounds.top + bounds.height;
    },

    /**
     * Processes a mouse down event on the drag source container element.
     * 
     * @param e the event
     */
    _processMouseDown: function(e) {
        Core.Web.DOM.preventEventDefault(e);

        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        
        this._dragStart(e);
    },
    
    /**
     * Processes a mouse move event (on the overlay DIV).
     * 
     * @param e the event
     */
    _processMouseMove: function(e) {
        this._dragUpdate(e);
    },
    
    /**
     * Processes a mouse up event (on the overlay DIV).
     * 
     * @param e the event
     */
    _processMouseUp: function(e) {
        this._dragStop();
        this._dragDrop(e);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.style.cssText = "cursor:pointer;";
        if (this.component.children.length > 0) {
            Echo.Render.renderComponentAdd(update, this.component.children[0], this._div);
        }

        Core.Web.Event.add(this._div, "mousedown", Core.method(this, this._processMouseDown), true);
        
        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._dragStop();
        Core.Web.Event.removeAll(this._div);

        this._dragDiv = null;
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
    },
    
    /**
     * Sets the opacity of the dragged item.
     * 
     * @param value the new opacity
     */
    _setDragOpacity: function(value) {
        if (Core.Web.Env.NOT_SUPPORTED_CSS_OPACITY) {
            if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
                this._dragDiv.style.filter = "alpha(opacity=" + (value * 100) + ")";
            }
        } else {
            this._dragDiv.style.opacity = value;
        }
    }
});/**
 * Component rendering peer: Group.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.Group = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
            borderImages: [
                "image/group/GroupBorderTopLeft.png",
                "image/group/GroupBorderTop.png",
                "image/group/GroupBorderTopRight.png",
                "image/group/GroupBorderLeft.png",
                "image/group/GroupBorderRight.png",
                "image/group/GroupBorderBottomLeft.png",
                "image/group/GroupBorderBottom.png",
                "image/group/GroupBorderBottomRight.png"
            ],
            borderInsets: "10px",
            titleInsets: "0px 2px"
        }
    },

    $load: function() {
        Echo.Render.registerPeer("Extras.Group", this);
    },
    
    /**
     * Main outer DIV element.
     * @type Element
     */
    _div: null,
    
    /**
     * Array of component-provided border images (may be null if unspecified).
     * @type Array
     */
    _borderImages: null,
    
    /**
     * Creates a FillImage value for the given position, repeat, and position settings.
     * Images are retrieved from component-set or default border image array.
     * 
     * @param {Number} position the position index (0-7)
     * @param {String} repeat the repeat setting
     * @param {#Extent} x the rendered horizontal position, e.g., 0, or "100%" 
     * @param {#Extent} y the rendered vertical position, e.g., 0, or "100%"
     * @return the rendered image
     * @type #FillImage 
     */
    _getBorderImage: function(position, repeat, x, y) {
        var image = this._borderImages ? this._borderImages[position] : 
                this.client.getResourceUrl("Extras", Extras.Sync.Group.DEFAULTS.borderImages[position]);
        return image ? { url: image, repeat: repeat, x: x, y: y } : null; 
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._borderImages = this.component.render("borderImage");
        
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        Echo.Sync.Color.render(this.component.render("foreground"), this._div, "color");
        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), this._div);
    
        this._renderBorder(update);
        
        parentElement.appendChild(this._div);
    },
    
    /**
     * Renders border element, appends to main DIV.  Invokes _renderContent() to render content and append to
     * DOM hierarchy in appropriate position.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     */
    _renderBorder: function(update) {
        var borderInsets = this.component.render("borderInsets", Extras.Sync.Group.DEFAULTS.borderInsets);
        var borderPixelInsets = Echo.Sync.Insets.toPixels(borderInsets);
        var flags = this.component.render("ieAlphaRenderBorder") ? Echo.Sync.FillImage.FLAG_ENABLE_IE_PNG_ALPHA_FILTER : 0;
        
        var topRightDiv = document.createElement("div");
        topRightDiv.style.width = "100%";
        Echo.Sync.FillImage.render(this._getBorderImage(2, "no-repeat", "100%", "100%"), topRightDiv, flags);
        
        var topLeftDiv = document.createElement("div");
        topLeftDiv.style.paddingRight = borderPixelInsets.right + "px";
        topLeftDiv.style.paddingLeft = borderPixelInsets.left + "px";
        Echo.Sync.FillImage.render(this._getBorderImage(0, "no-repeat", 0, "100%"), topLeftDiv, flags);
        topRightDiv.appendChild(topLeftDiv);
        
        var title = this.component.render("title");
        if (title) {
            var topTable = document.createElement("table");
            topTable.style.padding = "0px";
            topTable.style.borderCollapse = "collapse";
            topTable.style.width = "100%";
            var topTbody = document.createElement("tbody");
            topTable.appendChild(topTbody);
            var topTr = document.createElement("tr");
            topTbody.appendChild(topTr);
            
            var titlePosition = this.component.render("titlePosition");
            if (titlePosition) {
                var topPositionTd = document.createElement("td");
                if (Echo.Sync.Extent.isPercent(titlePosition)) {
                    topPositionTd.style.width = titlePosition.toString();
                }
                var topPositionImg = document.createElement("img");
                topPositionImg.src = this.client.getResourceUrl("Echo", "resource/Transparent.gif");
                if (Echo.Sync.Extent.isPercent(titlePosition)) {
                    topPositionImg.style.width = titlePosition.toString();
                }
                topPositionImg.style.height = "1px";
                topPositionTd.appendChild(topPositionImg);
                Echo.Sync.FillImage.render(
                        this._getBorderImage(1, "repeat-x", 0, "100%"), topPositionTd, flags);
                topTr.appendChild(topPositionTd);
            }
            
            var titleTd = document.createElement("td");
            titleTd.style.whiteSpace = "nowrap";
            Echo.Sync.Font.render(this.component.render("titleFont"), titleTd);
            Echo.Sync.Insets.render(this.component.render("titleInsets",
                    Extras.Sync.Group.DEFAULTS.titleInsets), titleTd, "padding");
            var titleImage = this.component.render("titleBackgroundImage");
            if (titleImage) {
                Echo.Sync.FillImage.render({ url: titleImage, repeat: "repeat-x", x: 0, y: "100%" }, titleTd, flags);
            }
            titleTd.appendChild(document.createTextNode(title));
            topTr.appendChild(titleTd);
            
            var topFillTd = document.createElement("td");
            if (titlePosition && Echo.Sync.Extent.isPercent(titlePosition)) {
                topFillTd.style.width = (100 - parseInt(titlePosition, 10)) + "%";
            } else {
                topFillTd.style.width = "100%";
            }
            topFillTd.style.height = borderPixelInsets.top + "px";
            Echo.Sync.FillImage.render(this._getBorderImage(1, "repeat-x", 0, "100%"), 
                    topFillTd, flags);
            topTr.appendChild(topFillTd);
            
            topLeftDiv.appendChild(topTable);
        } else {
            var topDiv = document.createElement("div");
            topDiv.style.width = "100%";
            topDiv.style.height = borderPixelInsets.top + "px";
            topDiv.style.fontSize = "1px";
            Echo.Sync.FillImage.render(this._getBorderImage(1, "repeat-x", 0, "100%"), 
                    topDiv, flags);
            topLeftDiv.appendChild(topDiv);
        }
        
        this._div.appendChild(topRightDiv);
        
        var rightDiv = document.createElement("div");
        rightDiv.style.width = "100%";
        Echo.Sync.FillImage.render(this._getBorderImage(4, "repeat-y", "100%", 0), 
                rightDiv, flags);
        
        var leftDiv = document.createElement("div");
        leftDiv.style.paddingRight = borderPixelInsets.right + "px";
        leftDiv.style.paddingLeft = borderPixelInsets.left + "px";
        Echo.Sync.FillImage.render(this._getBorderImage(3, "repeat-y", 0, 0), 
                leftDiv, flags);
        this._renderContent(update, leftDiv);
        rightDiv.appendChild(leftDiv);
        this._div.appendChild(rightDiv);
        
        var bottomRightDiv = document.createElement("div");
        bottomRightDiv.style.width = "100%";
        bottomRightDiv.style.height = borderPixelInsets.bottom + "px";
        bottomRightDiv.style.fontSize = "1px";
        Echo.Sync.FillImage.render(this._getBorderImage(7, "no-repeat", "100%", "100%"), bottomRightDiv, flags);
        
        var bottomLeftDiv = document.createElement("div");
        bottomLeftDiv.style.paddingRight = borderPixelInsets.right + "px";
        bottomLeftDiv.style.paddingLeft = borderPixelInsets.left + "px";
        Echo.Sync.FillImage.render(this._getBorderImage(5, "no-repeat", 0, "100%"), bottomLeftDiv, flags);
        bottomRightDiv.appendChild(bottomLeftDiv);
        
        var bottomDiv = document.createElement("div");
        bottomDiv.style.width = "100%";
        bottomDiv.style.height = borderPixelInsets.bottom + "px";
        bottomDiv.style.fontSize = "1px";
        Echo.Sync.FillImage.render(this._getBorderImage(6, "repeat-x", 0, "100%"), 
                bottomDiv, flags);
        bottomLeftDiv.appendChild(bottomDiv);
        this._div.appendChild(bottomRightDiv);
    },
    
    /**
     * Renders the content (child) of the Group.
     * 
     * @param {Echo.Update.ComponentUpdate} the update
     * @param {Element} the element to which the content should be appended  
     */
    _renderContent: function(update, parentElement) {
        var div = document.createElement("div");
        
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), div);
        Echo.Sync.Color.render(this.component.render("background"), div, "backgroundColor");
        Echo.Sync.Font.render(this.component.render("font"), div);
        Echo.Sync.Insets.render(this.component.render("insets"), div, "padding");
        
        var componentCount = this.component.getComponentCount();
        for (var i = 0; i < componentCount; i++) {
            var child = this.component.getComponent(i);
            Echo.Render.renderComponentAdd(update, child, div);
        }
        
        parentElement.appendChild(div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._borderImages = null;
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});
/**
 * Abstract base class for menu rendering peers.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.Menu = Core.extend(Echo.Render.ComponentSync, {
    
    $static: {
    
        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
            foreground: "#000000",
            background: "#cfcfcf",
            disabledForeground: "#7f7f7f",
            selectionForeground: "#ffffff",
            selectionBackground: "#3f3f3f",
            border: "1px outset #cfcfcf"
        }
    }, 
    
    /**
     * The root menu model.
     * @type Extras.MenuModel
     */
    menuModel: null,
    
    /**
     * The menu state model.
     * @type Extras.MenuStateModel
     */
    stateModel: null,
    
    /**
     * The root DOM element of the rendered menu.
     * @type Element
     */
    element: null,
    
    /**
     * The active state of the menu, true when the menu is open.
     * @type Boolean
     */
    active: false,

    /** 
     * Array containing <code>Extras.MenuModel</code>s representing currently open menu path. 
     * @type Array
     */
    _openMenuPath: null,
    
    /** 
     * Flag indicating whether menu mask is deployed. 
     * @type Boolean
     */
    _maskDeployed: false,
    
    /**
     * Reference to the mask click listener.
     * @type Function 
     */
    _processMaskClickRef: null,
    
    /**
     * The collection of named overlay elements (top/left/right/bottom) deployed to cover non-menu elements of the
     * screen with transparent DIVs when the menu is active.  This allows the menu to receive de-activation events,
     * event if a mouse click is received in an IFRAME document.
     */
    _overlay: null,
    
    /**
     * Constructor.  Must be invoked by derivative class constructors.
     */
    $construct: function() {
        this._processMaskClickRef = Core.method(this, this._processMaskClick);
        this._openMenuPath = [];
    },

    $abstract: {
    
        /**
         * Returns an object containing 'x' and 'y' properties indicating the position at 
         * which a submenu should be placed.
         * 
         * @param {Extras.MenuModel} menuModel the submenu
         */
        getSubMenuPosition: function(menuModel) { },

        /**
         * Renders the top level menu of the menu component (that which resides in the DOM at all times).
         * 
         * @param {Echo.Update.ComponentUpdate} the hierarchy update for which the rendering is being performed
         */
        renderMain: function(update) { }
    },
    
    $virtual: {

        /**
         * Activates the menu component.
         * Adds rendering mask to screen, sets menu component as modal.
         */
        activate: function() {
            if (this.active) {
                return false;
            }
            this.component.set("modal", true);
            this.active = true;
            this.addMask();
            
            this.client.application.setFocusedComponent(this.component);
            Core.Web.DOM.focusElement(this.element);
            
            return true;
        },

        /**
         * Activates a menu item.  Displays submenu if item is a submenu.  Invokes menu action if item
         * is a menu option.
         * 
         * @param {Extras.ItemModel} itemModel the item model to activate.
         */
        activateItem: function(itemModel) {
            if (this.stateModel && !this.stateModel.isEnabled(itemModel.modelId)) {
                return;
            }
            if (itemModel instanceof Extras.OptionModel) {
                this.deactivate();
                this.processAction(itemModel);
            } else if (itemModel instanceof Extras.MenuModel) {
                this._openMenu(itemModel);
            }
        },
        
        /**
         * Fires an action event in response to a menu option being activated.
         */
        processAction: function(itemModel) {
            this.component.doAction(itemModel);
        }
    },

    /**
     * Adds a menu to the open menu path.
     * 
     * @param {Extras.MenuModel} menu the menu to add
     */
    addMenu: function(menu) {
        this._openMenuPath.push(menu);
    },
    
    /**
     * Adds the menu mask, such that click events on elements other than the menu will be captured by the menu.
     */
    addMask: function() {
        if (this.maskDeployed) {
            return;
        }
        this.maskDeployed = true;
        this._overlayAdd(new Core.Web.Measure.Bounds(this.element));
        
        Core.Web.Event.add(document.body, "click", this._processMaskClickRef, false);
        Core.Web.Event.add(document.body, "contextmenu", this._processMaskClickRef, false);
    },
    
    /**
     * Processes a key down event.
     */
    clientKeyDown: function(e) {
        if (e.keyCode == 27) {
            this.deactivate();
            return false;
        }
        return true;
    },
    
    /**
     * Closes all open menus.
     */
    closeAll: function() {
        while (this._openMenuPath.length > 0) {
            var menu = this._openMenuPath.pop();
            menu.close();
        }
    },
    
    /**
     * Closes all open menus which are descendants of the specified parent menu.
     * 
     * @param {Extras.MenuModel} parentMenu the parent menu
     */
    closeDescendants: function(parentMenu) {
        while (parentMenu != this._openMenuPath[this._openMenuPath.length - 1]) {
            var menu = this._openMenuPath.pop();
            menu.close();
        }
    },
    
    /**
     * Deactivates the menu component, closing any open menus.
     * Removes rendering mask from screen, sets menu component as non-modal.
     */
    deactivate: function() {
        this.component.set("modal", false);
        if (!this.active) {
            return;
        }
        this.active = false;

        this.closeAll();
        this.removeMask();
    },
    
    /**
     * Determines if the specified menu is currently open (on-screen).
     * 
     * @param {Extras.MenuModel} menuModel the menu
     * @return true if the menu is open
     * @type Boolean
     */
    isOpen: function(menuModel) {
        for (var i = 0; i < this._openMenuPath.length; ++i) {
            if (this._openMenuPath[i].menuModel == menuModel) {
                return true;
            }
        }
        return false;
    },
    
    /**
     * Creates and adds the overlay mask elements to the screen, blocking all content except that within the specified bounds.
     * 
     * @param bounds an object containing the pixel bounds of the region NOT to be blocked, must provide top, left, width, and
     *        height integer properties
     */
    _overlayAdd: function(bounds) {
        this._overlayRemove();
        
        var bottom = bounds.top + bounds.height,
            right = bounds.left + bounds.width,
            domainBounds = new Core.Web.Measure.Bounds(document.body);
        this._overlay = { };

        if (bounds.top > 0) {
            this._overlay.top = document.createElement("div");
            this._overlay.top.style.cssText = "position:absolute;z-index:30000;top:0;left:0;width:100%;" +
                    "height:" + bounds.top + "px;";
            document.body.appendChild(this._overlay.top);
        }
        
        if (bottom < domainBounds.height) {
            this._overlay.bottom = document.createElement("div");
            this._overlay.bottom.style.cssText = "position:absolute;z-index:30000;bottom:0;left:0;width:100%;" +
                    "top:" + bottom + "px;";
            document.body.appendChild(this._overlay.bottom);
        }

        if (bounds.left > 0) {
            this._overlay.left = document.createElement("div");
            this._overlay.left.style.cssText = "position:absolute;z-index:30000;left:0;" +
                    "width:" + bounds.left + "px;top:" + bounds.top + "px;height:" + bounds.height + "px;";
            document.body.appendChild(this._overlay.left);
        }

        if (right < domainBounds.width) {
            this._overlay.right = document.createElement("div");
            this._overlay.right.style.cssText = "position:absolute;z-index:30000;right:0;" +
                    "left:" + right + "px;top:" + bounds.top + "px;height:" + bounds.height + "px;";
            document.body.appendChild(this._overlay.right);
        }
        
        for (var name in this._overlay) {
            Echo.Sync.FillImage.render(this.client.getResourceUrl("Echo", "resource/Transparent.gif"), this._overlay[name]);
            Core.Web.VirtualPosition.redraw(this._overlay[name]);
        }
      
        // Force redraw after body modification.
        this.client.forceRedraw();
    },
    
    /**
     * Removes the overlay mask from the screen, if present.
     */
    _overlayRemove: function() {
        if (!this._overlay) {
            return;
        }
        for (var name in this._overlay) {
            document.body.removeChild(this._overlay[name]);
        }
        this._overlay = null;

        // Force redraw after body modification.
        this.client.forceRedraw();
    },
    
    /**
     * Opens a menu.
     * 
     * @param {Extras.MenuModel} menuModel the menu to open
     */
    _openMenu: function(menuModel) {
        if (this.isOpen(menuModel)) {
            return;
        }
        
        var subMenu = new Extras.Sync.Menu.RenderedMenu(this, menuModel);
        subMenu.create();

        var parentMenu = null;
        for (var i = 0; i < this._openMenuPath.length; ++i) {
            if (this._openMenuPath[i].menuModel == menuModel.parent) {
                parentMenu = this._openMenuPath[i];
                break;
            }
        }
        
        if (parentMenu == null) {
            parentMenu = this;
        } else {
            this.closeDescendants(parentMenu);
        }

        var position = parentMenu.getSubMenuPosition(menuModel);
        var windowBounds = new Core.Web.Measure.Bounds(document.body);
        
        if (position.x + subMenu.width > windowBounds.width) {
            position.x = windowBounds.width - subMenu.width;
            if (position.x < 0) {
                position.x = 0;
            }
        }
        if (position.y + subMenu.height > windowBounds.height) {
            position.y = windowBounds.height - subMenu.height;
            if (position.y < 0) {
                position.y = 0;
            }
        }
        
        subMenu.open(position.x, position.y);
        
        this.addMenu(subMenu);
    },

    /**
     * Handler for clicks on the overlay mask: de-activates menu.
     */
    _processMaskClick: function(e) {
        this.deactivate();
        return true;
    },
    
    /** 
     * Removes the menu mask.
     */
    removeMask: function() {
        if (!this.maskDeployed) {
            return;
        }
        this._overlayRemove();
        this.maskDeployed = false;
        Core.Web.Event.remove(document.body, "click", this._processMaskClickRef, false);
        Core.Web.Event.remove(document.body, "contextmenu", this._processMaskClickRef, false);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.menuModel = this.component.get("model");
        this.stateModel = this.component.get("stateModel");
        
        this.element = this.renderMain(update);
        this.element.tabIndex = "-1";
        this.element.style.outlineStyle = "none";
        parentElement.appendChild(this.element);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderDispose: function(update) {
        this.deactivate();
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        Core.Web.DOM.focusElement(this.element);
    },
    
    /** @see Echo.Render.ComponentSync#renderHide */
    renderHide: function() {
        this.deactivate();
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.isUpdatedPropertySetIn({modal: true})) {
            // Do not re-render on update to modal state.
            return;
        }
        var element = this.element;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return false;
    }
});

/**
 * A single on-screen rendered menu.
 */
Extras.Sync.Menu.RenderedMenu = Core.extend({

    $static: {

        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
            iconTextMargin: 5,
            menuInsets: "2px",
            menuItemInsets: "1px 12px"
        },
    
        /**
         * Animation effect to fade-in a DOM element.
         */
        FadeAnimation: Core.extend(Extras.Sync.Animation, {
            
            /**
             * The faded-in element.
             * @type Element
             */
            _element: null,
            
            /**
             * Creates a new FadeAnimation.
             * 
             * @param {Element} element the element to fade in.
             * @param {Number} runTime the animation run time (in milliseconds)
             */
            $construct: function(element, runTime) {
                this._element = element;
                this.runTime = runTime;
            },
        
            /** @see Extras.Sync.Animation#init */
            init: function() { },
            
            /** @see Extras.Sync.Animation#step */
            step: function(progress) {
                this._element.style.opacity = progress;
            },

            /** @see Extras.Sync.Animation#complete */
            complete: function(abort) {
                this._element.style.opacity = 1;
            }
        })
    },
    
    /**
     * The containing menu synchronization peer.
     * @type Extras.Sync.Menu
     */
    menuSync: null,
    
    /**
     * The menu component.
     * @type Echo.Component
     */
    component: null,
    
    /**
     * The relevant client instance.
     * @type Echo.Client
     */
    client: null,
    
    /**
     * The root element of the menu.
     * @type Element
     */
    element: null,
    
    /**
     * Mapping between model ids and menu item TR elements.
     * @type Object
     */
    itemElements: null,
    
    /**
     * The displayed menu model.
     * @type Extras.MenuModel
     */
    menuModel: null,
    
    /**
     * The rendered pixel width of the model.
     * @type Number
     */
    width: null,
    
    /**
     * The rendered pixel height of the model.
     * @type Number
     */
    height: null,
    
    /**
     * The currently active menu item.
     * @type Extras.ItemModel
     */
    _activeItem: null,
    
    /**
     * The menu state model.
     * @type Extras.MenuStateModel
     */
    stateModel: null,
    
    /**
     * Creates a new <code>RenderedMenu</code>.
     * 
     * @param {Extras.Sync.Menu} menuSync the menu synchronization peer
     * @param {Extras.MenuModel} menuModel the menu model
     */
    $construct: function(menuSync, menuModel) {
        this.menuSync = menuSync;
        this.menuModel = menuModel;
        this.component = this.menuSync.component;
        this.client = this.menuSync.client;
        this.stateModel = this.menuSync.stateModel;
        this.itemElements = { };
    },

    /**
     * Closes the menu, removing it from the screen.
     * Disposes all resources, object should be released for garbage collection after invocation.
     */
    close: function() {
        Core.Web.Event.removeAll(this.element);
        document.body.removeChild(this.element);
        // Force redraw after body modification.
        this.client.forceRedraw();
        this.element = null;
        this.itemElements = null;
        this._activeItem = null;
    },

    /**
     * Renders DOM element hierarchy of menu.  Does not display it within document (open() method will later
     * be used to perform this operation).  
     */
    create: function() {
        var i,
            item,
            img,
            menuItemContentTd,
            menuItemIconTd,
            menuItemTr;

        this.element = document.createElement("div");
        this.element.style.position = "absolute";
        this.element.style.zIndex = 30050;
        
        var opacity = (Core.Web.Env.NOT_SUPPORTED_CSS_OPACITY ? 100 : this.component.render("menuOpacity", 100)) / 100;

        var menuContentDiv = document.createElement("div");
        menuContentDiv.style.cssText = "position:relative;z-index:10;";
        this.element.appendChild(menuContentDiv);

        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), menuContentDiv);
        Echo.Sync.Insets.render(Extras.Sync.Menu.RenderedMenu.DEFAULTS.menuInsets, 
                menuContentDiv, "padding");
        Echo.Sync.Border.render(this.component.render("menuBorder", Extras.Sync.Menu.DEFAULTS.border),
                menuContentDiv);
        var foreground;
        var menuForeground = this.component.render("menuForeground");
        if (menuForeground) {
            foreground = menuForeground;
        } else {
            foreground = this.component.render("foreground", Extras.Sync.Menu.DEFAULTS.foreground);
        }
        Echo.Sync.Color.render(foreground, menuContentDiv, "color");

        // Apply menu font if it is set, or apply default font 
        // if it is set and the menu font is NOT set.
        var font = this.component.render("menuFont");
        if (!font) {
            font = this.component.render("font");
        }
        if (font) {
            Echo.Sync.Font.render(font, menuContentDiv);
        }

        var backgroundDiv;
        if (opacity < 1) {
            backgroundDiv = document.createElement("div");
            backgroundDiv.style.cssText = "position:absolute;z-index:1;width:100%;height:100%;top:0;bottom:0;";
            backgroundDiv.style.opacity = opacity;
            this.element.appendChild(backgroundDiv);
        } else {
            backgroundDiv = this.element;
        }

        var background;
        var menuBackground = this.component.render("menuBackground");
        if (menuBackground) {
            background = menuBackground;
        } else {
            background = this.component.render("background", Extras.Sync.Menu.DEFAULTS.background);
        }
        Echo.Sync.Color.render(background, backgroundDiv, "backgroundColor");

        // Apply menu background image if it is set, or apply default background 
        // image if it is set and the menu background is NOT set.
        var backgroundImage;
        var menuBackgroundImage = this.component.render("menuBackgroundImage");
        if (menuBackgroundImage) {
            backgroundImage = menuBackgroundImage;
        } else if (menuBackground == null) {
            backgroundImage = this.component.render("backgroundImage");
        }
        if (backgroundImage) {
            Echo.Sync.FillImage.render(backgroundImage, backgroundDiv, null); 
        }

        var menuTable = document.createElement("table");
        menuTable.style.borderCollapse = "collapse";
        menuContentDiv.appendChild(menuTable);

        var menuTbody = document.createElement("tbody");
        menuTable.appendChild(menuTbody);

        var items = this.menuModel.items;

        // Determine if any icons are present.
        var hasIcons = false;
        for (i = 0; i < items.length; ++i) {
            item = items[i];
            if (item.icon || item instanceof Extras.ToggleOptionModel) {
                hasIcons = true;
                break;
            }
        }
        var textPadding, iconPadding;

        if (hasIcons) {
            var pixelInsets = Echo.Sync.Insets.toPixels(Extras.Sync.Menu.RenderedMenu.DEFAULTS.menuItemInsets);
            iconPadding = "0px 0px 0px " + pixelInsets.left + "px";
            textPadding = pixelInsets.top + "px " + pixelInsets.right + "px " + 
                    pixelInsets.bottom + "px " + pixelInsets.left + "px";
        } else {
            textPadding = Extras.Sync.Menu.RenderedMenu.DEFAULTS.menuItemInsets;
        }

        for (i = 0; i < items.length; ++i) {
            item = items[i];
            if (item instanceof Extras.OptionModel || item instanceof Extras.MenuModel) {
                menuItemTr = document.createElement("tr");
                this.itemElements[item.id] = menuItemTr;
                menuItemTr.style.cursor = "pointer";
                menuTbody.appendChild(menuItemTr);

                if (hasIcons) {
                    menuItemIconTd = document.createElement("td");
                    Echo.Sync.Insets.render(iconPadding, menuItemIconTd, "padding");
                    if (item instanceof Extras.ToggleOptionModel) {
                        var iconIdentifier;
                        var selected = this.stateModel && this.stateModel.isSelected(item.modelId);
                        if (item instanceof Extras.RadioOptionModel) {
                            iconIdentifier = selected ? "image/menu/RadioOn.gif" : "image/menu/RadioOff.gif";
                        } else {
                            iconIdentifier = selected ? "image/menu/ToggleOn.gif" : "image/menu/ToggleOff.gif";
                        }
                        img = document.createElement("img");
                        img.src = this.client.getResourceUrl("Extras", iconIdentifier);
                        menuItemIconTd.appendChild(img);
                    } else if (item.icon) {
                        img = document.createElement("img");
                        Echo.Sync.ImageReference.renderImg(item.icon, img);
                        menuItemIconTd.appendChild(img);
                    }
                    menuItemTr.appendChild(menuItemIconTd);
                }

                menuItemContentTd = document.createElement("td");
                Echo.Sync.Insets.render(textPadding, menuItemContentTd, "padding");
                menuItemContentTd.style.whiteSpace = "nowrap";
                if (this.stateModel && !this.stateModel.isEnabled(item.modelId)) {
                    Echo.Sync.Color.render(this.component.render("disabledForeground", 
                            Extras.Sync.Menu.DEFAULTS.disabledForeground), menuItemContentTd, "color");
                }
                menuItemContentTd.appendChild(document.createTextNode(item.text));
                menuItemTr.appendChild(menuItemContentTd);

                if (item instanceof Extras.MenuModel) {
                    // Submenus have adjacent column containing 'expand' icons.
                    var menuItemArrowTd = document.createElement("td");
                    menuItemArrowTd.style.textAlign = "right";
                    img = document.createElement("img");
                    var expandImage = this.component.render("menuExpandIcon", 
                            this.client.getResourceUrl("Extras", "image/menu/ArrowRight.gif"));
                    img.setAttribute("src", expandImage.url ? expandImage.url : expandImage);
                    img.setAttribute("alt", "");
                    menuItemArrowTd.appendChild(img);
                    menuItemTr.appendChild(menuItemArrowTd);
                } else {
                    // Menu items fill both columns.
                    menuItemContentTd.colSpan = 2;
                }
            } else if (item instanceof Extras.SeparatorModel) {
                if (i === 0 || i === items.length - 1 || items[i - 1] instanceof Extras.SeparatorModel ||
                        items[i + 1] instanceof Extras.SeparatorModel) {
                    // Ignore separators at zero position.
                    continue;
                }
                menuItemTr = document.createElement("tr");
                menuTbody.appendChild(menuItemTr);
                menuItemContentTd = document.createElement("td");
                menuItemContentTd.colSpan = hasIcons ? 3 : 2;
                menuItemContentTd.style.padding = "3px 0px";
                var hrDiv = document.createElement("div");
                hrDiv.style.cssText = "border-top:1px solid #a7a7a7;height:0;font-size:1px;line-height:0";
                menuItemContentTd.appendChild(hrDiv);
                menuItemTr.appendChild(menuItemContentTd);
            }
        }

        var bounds = new Core.Web.Measure.Bounds(this.element);
        this.width = bounds.width;
        this.height = bounds.height;
    },

    /**
     * Returns the menu item TR element which is a parent of the specified element.
     * 
     * @param element an element which is a descendant of a TR element representing a menu item
     * @return the TR element
     * @type Element
     */
    _getItemElement: function(element) {
        if (element == null) {
            return null;
        }
        // Find TD element.
        while (element.nodeName.toLowerCase() != "tr") {
            if (element == this.element) {
                return null;
            }
            element = element.parentNode;
        }
        return element;
    },
    
    /**
     * Determines a ItemModel id based on a menu item DOM element.
     * 
     * @param element the DOM element
     * @return the ItemModel id
     * @type String
     */
    _getItemModel: function(element) {
        var itemModelId = null;
        element = this._getItemElement(element);
        if (element == null) {
            return null;
        }

        // Find item model id of clicked element.
        for (var x in this.itemElements) {
            if (this.itemElements[x] == element) {
                itemModelId = x;
                break;
            }
        }

        if (itemModelId == null) {
            return null;
        } else {
            return this.menuModel.findItem(itemModelId);
        }
    },
    
    /** @see Extras.Sync.Menu#getSubMenuPosition */
    getSubMenuPosition: function(menuModel) {
        var menuElement = this.itemElements[menuModel.id];
        var itemBounds = new Core.Web.Measure.Bounds(menuElement);
        var menuBounds = new Core.Web.Measure.Bounds(this.element);
        return { x: menuBounds.left + menuBounds.width, y: itemBounds.top };
    },
    
    /**
     * Opens the rendered menu, displaying it on the screen at the specified position.
     * 
     * @param {Number} x the horizontal pixel position
     * @param {Number} y the vertical pixel position
     */
    open: function(x, y) {
        this.element.style.left = x + "px";
        this.element.style.top = y + "px";

        var animationTime = this.component.render("animationTime", 0);
        if (animationTime && !Core.Web.Env.NOT_SUPPORTED_CSS_OPACITY) {
            this.element.style.opacity = 0;
            var fadeAnimation = new Extras.Sync.Menu.RenderedMenu.FadeAnimation(this.element, animationTime);
            fadeAnimation.start();
        }
        document.body.appendChild(this.element);
        // Force redraw after body modification.
        this.client.forceRedraw();

        Core.Web.Event.add(this.element, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.add(this.element, "mouseover", Core.method(this, this._processItemEnter), false);
        Core.Web.Event.add(this.element, "mouseout", Core.method(this, this._processItemExit), false);
        Core.Web.Event.Selection.disable(this.element);
    },

    /**
     * Processes a mouse click event.
     * 
     * @param e the event
     */
    _processClick: function(e) {
        Core.Web.DOM.preventEventDefault(e);
        var itemModel = this._getItemModel(Core.Web.DOM.getEventTarget(e));
        if (itemModel) {
            this._setActiveItem(itemModel, true);
        }
    },
    
    /**
     * Processes a mouse rollover enter event.
     * 
     * @param e the event
     */
    _processItemEnter: function(e) {
        this._processRollover(e, true);
    },

    /**
     * Processes a mouse rollover exit event.
     * 
     * @param e the event
     */
    _processItemExit: function(e) {
        this._processRollover(e, false);
    },
    
    /**
     * Processes mouse rollover events.
     * 
     * @param e the event
     * @param {Boolean} state the rollover state, true indicating the mouse is currently rolled over an item
     */
    _processRollover: function(e, state) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return true;
        }
        
        var element = this._getItemElement(Core.Web.DOM.getEventTarget(e));
        if (!element) {
            return;
        }
        var itemModel = this._getItemModel(element);
        if (!itemModel) {
            return;
        }
        
        if (this.stateModel && !this.stateModel.isEnabled(itemModel.modelId)) {
            return;
        }
        
        if (state) {
            this._setActiveItem(itemModel, false);
        }
    },
    
    /**
     * Sets the active item.
     * 
     * @param {Extras.ItemModel} itemModel the item
     * @param {Boolean} execute flag indicating whether the item should be executed
     */
    _setActiveItem: function(itemModel, execute) {
        if (this._activeItem) {
            this._setItemHighlight(this._activeItem, false);
            this._activeItem = null;
        }

        if (itemModel instanceof Extras.MenuModel) {
            this.menuSync.activateItem(itemModel);
        } else {
            if (execute) {
                this.menuSync.activateItem(itemModel);
                // Executing item, menu will close: return immediately.
                return;
            } else {
                this.menuSync.closeDescendants(this);
            }
        }

        if (itemModel) {
            this._activeItem = itemModel;
            this._setItemHighlight(this._activeItem, true);
        }
    },

    /**
     * Sets the highlight state of an item.
     * 
     * @param {Extras.ItemModel} itemModel the item
     * @param {Boolean} state the highlight state
     */
    _setItemHighlight: function(itemModel, state) {
        var element = this.itemElements[itemModel.id];
        if (state) {
            Echo.Sync.FillImage.render(this.component.render("selectionBackgroundImage"), element);
            Echo.Sync.Color.render(this.component.render("selectionBackground", 
                    Extras.Sync.Menu.DEFAULTS.selectionBackground), element, "backgroundColor");
            Echo.Sync.Color.render(this.component.render("selectionForeground", 
                    Extras.Sync.Menu.DEFAULTS.selectionForeground), element, "color");
        } else {
            element.style.backgroundImage = "";
            element.style.backgroundColor = "";
            element.style.color = "";
        } 
    }
});

/**
 * Component rendering peer: ContextMenu
 */
Extras.Sync.ContextMenu = Core.extend(Extras.Sync.Menu, {

    $load: function() {
        Echo.Render.registerPeer("Extras.ContextMenu", this);
    },
    
    /** 
     * X coordinate of activation mouse click.
     * @type Number
     */
    _mouseX: null,
    
    /**
     * Y coordinate of activation mouse click.
     * @type Number
     */
    _mouseY: null,
    
    /** @see Extras.Sync.Menu#getSubMenuPosition */
    getSubMenuPosition: function(menuModel) {
        return { x: this._mouseX, y: this._mouseY };
    },

    /**
     * Processes a mouse click/context-click event.
     * 
     * @param e the event
     */
    _processContextClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return true;
        }
    
        Core.Web.DOM.preventEventDefault(e);
        
        this._mouseX = e.pageX || (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft));
        this._mouseY = e.pageY || (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop));
        
        this.activate();
        this.activateItem(this.menuModel);
    },

    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this.element);
        Extras.Sync.Menu.prototype.renderDispose.call(this, update);
    },
    
    /** @see Extras.Sync.Menu#renderMain */
    renderMain: function(update) {
        var contextMenuDiv = document.createElement("div");
        contextMenuDiv.id = this.component.renderId;
        
        var activationMode = this.component.render("activationMode", Extras.ContextMenu.ACTIVATION_MODE_CONTEXT_CLICK);
        if (activationMode & Extras.ContextMenu.ACTIVATION_MODE_CLICK) {
            Core.Web.Event.add(contextMenuDiv, "click", Core.method(this, this._processContextClick), false);
        }
        if (activationMode & Extras.ContextMenu.ACTIVATION_MODE_CONTEXT_CLICK) {
            Core.Web.Event.add(contextMenuDiv, "contextmenu", Core.method(this, this._processContextClick), false);
        }
        
        var componentCount = this.component.getComponentCount();
        if (componentCount > 0) {
            Echo.Render.renderComponentAdd(update, this.component.getComponent(0), contextMenuDiv);
        }
        
        return contextMenuDiv;
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.isUpdatedPropertySetIn({ stateModel: true, model: true })) {
            // partial update
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                Core.Web.DOM.removeNode(this.element.firstChild);
            }
            var addedChildren = update.getAddedChildren();
            if (addedChildren) {
                Echo.Render.renderComponentAdd(update, addedChildren[0], this.element);
            }
            var modelUpdate = update.getUpdatedProperty("model");
            var stateModelUpdate = update.getUpdatedProperty("stateModel");
            
            var reOpenMenu = this.maskDeployed && (modelUpdate || stateModelUpdate);
            if (reOpenMenu) {
                this.deactivate();
            }
            if (modelUpdate) {
                this.menuModel = modelUpdate.newValue;
            }
            if (stateModelUpdate) {
                this.stateModel = stateModelUpdate.newValue;
            }
            if (reOpenMenu) {
                this.activate();
                this.activateItem(this.menuModel);
            }
            return false;
        }
        // full update
        Extras.Sync.Menu.prototype.renderUpdate.call(this, update);
        return true;
    }
});

//FIXME 'selection' property should be an itemmodel id.  We should have a remote peer for this path-string business.
/**
 * Component rendering peer: DropDownMenu
 */
Extras.Sync.DropDownMenu = Core.extend(Extras.Sync.Menu, {

    $load: function() {
        Echo.Render.registerPeer("Extras.DropDownMenu", this);
    },
    
    /**
     * DIV containing selected item / root content.
     * @type Element
     */
    _contentDiv: null,

    /**
     * The selected item.
     * @type Extras.ItemModel
     */
    _selectedItem: null,
    
    /**
     * Creates the selection item content to display as the menu's root node.
     * 
     * @param {Extras.ItemModel} itemModel the selected item
     */
    _createSelectionContent: function(itemModel) {
        var img;
        if (itemModel.icon) {
            if (itemModel.text) {
                // Render Text and Icon
                var table = document.createElement("table");
                table.style.cssText = "border-collapse:collapse;padding:0;";
                var tbody = document.createElement("tbody");
                var tr = document.createElement("tr");
                var td = document.createElement("td");
                td.style.cssText = "padding:0vertical-align:top;";
                img = document.createElement("img");
                Echo.Sync.ImageReference.renderImg(itemModel.icon, img);
                td.appendChild(img);
                tr.appendChild(td);
                td = document.createElement("td");
                td.style.cssText = "padding:width:3px;";
                var spacingDiv = document.createElement("div");
                spacingDiv.style.cssText = "width:3px";
                td.appendChild(spacingDiv);
                tr.appendChild(td);
                td = document.createElement("td");
                td.style.cssText = "padding:0vertical-align:top;";
                td.appendChild(document.createTextNode(itemModel.text));
                tr.appendChild(td);
                tbody.appendChild(tr);
                table.appendChild(tbody);
                return table;
            } else {
                // Render Icon Only
                img = document.createElement("img");
                Echo.Sync.ImageReference.renderImg(itemModel.icon, img);
                return img;
            }
        } else {
            // Text (or Empty)
            return document.createTextNode(itemModel.text ? itemModel.text : "\u00a0");
        }
    },

    /** @see Extras.Sync.Menu#getSubMenuPosition */
    getSubMenuPosition: function(menuModel) {
        var bounds = new Core.Web.Measure.Bounds(this.element);
        return { x: bounds.left, y: bounds.top + bounds.height };
    },
    
    /** 
     * Processes a menu action, updating selection state if selection is enabled.
     * 
     * @see Extras.Sync.Menu#processAction 
     */
    processAction: function(itemModel) {
        if (this.component.render("selectionEnabled")) {
            this._setSelection(itemModel);
        }
        var path = itemModel.getItemPositionPath().join(".");
        this.component.set("selection", path);
        Extras.Sync.Menu.prototype.processAction.call(this, itemModel);
    },

    /**
     * Processes a mouse click event.
     * 
     * @param e the event
     */
    _processClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return true;
        }
        
        Core.Web.DOM.preventEventDefault(e);
    
        this.activate();
        this.activateItem(this.menuModel);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this.element);
        this._contentDiv = null;
        Extras.Sync.Menu.prototype.renderDispose.call(this, update);
    },
    
    /** @see Extras.Sync.Menu#renderMain */
    renderMain: function() {
        var dropDownDiv = document.createElement("div");
        dropDownDiv.id = this.component.renderId;
        dropDownDiv.style.cssText = "overflow:hidden;cursor:pointer;";
        
        Echo.Sync.LayoutDirection.render(this.component.getLayoutDirection(), dropDownDiv);
        Echo.Sync.Color.render(this.component.render("foreground", Extras.Sync.Menu.DEFAULTS.foreground), dropDownDiv, "color");
        Echo.Sync.Color.render(this.component.render("background", Extras.Sync.Menu.DEFAULTS.background), 
                dropDownDiv, "backgroundColor");
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), dropDownDiv); 
        Echo.Sync.Border.render(this.component.render("border", Extras.Sync.Menu.DEFAULTS.border), dropDownDiv); 
        Echo.Sync.Extent.render(this.component.render("width"), dropDownDiv, "width", true, true);
        Echo.Sync.Extent.render(this.component.render("height"), dropDownDiv, "height", false, true);

        var relativeDiv = document.createElement("div");
        relativeDiv.style.cssText = "float:right;position:relative;";
        dropDownDiv.appendChild(relativeDiv);

        var expandDiv = document.createElement("div");
        expandDiv.style.cssText = "position:absolute;top:2px;right:2px;";
        var expandIcon = this.component.render("expandIcon", this.client.getResourceUrl("Extras", "image/menu/ArrowDown.gif"));
        var img = document.createElement("img");
        Echo.Sync.ImageReference.renderImg(expandIcon, img);
        expandDiv.appendChild(img);
        relativeDiv.appendChild(expandDiv);
  
        this._contentDiv = document.createElement("div");
        this._contentDiv.style.cssText = "float:left;";
        if (!this.component.render("lineWrap")) {
            this._contentDiv.style.whiteSpace = "nowrap";
        }
        Echo.Sync.Insets.render(this.component.render("insets", "2px 5px"), this._contentDiv, "padding");
        dropDownDiv.appendChild(this._contentDiv);
        
        var clearDiv = document.createElement("div");
        clearDiv.style.cssText = "clear:both;";
        dropDownDiv.appendChild(clearDiv);

        Core.Web.Event.add(dropDownDiv, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.Selection.disable(dropDownDiv);

        if (this.component.render("selectionEnabled")) {
            var selection = this.component.render("selection");
            if (selection) {
                this._selectedItem = this.menuModel.getItemModelFromPositions(selection.split("."));
            }
        } else {
            this._selectedItem = null;
        }
        
        if (this._selectedItem) {
            this._contentDiv.appendChild(this._createSelectionContent(this._selectedItem));
        } else {
            var contentText = this.component.render("selectionText");
            this._contentDiv.appendChild(document.createTextNode(contentText ? contentText : "\u00a0"));
        }
        
        if (!this.component.render("height")) {
            var contentBounds = new Core.Web.Measure.Bounds(this._contentDiv);
            relativeDiv.style.height = contentBounds.height + "px";
        }

        return dropDownDiv;
    },

    /**
     * Sets the selection to the given menu model.
     *
     * @param itemModel the model to select
     */
    _setSelection: function(itemModel) {
        this._selectedItem = itemModel;
        for (var i = this._contentDiv.childNodes.length - 1; i >= 0; --i) {
            this._contentDiv.removeChild(this._contentDiv.childNodes[i]);
        }
        this._contentDiv.appendChild(this._createSelectionContent(itemModel));
    }
});    

/**
 * Component rendering peer: MenuBarPane
 */
Extras.Sync.MenuBarPane = Core.extend(Extras.Sync.Menu, {

    $static: {
    
        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
            itemInsets: "0px 12px",
            insets: "3px 0px"
        }
    },
    
    $load: function() {
       Echo.Render.registerPeer("Extras.MenuBarPane", this);
    },
    
    /**
     * The currently active menu item.
     * @type Extras.ItemModel
     */
    _activeItem: null,
    
    /**
     * The menu bar's main TABLE element.
     * @type Element
     */
    _menuBarTable: null,
    
    /**
     * The total height contribution of the menu bar's border, in pixels.
     * @type Number
     */
    _menuBarBorderHeight: null,
    
    /**
     * Mapping between model ids and menu item TD elements.
     * @type Object
     */
    itemElements: null,
    
    /**
     * Constructor.
     */
    $construct: function() {
        Extras.Sync.Menu.call(this);
        this.itemElements = { };
    },
    
    /** @see Extras.Sync.Menu#activate */
    activate: function() {
        if (Extras.Sync.Menu.prototype.activate.call(this)) {
            this.addMenu(this);
        }
    },

    /**
     * Closes the menu.
     */
    close: function() {
        if (this._activeItem) {
            this._setItemHighlight(this._activeItem, false);
            this._activeItem = null;
        }
    },
    
    /**
     * Returns the menu item TD element which is a parent of the specified element.
     * 
     * @param element an element which is a descendant of a TD element representing a menu item
     * @return the TD element
     * @type Element
     */
    _getItemElement: function(element) {
        if (element == null) {
            return null;
        }
        // Find TD element.
        while (element.nodeName.toLowerCase() != "td") {
            if (element == this.element) {
                return null;
            }
            element = element.parentNode;
        }
        return element;
    },
    
    /**
     * Determines a ItemModel id based on a menu item DOM element.
     * 
     * @param element the DOM element
     * @return the ItemModel id
     * @type String
     */
    _getItemModel: function(element) {
        var itemModelId = null;
        element = this._getItemElement(element);
        if (element == null) {
            return null;
        }

        // Find item model id of clicked element.
        for (var x in this.itemElements) {
            if (this.itemElements[x] == element) {
                itemModelId = x;
                break;
            }
        }

        if (itemModelId == null) {
            return null;
        } else {
            return this.menuModel.findItem(itemModelId);
        }
    },
    
    /** @see Echo.Render.ComponnetSync#getPreferredSize */
    getPreferredSize: function() {
        this._menuBarTable.style.height = "";
        var insets = Echo.Sync.Insets.toPixels(this.component.render("insets", Extras.Sync.MenuBarPane.DEFAULTS.insets));
        return { height: new Core.Web.Measure.Bounds(this.element).height + insets.top + insets.bottom };
    },
    
    /** @see Extras.Sync.Menu#getSubMenuPosition */
    getSubMenuPosition: function(menuModel) {
        var itemElement = this.itemElements[menuModel.id];
        if (!itemElement) {
            throw new Error("Invalid menu: " + menuModel);
        }
        
        var containerBounds = new Core.Web.Measure.Bounds(this.element);
        var itemBounds = new Core.Web.Measure.Bounds(itemElement);

        return { x: itemBounds.left, y: containerBounds.top + containerBounds.height };
    },
    
    /**
     * Processes a mouse click event.
     * 
     * @param e the event
     */
    _processClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        
        Core.Web.DOM.preventEventDefault(e);

        var itemModel = this._getItemModel(Core.Web.DOM.getEventTarget(e));
        if (itemModel) {
            if (itemModel instanceof Extras.OptionModel) {
                this.deactivate();
                this.processAction(itemModel);
            } else {
                this.activate();
                this._setActiveItem(itemModel, true);
            }
        } else {
            this.deactivate();
        }
    },
    
    /**
     * Processes a mouse rollover enter event.
     * 
     * @param e the event
     */
    _processItemEnter: function(e) {
        this._processRollover(e, true);
    },
    
    /**
     * Processes a mouse rollover exit event.
     * 
     * @param e the event
     */
    _processItemExit: function(e) {
        this._processRollover(e, false);
    },
    
    /**
     * Processes mouse rollover events.
     * 
     * @param e the event
     * @param {Boolean} state the rollover state, true indicating the mouse is currently rolled over an item
     */
    _processRollover: function(e, state) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return true;
        }
        
        var element = this._getItemElement(Core.Web.DOM.getEventTarget(e));
        if (!element) {
            return;
        }
        var itemModel = this._getItemModel(element);
        
        if (this.stateModel && !this.stateModel.isEnabled(itemModel.modelId)) {
            return;
        }
        
        if (this.active) {
            if (state) {
                this._setActiveItem(itemModel, itemModel instanceof Extras.MenuModel);
            }
        } else {
            this._setItemHighlight(itemModel, state);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this.element);
        var bounds = new Core.Web.Measure.Bounds(this.element.parentNode);
        var height = bounds.height - this._menuBarBorderHeight;
        this._menuBarTable.style.height = height <= 0 ? "" : height + "px";
    },

    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._menuBarTable = null;
        Core.Web.Event.removeAll(this.element);
        Extras.Sync.Menu.prototype.renderDispose.call(this, update);
    },
    
    /** @see Extras.Sync.Menu#renderMain */
    renderMain: function(update) {
        var menuBarDiv = document.createElement("div");
        menuBarDiv.id = this.component.renderId;
        menuBarDiv.style.cssText = "overflow:hidden;";
        
        Echo.Sync.renderComponentDefaults(this.component, menuBarDiv);
        var border = this.component.render("border", Extras.Sync.Menu.DEFAULTS.border);
        var multisided = Echo.Sync.Border.isMultisided(border);
        this._menuBarBorderHeight = Echo.Sync.Border.getPixelSize(border, "top") + Echo.Sync.Border.getPixelSize(border, "bottom");
        Echo.Sync.Border.render(multisided ? border.top : border, menuBarDiv, "borderTop");
        Echo.Sync.Border.render(multisided ? border.bottom : border, menuBarDiv, "borderBottom");
        Echo.Sync.FillImage.render(this.component.render("backgroundImage"), menuBarDiv); 
        
        this._menuBarTable = document.createElement("table");
        this._menuBarTable.style.borderCollapse = "collapse";
        menuBarDiv.appendChild(this._menuBarTable);
        
        var menuBarTbody = document.createElement("tbody");
        this._menuBarTable.appendChild(menuBarTbody);
        
        var menuBarTr = document.createElement("tr");
        menuBarTbody.appendChild(menuBarTr);
        
        if (this.menuModel != null) {
            var items = this.menuModel.items;
            for (var i = 0; i < items.length; ++i) {
                var item = items[i];
                if (item instanceof Extras.OptionModel || item instanceof Extras.MenuModel) {
                    var menuBarItemTd = document.createElement("td");
                    this.itemElements[item.id] = menuBarItemTd;
                    menuBarItemTd.style.padding = "0px";
                    menuBarItemTd.style.cursor = "pointer";
                    menuBarTr.appendChild(menuBarItemTd);
                    var menuBarItemDiv = document.createElement("div");
                    menuBarItemDiv.style.whiteSpace = "nowrap";
                    Echo.Sync.Insets.render(Extras.Sync.MenuBarPane.DEFAULTS.itemInsets, menuBarItemDiv, "padding");
                    menuBarItemTd.appendChild(menuBarItemDiv);
                    if (item.icon) {
                        // FIXME no load listeners being set on images for auto-resizing yet.
                        var img = document.createElement("img");
                        img.style.verticalAlign = "middle";
                        img.src = item.icon;
                        menuBarItemDiv.appendChild(img);
                        if (item.text) {
                            // FIXME Does not handle RTL.
                            img.style.paddingRight = "1ex";
                        }
                    }
                    if (item.text) {
                        var textSpan = document.createElement("span");
                        textSpan.style.verticalAlign = "middle";
                        textSpan.appendChild(document.createTextNode(item.text));
                        menuBarItemDiv.appendChild(textSpan);
                    }
                }
            }
        }
        
        Core.Web.Event.add(menuBarDiv, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.add(menuBarDiv, "mouseover", Core.method(this, this._processItemEnter), false);
        Core.Web.Event.add(menuBarDiv, "mouseout", Core.method(this, this._processItemExit), false);
        Core.Web.Event.Selection.disable(menuBarDiv);
    
        return menuBarDiv;
    },
    
    /**
     * Sets the active item.
     * 
     * @param {Extras.ItemModel} itemModel the item
     * @param {Boolean} execute flag indicating whether the item should be executed
     */
    _setActiveItem: function(itemModel, execute) {
        if (this._activeItem == itemModel) {
            return;
        }
        
        if (this._activeItem) {
            this._setItemHighlight(this._activeItem, false);
            this._activeItem = null;
        }
    
        if (execute) {
            this.activateItem(itemModel);
        }

        if (itemModel) {
            this._activeItem = itemModel;
            this._setItemHighlight(this._activeItem, true);
        }
    },
    
    /**
     * Sets the highlight state of an item.
     * 
     * @param {Extras.ItemModel} itemModel the item
     * @param {Boolean} state the highlight state
     */
    _setItemHighlight: function(itemModel, state) {
        var element = this.itemElements[itemModel.id];
        if (state) {
            Echo.Sync.FillImage.render(this.component.render("selectionBackgroundImage"), element);
            Echo.Sync.Color.render(this.component.render("selectionBackground", 
                    Extras.Sync.Menu.DEFAULTS.selectionBackground), element, "backgroundColor");
            Echo.Sync.Color.render(this.component.render("selectionForeground", 
                    Extras.Sync.Menu.DEFAULTS.selectionForeground), element, "color");
        } else {
            element.style.backgroundImage = "";
            element.style.backgroundColor = "";
            element.style.color = "";
        } 
    }
});
/**
 * Component rendering peer: RichTextArea
 */
Extras.Sync.RichTextArea = Core.extend(Echo.Arc.ComponentSync, {
    
    $static: {

        /**
         * Default rendering values used when component does not specify a property value.
         */
        DEFAULTS: {
    
            /**
             * Default style object applied to control panes.
             */
            controlPaneStyle: {
                separatorColor: "#dfdfef",
                separatorHeight: 1,
                autoPositioned: true
            },
            
            /**
             * Default style object applied to control pane option button container rows.
             */
            controlPaneRowStyle: {
                insets: "2px 10px",
                cellSpacing: 3,
                layoutData: {
                    overflow: Echo.SplitPane.OVERFLOW_HIDDEN,
                    background: "#cfcfdf"
                }
            },
            
            /**
             * Default style object applied to control pane option buttons.
             */
            controlPaneButtonStyle: {
                insets: "0px 8px",
                lineWrap: false,
                foreground: "#000000",
                rolloverEnabled: true,
                rolloverForeground: "#6f0f0f"
            },
            
            /**
             * Default enabled feature set.
             */
            features: {
                menu: true, toolbar: true, undo: true, clipboard: true, alignment: true, foreground: true, background: true,
                list: true, table: true, image: true, horizontalRule: true, hyperlink: true, subscript: true, 
                bold: true, italic: true, underline: true, strikethrough: true, paragraphStyle: true, indent: true
            }
        },
        
        /**
         * Default localization strings.
         */
        resource: new Core.ResourceBundle({
            "ColorDialog.Title.Foreground":     "Text Color",
            "ColorDialog.Title.Background":     "Highlight Color",
            "ColorDialog.PromptForeground":     "Foreground:",
            "ColorDialog.PromptBackground":     "Background:",
            "Error.ClipboardAccessDisabled":    "This browser has clipboard access disabled. " + 
                                                "Use keyboard shortcuts or change your security settings.",
            "Generic.Cancel":                   "Cancel",
            "Generic.Error":                    "Error",
            "Generic.Ok":                       "Ok",
            "HyperlinkDialog.Title":            "Insert Hyperlink",
            "HyperlinkDialog.PromptURL":        "URL:",
            "HyperlinkDialog.PromptDescription":
                                                "Description Text:",
            "HyperlinkDialog.ErrorDialogTitle": "Cannot Insert Hyperlink",
            "HyperlinkDialog.ErrorDialog.URL":  "The URL entered is not valid.",
            "ImageDialog.Title":                "Insert Image",
            "ImageDialog.PromptURL":            "URL:",
            "ImageDialog.ErrorDialogTitle":     "Cannot Insert Image",
            "ImageDialog.ErrorDialog.URL":      "The URL entered is not valid.",
            "Menu.Edit":                        "Edit",
            "Menu.Undo":                        "Undo",
            "Menu.Redo":                        "Redo",
            "Menu.Cut":                         "Cut",
            "Menu.Copy":                        "Copy",
            "Menu.Paste":                       "Paste",
            "Menu.Delete":                      "Delete",
            "Menu.SelectAll":                   "Select All",
            "Menu.Insert":                      "Insert",
            "Menu.InsertImage":                 "Image...",
            "Menu.InsertHyperlink":             "Hyperlink...",
            "Menu.InsertHorizontalRule":        "Horizontal Rule",
            "Menu.Table":                       "Table",
            "Menu.Table.New":                   "New Table...",
            "Menu.Table.DeleteRow":             "Delete Row",
            "Menu.Table.DeleteColumn":          "Delete Column",
            "Menu.Table.InsertRow":             "Insert Row",
            "Menu.Table.InsertColumn":          "Insert Column",
            "Menu.BulletedList":                "Bulleted List",
            "Menu.NumberedList":                "Numbered List",
            "Menu.Format":                      "Format",
            "Menu.Bold":                        "Bold",
            "Menu.Italic":                      "Italic",
            "Menu.Underline":                   "Underline",
            "Menu.Strikethrough":               "Strikethrough",
            "Menu.Superscript":                 "Superscript",
            "Menu.Subscript":                   "Subscript",
            "Menu.PlainText":                   "Plain Text",
            "Menu.TextStyle":                   "Text Style",
            "Menu.ParagraphStyle":              "Paragraph Style",
            "Menu.Alignment":                   "Alignment",
            "Menu.Left":                        "Left",
            "Menu.Right":                       "Right",
            "Menu.Center":                      "Center",
            "Menu.Justified":                   "Justified",
            "Menu.Indent":                      "Indent",
            "Menu.Outdent":                     "Outdent",
            "Menu.SetForeground":               "Set Text Color...",
            "Menu.SetBackground":               "Set Highlight Color...",
            "Menu.Heading1":                    "Heading 1",
            "Menu.Heading2":                    "Heading 2",
            "Menu.Heading3":                    "Heading 3",
            "Menu.Heading4":                    "Heading 4",
            "Menu.Heading5":                    "Heading 5",
            "Menu.Heading6":                    "Heading 6",
            "Menu.Normal":                      "Normal",
            "Menu.Preformatted":                "Preformatted",
            "TableDialog.Title":                "Insert Table",
            "TableDialog.PromptRows":           "Rows:",
            "TableDialog.PromptColumns":        "Columns:",
            "TableDialog.ErrorDialogTitle":     "Cannot Insert Table",
            "TableDialog.ErrorDialog.Columns":  "The entered columns value is not valid.  " +
                                                "Please specify a number between 1 and 50.",
            "TableDialog.ErrorDialog.Rows":     "The entered rows value is not valid.  Please specify a number between 1 and 50."
        })
    },
    
    /**
     * Method reference to _processDialogClose().
     * @type Function
     */
    _processDialogCloseRef: null,

    /**
     * Listener to receive execCommand events from component.
     * @type Function
     */
    _execCommandListener: null,

    $load: function() {
        Echo.Render.registerPeer("Extras.RichTextArea", this);
    },

    $virtual: {
    
        /**
         * Creates/returns the icon set for this RichTextArea.
         * 
         * @return the icon set (name to URL mapping) object
         */
        getIcons: function() {
            var icons = this._getDefaultIcons();
            var customIcons = this.component.get("icons");
            if (customIcons) {
                for (var x in customIcons) {
                    icons[x] = customIcons[x];
                }
            }
            return icons;
        },
        
        /**
         * Event handler for user request (from menu/toolbar) to insert a hyperlink.
         * 
         * @param e the event
         */
        processInsertHyperlink: function(e) {
            var hyperlinkDialog = new Extras.Sync.RichTextArea.HyperlinkDialog(this.component);
            hyperlinkDialog.addListener("insertHyperlink", Core.method(this, function(e) {
                this._richTextInput.insertHtml("<a href=\"" + e.data.url + "\">" +
                        (e.data.description ? e.data.description : e.data.url) + "</a>");
                this.focusDocument();
            }));
            this._openDialog(hyperlinkDialog);
        },
        
        /**
         * Event handler for user request (from menu/toolbar) to insert an image.
         * 
         * @param e the event
         */
        processInsertImage: function(e) {
            var imageDialog = new Extras.Sync.RichTextArea.ImageDialog(this.component);
            imageDialog.addListener("insertImage", Core.method(this, function(e) {
                this._richTextInput.insertHtml("<img src=\"" + e.data.url + "\">");
                this.focusDocument();
            }));
            this._openDialog(imageDialog);
        },

        /**
         * Event handler for user request (from menu/toolbar) to insert a table.
         * 
         * @param e the event
         */
        processNewTable: function(e) {
            var tableDialog = new Extras.Sync.RichTextArea.TableDialog(this.component);
            tableDialog.addListener("tableInsert", Core.method(this, function(e) {
                this.newTable(e.data.columns, e.data.rows);
                this.focusDocument();
            }));
            this._openDialog(tableDialog);
        },

        /**
         * Event handler for user request (from menu/toolbar) to set the background color.
         * 
         * @param e the event
         */
        processSetBackground: function(e) {
            var colorDialog = new Extras.Sync.RichTextArea.ColorDialog(this.component, true,
                    this._toolbarButtons.background.get("color"));
            colorDialog.addListener("colorSelect", Core.method(this, function(e) {
                this.execCommand("background", e.data);
                this._toolbarButtons.background.set("color", e.data);
                this.focusDocument();
            }));
            this._openDialog(colorDialog);
        },
        
        /**
         * Event handler for user request (from menu/toolbar) to set the foreground color.
         * 
         * @param e the event
         */
        processSetForeground: function(e) {
            var colorDialog = new Extras.Sync.RichTextArea.ColorDialog(this.component, false,
                    this._toolbarButtons.foreground.get("color"));
            colorDialog.addListener("colorSelect", Core.method(this, function(e) {
                this.execCommand("foreground", e.data);
                this._toolbarButtons.foreground.set("color", e.data);
                this.focusDocument();
            }));
            this._openDialog(colorDialog);
        }
    },
    
    /**
     * Localized messages for rendered locale.
     */
    msg: null,
    
    /**
     * Mapping between icon names and icon URLs.
     */
    icons: null,
    
    /**
     * {Boolean} Flag indicating whether the parent component is a pane, and thus whether the RichTextArea should consume
     * horizontal and vertical space.
     * @type Boolean
     */
    _paneRender: false,
    
    /**
     * Mapping between toolbar button action commands and toolbar buttons.
     */
    _toolbarButtons: null,
    
    /**
     * Style selection drop down.
     * @type Echo.SelectField
     */
    _styleSelect: null,
    
    /**
     * The rich text input component.
     * 
     * @type Extras.RichTextInput
     */
    _richTextInput: null,
    
    /**
     * Root rendered DIV element.
     */
    _mainDiv: null,
    
    /** Constructor. */
    $construct: function() {
        this._execCommandListener = Core.method(this, function(e) {
            this.execCommand(e.commandName, e.value);
        });
        this._processDialogCloseRef = Core.method(this, this._processDialogClose);
        this._toolbarButtons = { };
    },
    
    /**
     * Adds listeners to supported Extras.RichTextArea object.
     */
    _addComponentListeners: function() {
        this.component.addListener("execCommand", this._execCommandListener);
    },

    /** @see #Echo.Arc.ComponentSync#createComponent */
    createComponent: function() {
        var features = this.component.render("features", Extras.Sync.RichTextArea.DEFAULTS.features);

        var contentPane = new Echo.ContentPane();
        var cursor = contentPane;

        if (features.menu) {
            var menuSplitPane = new Echo.SplitPane({
                orientation: Echo.SplitPane.ORIENTATION_VERTICAL_TOP_BOTTOM,
                autoPositioned: true,
                children: [
                    this._createMenu()
                ]
            });
            cursor.add(menuSplitPane);
            cursor = menuSplitPane;
        }
        
        if (features.toolbar) {
            var toolbarContainer = new Echo.SplitPane({
                orientation: Echo.SplitPane.ORIENTATION_VERTICAL_TOP_BOTTOM,
                autoPositioned: true,
                children: [
                    this._createToolbar()
                ]
            });
            cursor.add(toolbarContainer);
            cursor = toolbarContainer;
        }
        
        this._richTextInput = new Extras.RichTextInput({
            layoutData: {
                overflow: Echo.SplitPane.OVERFLOW_HIDDEN
            },
            background: this.component.render("background"),
            backgroundImage: this.component.render("backgroundImage"),
            border: this.component.render("border"),
            foreground: this.component.render("foreground"),
            text: this.component.get("text"),
            events: {
                action: Core.method(this, function(e) {
                    this.component.doAction();
                }),
                cursorStyleChange: Core.method(this, this._processCursorStyleChange),
                property: Core.method(this, function(e) {
                    if (e.propertyName == "text") {
                        this._processTextUpdate(e);
                    }
                })
            }
        });
        cursor.add(this._richTextInput);
        
        return contentPane;
    },
    
    /**
     * Creates the model for the menu bar based on enable feature set.
     *
     * @return the menu model
     * @type Extras.MenuModel
     */
    _createMainMenuBarModel: function() {
        var features = this.component.render("features", Extras.Sync.RichTextArea.DEFAULTS.features);
        var menu = new Extras.MenuModel(null, null, null);
        
        if (features.undo || features.clipboard) {
            var editMenu = new Extras.MenuModel(null, this.msg["Menu.Edit"], null);
            if (features.undo) {
                editMenu.addItem(new Extras.OptionModel("/undo", this.msg["Menu.Undo"], this.icons.undo));
                editMenu.addItem(new Extras.OptionModel("/redo", this.msg["Menu.Redo"], this.icons.redo));
            }
            if (features.undo && features.clipboard) {
                editMenu.addItem(new Extras.SeparatorModel());
            }
            if (features.clipboard) {
                editMenu.addItem(new Extras.OptionModel("cut", this.msg["Menu.Cut"], this.icons.cut));
                editMenu.addItem(new Extras.OptionModel("copy", this.msg["Menu.Copy"], this.icons.copy));
                editMenu.addItem(new Extras.OptionModel("paste", this.msg["Menu.Paste"], this.icons.paste));
                editMenu.addItem(new Extras.OptionModel("delete", this.msg["Menu.Delete"], this.icons["delete"]));
                editMenu.addItem(new Extras.SeparatorModel());
                editMenu.addItem(new Extras.OptionModel("/selectall", this.msg["Menu.SelectAll"], this.icons.selectAll));
            }
            menu.addItem(editMenu);
        }
        
        if (features.list || features.horizontalRule || features.image || features.hyperlink) {
            var insertMenu = new Extras.MenuModel(null, this.msg["Menu.Insert"], null);
            if (features.list || features.unorderedList) {
                insertMenu.addItem(new Extras.OptionModel("/insertunorderedlist", this.msg["Menu.BulletedList"],
                        this.icons.bulletedList));
            }
            if (features.list || features.orderedList) {
                insertMenu.addItem(new Extras.OptionModel("/insertorderedlist", this.msg["Menu.NumberedList"],
                        this.icons.numberedList));
            }
            insertMenu.addItem(new Extras.SeparatorModel());
            if (features.horizontalRule) {
                insertMenu.addItem(new Extras.OptionModel("/inserthorizontalrule", this.msg["Menu.InsertHorizontalRule"],
                        this.icons.horizontalRule));
            }
            if (features.image) {
                insertMenu.addItem(new Extras.OptionModel("insertimage", this.msg["Menu.InsertImage"], this.icons.image));
            }
            if (features.hyperlink) {
                insertMenu.addItem(new Extras.OptionModel("inserthyperlink", this.msg["Menu.InsertHyperlink"],
                        this.icons.hyperlink));
            }
            menu.addItem(insertMenu);
        }
        
        if (features.bold || features.italic || features.underline || features.strikeThrough || 
                features.subscript || features.paragraphStyle || features.alignment || features.indent || 
                features.foreground || features.background) {
            var formatMenu =  new Extras.MenuModel(null, this.msg["Menu.Format"], null);
            if (features.bold || features.italic || features.underline || features.strikeThrough || 
                    features.subscript) {
            }
            if (features.paragraphStyle) {
                formatMenu.addItem(new Extras.MenuModel(null, this.msg["Menu.ParagraphStyle"], this.icons.paragraphStyle, [
                    new Extras.OptionModel("/formatblock/<p>", this.msg["Menu.Normal"], this.icons.styleNormal),
                    new Extras.OptionModel("/formatblock/<pre>", this.msg["Menu.Preformatted"], this.icons.stylePreformatted),
                    new Extras.OptionModel("/formatblock/<h1>", this.msg["Menu.Heading1"], this.icons.styleH1),
                    new Extras.OptionModel("/formatblock/<h2>", this.msg["Menu.Heading2"], this.icons.styleH2),
                    new Extras.OptionModel("/formatblock/<h3>", this.msg["Menu.Heading3"], this.icons.styleH3),
                    new Extras.OptionModel("/formatblock/<h4>", this.msg["Menu.Heading4"], this.icons.styleH4),
                    new Extras.OptionModel("/formatblock/<h5>", this.msg["Menu.Heading5"], this.icons.styleH5),
                    new Extras.OptionModel("/formatblock/<h6>", this.msg["Menu.Heading6"], this.icons.styleH6)
                ]));
            }
            if (features.bold || features.italic || features.underline || features.strikeThrough || features.subscript) {
                var textMenu = new Extras.MenuModel(null, this.msg["Menu.TextStyle"], this.icons.textStyle);
                textMenu.addItem(new Extras.OptionModel("/removeformat",  this.msg["Menu.PlainText"], this.icons.plainText));
                textMenu.addItem(new Extras.SeparatorModel());
                if (features.bold) {
                    textMenu.addItem(new Extras.OptionModel("/bold",  this.msg["Menu.Bold"], this.icons.bold));
                }
                if (features.italic) {
                    textMenu.addItem(new Extras.OptionModel("/italic",  this.msg["Menu.Italic"], this.icons.italic));
                }
                if (features.underline) {
                    textMenu.addItem(new Extras.OptionModel("/underline",  this.msg["Menu.Underline"], this.icons.underline));
                }
                if (features.strikethrough) {
                    textMenu.addItem(new Extras.OptionModel("/strikethrough",  this.msg["Menu.Strikethrough"],
                            this.icons.strikethrough));
                }
                textMenu.addItem(new Extras.SeparatorModel());
                if (features.subscript) {
                    textMenu.addItem(new Extras.OptionModel("/superscript", this.msg["Menu.Superscript"], 
                            this.icons.superscript));
                    textMenu.addItem(new Extras.OptionModel("/subscript", this.msg["Menu.Subscript"], this.icons.subscript));
                }
                formatMenu.addItem(textMenu);
            }
            if (features.alignment) {
                formatMenu.addItem(new Extras.MenuModel(null, this.msg["Menu.Alignment"], this.icons.alignment, [
                    new Extras.OptionModel("/justifyleft",  this.msg["Menu.Left"], this.icons.alignmentLeft),
                    new Extras.OptionModel("/justifycenter",  this.msg["Menu.Center"], this.icons.alignmentCenter),
                    new Extras.OptionModel("/justifyright",  this.msg["Menu.Right"], this.icons.alignmentRight),
                    new Extras.OptionModel("/justifyfull",  this.msg["Menu.Justified"], this.icons.alignmentJustify)
                ]));
            }
            formatMenu.addItem(new Extras.SeparatorModel());
            if (features.indent) {
                formatMenu.addItem(new Extras.OptionModel("/indent",  this.msg["Menu.Indent"], this.icons.indent));
                formatMenu.addItem(new Extras.OptionModel("/outdent",  this.msg["Menu.Outdent"], this.icons.outdent));
            }
            formatMenu.addItem(new Extras.SeparatorModel());
            if (features.foreground || features.background) {
                if (features.foreground) {
                    formatMenu.addItem(new Extras.OptionModel("foreground",  this.msg["Menu.SetForeground"], 
                            this.icons.foreground));
                }
                if (features.background) {
                    formatMenu.addItem(new Extras.OptionModel("background",  this.msg["Menu.SetBackground"], 
                            this.icons.background));
                }
            }
            menu.addItem(formatMenu);
        }

        if (features.table) {
            var tableMenu = new Extras.MenuModel(null, this.msg["Menu.Table"], null);
            tableMenu.addItem(new Extras.OptionModel("tableNew", this.msg["Menu.Table.New"], this.icons.table));
            tableMenu.addItem(new Extras.SeparatorModel());
            tableMenu.addItem(new Extras.OptionModel("/tableInsertRow", this.msg["Menu.Table.InsertRow"], 
                    this.icons.tableInsertRow));
            tableMenu.addItem(new Extras.OptionModel("/tableInsertColumn", this.msg["Menu.Table.InsertColumn"], 
                    this.icons.tableInsertColumn));
            tableMenu.addItem(new Extras.SeparatorModel());
            tableMenu.addItem(new Extras.OptionModel("/tableDeleteRow", this.msg["Menu.Table.DeleteRow"], 
                    this.icons.tableDeleteRow));
            tableMenu.addItem(new Extras.OptionModel("/tableDeleteColumn", this.msg["Menu.Table.DeleteColumn"], 
                    this.icons.tableDeleteColumn));
            
            menu.addItem(tableMenu);
        }
        
        return menu;
    },
    
    /**
     * Creates main menu bar component.
     *
     * @return the main menu bar
     * @type Extras.MenuBarPane
     */
    _createMenu: function() {
        return new Extras.MenuBarPane({
            styleName: this.component.render("menuStyleName"),
            model: this._createMainMenuBarModel(),
            events: {
                action: Core.method(this, this._processMenuAction)
            }
        });
    },
    
    /**
     * Creates tool bar component.
     * 
     * @return the toolbar
     * @type Echo.Component
     */
    _createToolbar: function() {
        var row, button;
        var features = this.component.render("features", Extras.Sync.RichTextArea.DEFAULTS.features);
        var controlsRow;
        var panel = new Echo.Panel({
            styleName: this.component.render("toolbarPanelStyleName"),
            layoutData: {
                overflow: Echo.SplitPane.OVERFLOW_HIDDEN
            },
            insets: 2,
            children: [
                controlsRow = new Echo.Row({
                    styleName: this.component.render("toolbarRowStyleName"),
                    cellSpacing: 10
                })
            ]
        });
        
        // Style Dropdown.
        if (features.paragraphStyle) {
            var actionListener = Core.method(this, function(e) {
                var style = this._styleSelect.get("selectedId");
                this._richTextInput.execCommand("formatblock", "<" + style + ">");
            });
            this._styleSelect = new Echo.SelectField({
                items: [
                    { id: "p", text: this.msg["Menu.Normal"] },
                    { id: "pre", text: this.msg["Menu.Preformatted"] },
                    { id: "h1", text: this.msg["Menu.Heading1"] },
                    { id: "h2", text: this.msg["Menu.Heading2"] },
                    { id: "h3", text: this.msg["Menu.Heading3"] },
                    { id: "h4", text: this.msg["Menu.Heading4"] },
                    { id: "h5", text: this.msg["Menu.Heading5"] },
                    { id: "h6", text: this.msg["Menu.Heading6"] }
                ],
                events: {
                    action: actionListener
                }
            });
            controlsRow.add(this._styleSelect);
        }

        // Undo/Redo Tools
        if (features.undo) {
            controlsRow.add(new Echo.Row({
                children: [
                    this._createToolbarButton("<<<", this.icons.undo, this.msg["Menu.Undo"], this._processCommand, "undo"),
                    this._createToolbarButton(">>>", this.icons.redo, this.msg["Menu.Redo"], this._processCommand, "redo")
                ]
            }));
        }
        
        // Font Bold/Italic/Underline Tools
        if (features.bold || features.italic || features.underline) {
            row = new Echo.Row();
            if (features.bold) {
                button = this._createToolbarButton("B", this.icons.bold, this.msg["Menu.Bold"], this._processCommand, "bold");
                button.set("toggle", true);
                row.add(button);
            }
            if (features.italic) {
                button = this._createToolbarButton("I", this.icons.italic, this.msg["Menu.Italic"], 
                        this._processCommand, "italic");
                button.set("toggle", true);
                row.add(button);
            }
            if (features.underline) {
                button = this._createToolbarButton("U", this.icons.underline, this.msg["Menu.Underline"], 
                        this._processCommand, "underline");
                button.set("toggle", true);
                row.add(button);
            }
            controlsRow.add(row);
        }
        
        //Super/Subscript Tools
        if (features.subscript) {
            controlsRow.add(new Echo.Row({
                children: [
                    this._createToolbarButton("^", this.icons.superscript, this.msg["Menu.Superscript"], 
                            this._processCommand, "superscript"),
                    this._createToolbarButton("v", this.icons.subscript,this.msg["Menu.Subscript"], 
                            this._processCommand, "subscript")
                ]
            }));
        }
        
        // Alignment Tools
        if (features.alignment) {
            controlsRow.add(new Echo.Row({
                children: [
                    this._createToolbarButton("<-", this.icons.alignmentLeft, this.msg["Menu.Left"], 
                            this._processCommand, "justifyleft"),
                    this._createToolbarButton("-|-", this.icons.alignmentCenter, this.msg["Menu.Center"], 
                            this._processCommand, "justifycenter"),
                    this._createToolbarButton("->", this.icons.alignmentRight, this.msg["Menu.Right"], 
                            this._processCommand, "justifyright"),
                    this._createToolbarButton("||", this.icons.alignmentJustify, this.msg["Menu.Justified"], 
                            this._processCommand, "justifyfull")
                ]
            }));
        }
        
        // Color Tools
        if (features.foreground || features.background) {
            row = new Echo.Row();
            if (features.foreground) {
                row.add(this._createToolbarButton("FG", this.icons.foreground, this.msg["Menu.SetForeground"], 
                        this.processSetForeground, "foreground"));
            }
            if (features.background) {
                row.add(this._createToolbarButton("BG", this.icons.background, this.msg["Menu.SetBackground"], 
                        this.processSetBackground, "background"));
            }
            controlsRow.add(row);
        }
        
        // Insert Tools
        if (features.list || features.horizontalRule || features.image || features.hyperlink || features.table) {
            row = new Echo.Row();
            if (features.list || features.unorderedList) {
                row.add(this._createToolbarButton("Bulleted List", this.icons.bulletedList, this.msg["Menu.BulletedList"], 
                        this._processCommand, "insertunorderedlist"));
            }
            if (features.list || features.orderedList) {
                row.add(this._createToolbarButton("Numbered List", this.icons.numberedList, this.msg["Menu.NumberedList"], 
                        this._processCommand, "insertorderedlist"));
            }
            if (features.horizontalRule) {
                row.add(this._createToolbarButton("Horizontal Rule", this.icons.horizontalRule,
                        this.msg["Menu.InsertHorizontalRule"],  this._processCommand, "inserthorizontalrule"));
            }
            if (features.image) {
                row.add(this._createToolbarButton("Image", this.icons.image, this.msg["Menu.InsertImage"], 
                        this.processInsertImage));
            }
            if (features.hyperlink) {
                row.add(this._createToolbarButton("Hyperlink", this.icons.hyperlink, this.msg["Menu.InsertHyperlink"], 
                        this.processInsertHyperlink));
            }
            if (features.table) {
                row.add(this._createToolbarButton("Table", this.icons.table, this.msg["Menu.NewTable"], 
                        this.processNewTable));
            }
            controlsRow.add(row);
        }
        
        return panel;
    },
    
    /**
     * Creates a toolbar button.
     * 
     * @param {String} text the button text
     * @param {#ImageReference} icon the button icon
     * @param {String} toolTipText the rollover tool tip text
     * @param {Function} eventMethod the method to invoke when the button is clicked (must be a method of this object,
     *        will automatically be wrapped using Core.method()) 
     * @param {String} actionCommand the action command to send in fired events
     * @return the toolbar button
     * @type Extras.Sync.RichTextArea.ToolbarButton
     */
    _createToolbarButton: function(text, icon, toolTipText, eventMethod, actionCommand) {
        var button = new Extras.Sync.RichTextArea.ToolbarButton({
            actionCommand: actionCommand,
            styleName: this.component.render("toolbarButtonStyleName"),
            text: icon ? null : text,
            icon: icon,
            toolTipText: toolTipText
        });
        if (eventMethod) {
            button.addListener("action", Core.method(this, eventMethod));
        }
        this._toolbarButtons[actionCommand] = button;
        return button;
    },
    
    /**
     * Executes a rich-text editing command.  Delegates to RichTextInput peer.
     * 
     * @param {String} commandName the command name
     * @param {String} value the (optional) value to send
     */
    execCommand: function(commandName, value) {
        this._richTextInput.execCommand(commandName, value);
    },
    
    /**
     * Focuses the edited document.  Delegates to RichTextInput peer.
     */
    focusDocument: function() {
        this.arcApplication.setFocusedComponent(this._richTextInput);
    },
    
    /** @see Echo.Arc.ComponentSync#getDomainElement */
    getDomainElement: function() { 
        return this._mainDiv;
    },
    
    /**
     * Creates and returns a default icon name to URL map object.
     * @type Object
     */
    _getDefaultIcons: function() {
        var iconNames = {
            "16": [ "alignment", "alignmentCenter", "alignmentJustify", "alignmentLeft", "alignmentRight",
                "background", "bold", "bulletedList", "cancel", "copy", "cut", "delete", "foreground", "horizontalRule",
                "hyperlink", "image", "indent", "italic", "numberedList", "ok", "outdent", "paragraphStyle", "paste", "plainText", 
                "redo", "selectAll", "strikethrough", 
                "subscript", "superscript", "table", "tableInsertRow", "tableDeleteRow", "tableInsertColumn", "tableDeleteColumn",
                "textStyle", "underline", "undo" ],
            "24": [ "ok", "cancel" ]
        };
        var defaultIcons = { };
        for (var size in iconNames) {
            for (var i = 0; i < iconNames[size].length; ++i) {
                var iconResource = iconNames[size][i].charAt(0).toUpperCase() + iconNames[size][i].substring(1);
                defaultIcons[iconNames[size][i]] = this.client.getResourceUrl("Extras", 
                        "image/richtext/Icon" + size + iconResource + ".png");
            }
        }
        return defaultIcons;
    },
    
    /**
     * Inserts an image at the cursor position.
     * 
     * @param {String} url the image URL
     */
    insertImage: function(url) {
        this._richTextInput.insertHtml("<img src=\"" + url + "\">");
    },
    
    /**
     * Inserts an HTML table at the cursor position.
     * 
     * @param {Number} columns the number of columns
     * @param {Number} rows the number of rows
     */
    newTable: function(columns, rows) {
        var rowHtml = "",
            i,
            cellContent = Core.Web.Env.ENGINE_MSHTML ? "" : "<br/>";
        for (i = 0; i < columns; ++i) {
            rowHtml += "<td>" + cellContent + "</td>";
        }
        rowHtml = "<tr>" + rowHtml + "</tr>";
        var tableHtml = "<table width=\"100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"1\"><tbody>";
        for (i = 0; i < rows; ++i) {
            tableHtml += rowHtml;
        }
        tableHtml += "</tbody></table>";
        this._richTextInput.insertHtml(tableHtml);
    },
    
    /**
     * Opens a dialog window.  The dialog is displayed in an OverlayPane which shows
     * the dialog over the application, rather than simply over the RichTextArea itself. 
     * 
     * @param {Echo.WindowPane} dialogWindow the dialog to open 
     */
    _openDialog: function(dialogWindow) {
        // Activate overlay pane (if required).
        var contentPane;
        if (this._overlayPane == null) {
            this._overlayPane = new Extras.Sync.RichTextArea.OverlayPane();
            this._overlayPane.rta = this.component;
            contentPane = new Echo.ContentPane();
            this._overlayPane.add(contentPane);
            this.baseComponent.add(this._overlayPane);
        } else {
            contentPane = this._overlayPane.children[0];
        }
        
        // Add dialog to overlay pane.
        contentPane.add(dialogWindow);

        // Add parent-change listener to dialog so that overlay pane can be
        // deactivated when necessary.
        dialogWindow.addListener("parent", this._processDialogCloseRef);
    },
    
    /**
     * Processes a simple editor command action.  The event's actionCommand is sent to the input peer as the editor command name.
     * This method is registered as a listener to various toolbar buttons.
     * 
     * @param e the event
     */
    _processCommand: function(e) {
        this.execCommand(e.actionCommand);
        this.focusDocument();
    },
    
    /**
     * Updates the status of various press-able toolbar buttons to indicate the state of the text at the cursor position
     * (e.g., bold/italic/underline, color, style selection).  
     */
    _processCursorStyleChange: function(e) {
        if (this._toolbarButtons.bold) {
            this._toolbarButtons.bold.set("pressed", e.style.bold);
        }
        if (this._toolbarButtons.italic) {
            this._toolbarButtons.italic.set("pressed", e.style.italic);
        }
        if (this._toolbarButtons.underline) {
            this._toolbarButtons.underline.set("pressed", e.style.underline);
        }
        if (this._toolbarButtons.foreground) {
            this._toolbarButtons.foreground.set("color", e.style.foreground || "#000000");
        }
        if (this._toolbarButtons.background) {
            this._toolbarButtons.background.set("color", e.style.background || "#ffffff");
        }
        if (this._styleSelect) {
            this._styleSelect.set("selectedId", e.style.paragraphStyle);
        }
    },
    
    /**
     * Processes a dialog closing (de-parenting) event.
     * Removes the OverlayPane.
     * 
     * @param e the event
     */
    _processDialogClose: function(e) {
        if (e.newValue != null) {
            return;
        }
        
        // Deactivate overlay pane if it has no content.
        if (this._overlayPane.children[0].children.length === 0) {
            this.baseComponent.remove(this._overlayPane);
            this._overlayPane = null;
        }
        
        // Remove dialog parent-change listener.
        e.source.removeListener("parent", this._processDialogCloseRef);
    },
    
    /**
     * Processes an action received from the menu bar.
     * 
     * @param e the event
     */
    _processMenuAction: function(e) {
        if (e.modelId.charAt(0) == '/') {
            var separatorIndex = e.modelId.indexOf("/", 1);
            if (separatorIndex == -1) {
                this._richTextInput.execCommand(e.modelId.substring(1));
            } else {
                this._richTextInput.execCommand(e.modelId.substring(1, separatorIndex),
                        e.modelId.substring(separatorIndex + 1));
            }
        } else {
            switch (e.modelId) {
            case "foreground":
                this.processSetForeground();
                break;
            case "background":
                this.processSetBackground();
                break;
            case "tableNew":
                this.processNewTable();
                break;
            case "inserthyperlink":
                this.processInsertHyperlink();
                break;
            case "insertimage":
                this.processInsertImage();
                break;
            case "cut":
            case "copy":
            case "paste":
            case "delete":
                try {
                    this._richTextInput.execCommand(e.modelId);
                } catch (ex) {
                    this._openDialog(new Extras.Sync.RichTextArea.MessageDialog(this.component,
                            this.msg["Generic.Error"], this.msg["Error.ClipboardAccessDisabled"])); 
                }
            }
        }
    },
    
    _processTextUpdate: function(e) {
        this.component.set("text", e.newValue);
    },
    
    /**
     * Removes listeners from supported Extras.RichTextArea object.
     */
    _removeComponentListeners: function() {
        this.component.removeListener("execCommand", this._execCommandListener);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._addComponentListeners();
        this.msg = Extras.Sync.RichTextArea.resource.get(this.component.getRenderLocale());

        this.icons = this.getIcons();
        if (!this.icons) {
            this.icons = {};
        }
        
        this._paneRender = this.component.parent.pane;
        
        this._mainDiv = document.createElement("div");
        this._mainDiv.id = this.component.renderId;

        if (this._paneRender) {
            this._mainDiv.style.cssText = "position:absolute;top:0px;left:0px;right:0px;bottom:0px;";
        } else {
            this._mainDiv.style.position = "relative";
            // FIXME. set height of component based on height setting.
            this._mainDiv.style.height = "300px";
        }
        
        parentElement.appendChild(this._mainDiv);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        Core.Web.VirtualPosition.redraw(this._mainDiv);
        Echo.Arc.ComponentSync.prototype.renderDisplay.call(this);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._removeComponentListeners();
        Echo.Arc.ComponentSync.prototype.renderDispose.call(this, update);
        this._mainDiv = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        this.arcApplication.setFocusedComponent(this._richTextInput);
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.isUpdatedPropertySetIn({text: true })) {
            this._richTextInput.set("text", this.component.get("text"));
            update.renderContext.displayRequired = [];
            return;
        }
    
        var element = this._mainDiv;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
    }
});

/**
 * Abstract dialog message box.  Displays arbitrary content and  provides the user "Ok" and/or "Cancel" options.
 */
Extras.Sync.RichTextArea.AbstractDialog = Core.extend(Echo.WindowPane, {

    $static: {

        /**
         * Type flag indicating only an "Ok" option should be made available.
         */
        TYPE_OK: 0,

        /**
         * Type flag indicating both "Ok" and "Cancel" options should be made available.
         */
        TYPE_OK_CANCEL: 1
    },
    
    $abstract: true,
    
    /**
     * The owning RichTextArea.
     * @type Extras.RichTextArea
     */
    rta: null,

    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} rta the owning RichTextArea
     * @param {Number} type the dialog type, either <code>TYPE_OK</code> or <code>TYPE_OK_CANCEL</code>
     * @param properties initial properties to be set on the WindowPane
     * @param {Echo.Component} content the component to display within the dialog 
     */
    $construct: function(rta, type, properties, content) {
        this.rta = rta;
    
        var controlPaneSplitPaneStyleName = rta.render("controlPaneSplitPaneStyleName");
        var controlPaneRowStyleName = rta.render("controlPaneRowStyleName");
        var controlPaneButtonStyleName = rta.render("controlPaneButtonStyleName"); 
        
        // Build control.
        Echo.WindowPane.call(this, {
            styleName: rta.render("windowPaneStyleName"),
            iconInsets: "6px 10px",
            contentWidth: "25em",
            modal: true,
            resizable: false,
            events: {
                close: Core.method(this, this.processCancel)
            },
            children: [
                new Echo.SplitPane({
                    orientation: Echo.SplitPane.ORIENTATION_VERTICAL_BOTTOM_TOP,
                    autoPositioned: true,
                    styleName: controlPaneSplitPaneStyleName,
                    style: controlPaneSplitPaneStyleName ? null : Extras.Sync.RichTextArea.DEFAULTS.controlPaneStyle,
                    children: [
                        this.controlsRow = new Echo.Row({
                            styleName: controlPaneRowStyleName,
                            style: controlPaneRowStyleName ? null : Extras.Sync.RichTextArea.DEFAULTS.controlPaneRowStyle
                        }),
                        content
                    ]
                })
            ]
        });
        
        // Add OK button.
        this.controlsRow.add(new Echo.Button({
            styleName: controlPaneButtonStyleName,
            style: controlPaneButtonStyleName ? null : Extras.Sync.RichTextArea.DEFAULTS.controlPaneButtonStyle,
            text: rta.peer.msg["Generic.Ok"],
            icon: rta.peer.icons.ok,
            events: {
                action: Core.method(this, this.processOk)
            }
        }));
        
        // Add Cancel button.
        if (type == Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK_CANCEL) {
            this.controlsRow.add(new Echo.Button({
                styleName: controlPaneButtonStyleName,
                style: controlPaneButtonStyleName ? null : Extras.Sync.RichTextArea.DEFAULTS.controlPaneButtonStyle,
                text: rta.peer.msg["Generic.Cancel"],
                icon: rta.peer.icons.cancel,
                events: {
                    action: Core.method(this, this.processCancel)
                }
            }));
        }
        
        // Set properties.
        for (var x in properties) {
            this.set(x, properties[x]);
        }
    },
    
    $virtual: {
        
        /**
         * Processes a user selection of the "Cancel" button.
         * 
         * @param e the event
         */
        processCancel: function(e) {
            this.parent.remove(this);
        },
        
        /**
         * Processes a user selection of the "OK" button.
         * 
         * @param e the event
         */
        processOk: function(e) {
            this.parent.remove(this);
        }
    }
});

/**
 * Color selection dialog.
 */
Extras.Sync.RichTextArea.ColorDialog = Core.extend(Extras.Sync.RichTextArea.AbstractDialog, {

    $static: {
    
        /**
         * Default color swatch values.  
         * Sourced from Tango color palete: http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines
         * @type Array
         */
        COLORS: [ 
                "#fce94f", "#edd400", "#c4a000",
                "#fcaf3e", "#f57900", "#e8b86e",
                "#e9b96e", "#c17d11", "#8f5902",
                "#8ae234", "#73d216", "#4e9a06",
                "#729fcf", "#3465a4", "#204a87",
                "#ad7fa8", "#75507b", "#5c3566",
                "#ef2929", "#cc0000", "#a40000",
                "#eeeeec", "#d3d7cf", "#babdb6",
                "#888a85", "#555753", "#2e3436",
                "#ffffff", "#7f7f7f", "#000000"
        ]
    },
    
    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} rta the RichTextArea
     * @param {Boolean} setBackground flag indicating whether background (true) or foreground (false) is being set
     * @param {#Color} initialColor the initially selected color
     */
    $construct: function(rta, setBackground, initialColor) {
        Extras.Sync.RichTextArea.AbstractDialog.call(this, rta,
                Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK_CANCEL, 
                {
                    title: rta.peer.msg[setBackground ? 
                            "ColorDialog.Title.Background" : "ColorDialog.Title.Foreground"],
                    icon: setBackground ? rta.peer.icons.background : rta.peer.icons.foreground,
                    contentWidth: "32em"
                },
                new Echo.Row({
                    cellSpacing: "1em",
                    insets: "1em",
                    children: [
                        new Echo.Column({
                            children: [
                                new Echo.Label({
                                    text: rta.peer.msg[
                                            setBackground ? "ColorDialog.PromptBackground" : "ColorDialog.PromptForeground"]
                                }),
                                this._colorSelect = new Extras.ColorSelect({
                                    color: initialColor,
                                    displayValue: true
                                })
                            ]
                        }),
                        new Echo.Grid({
                            insets: 2,
                            size: 3,
                            children: this._createSwatches()
                        })
                    ]
                }));
    },
    
    /**
     * Creates and returns an array of Echo.Button components which are used to select pre-set color values.
     * 
     * @return the color swatch buttons
     * @type Array
     */
    _createSwatches: function() {
        var children = [];
        var COLORS = Extras.Sync.RichTextArea.ColorDialog.COLORS;
        var actionListener = Core.method(this, function(e) {
            this._colorSelect.set("color", e.actionCommand);
        });
        for (var i = 0; i < COLORS.length; ++i) {
            children.push(new Echo.Button({
                height: "1em",
                width: "3em",
                background: COLORS[i],
                border: "1px outset " + COLORS[i],
                actionCommand: COLORS[i],
                events: {
                    action: actionListener
                }
            }));
        }
        return children;
    },
    
    /** @see Extras.Sync.RichTextArea.AbstractDialog#processOk */
    processOk: function(e) {
        var color = this._colorSelect.get("color");
        this.parent.remove(this);
        this.fireEvent({type: "colorSelect", source: this, data : color});
    }
});

/**
 * Add Hyperlink Dialog.
 */
Extras.Sync.RichTextArea.HyperlinkDialog = Core.extend(Extras.Sync.RichTextArea.AbstractDialog, {

    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} rta the RichTextArea
     */
    $construct: function(rta) {
        Extras.Sync.RichTextArea.AbstractDialog.call(this, rta,
                Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK_CANCEL,
                {
                    title: rta.peer.msg["HyperlinkDialog.Title"], 
                    icon: rta.peer.icons.hyperlink
                },
                new Echo.Column({
                    insets: 10,
                    children: [
                        new Echo.Label({
                            text: rta.peer.msg["HyperlinkDialog.PromptURL"]
                        }),
                        this._urlField = new Echo.TextField({
                            width: "100%"
                        }),
                        new Echo.Label({
                            text: rta.peer.msg["HyperlinkDialog.PromptDescription"]
                        }),
                        this._descriptionField = new Echo.TextField({
                            width: "100%"
                        })
                    ]
                }));
    },
    
    /** @see Extras.Sync.RichTextArea.AbstractDialog#processOk */
    processOk: function(e) {
        var data = {
            url: this._urlField.get("text"),
            description: this._descriptionField.get("text")
        };
        if (!data.url) {
            this.parent.add(new Extras.Sync.RichTextArea.MessageDialog(this.rta, 
                    this.rta.peer.msg["HyperlinkDialog.ErrorDialogTitle"], 
                    this.rta.peer.msg["HyperlinkDialog.ErrorDialog.URL"]));
            return;
        }
        this.parent.remove(this);
        this.fireEvent({type: "insertHyperlink", source: this, data: data});
    }
});

/**
 * Add Image Dialog.
 */
Extras.Sync.RichTextArea.ImageDialog = Core.extend(Extras.Sync.RichTextArea.AbstractDialog, {

    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} rta the RichTextArea
     */
    $construct: function(rta) {
        Extras.Sync.RichTextArea.AbstractDialog.call(this, rta,
                Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK_CANCEL,
                {
                    title: rta.peer.msg["ImageDialog.Title"], 
                    icon: rta.peer.icons.image
                },
                new Echo.Column({
                    insets: 10,
                    children: [
                        new Echo.Label({
                            text: rta.peer.msg["ImageDialog.PromptURL"]
                        }),
                        this._urlField = new Echo.TextField({
                            width: "100%"
                        })
                    ]
                }));
    },
    
    /** @see Extras.Sync.RichTextArea.AbstractDialog#processOk */
    processOk: function(e) {
        var data = {
            url: this._urlField.get("text")
        };
        if (!data.url) {
            this.parent.add(new Extras.Sync.RichTextArea.MessageDialog(this.rta, 
                    this.rta.peer.msg["ImageDialog.ErrorDialogTitle"], 
                    this.rta.peer.msg["ImageDialog.ErrorDialog.URL"]));
            return;
        }
        this.parent.remove(this);
        this.fireEvent({type: "insertImage", source: this, data: data});
    }
});

/**
 * Pane which renders its content over the entire domain of the application.  
 */
Extras.Sync.RichTextArea.OverlayPane = Core.extend(Echo.Component, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.RichTextOverlayPane", this);
    },
    
    /**
     * The supported RichTextArea.
     * @type Extras.RichTextArea
     */
    rta: null,
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.RichTextOverlayPane",
    
    /** @see Echo.Component#floatingPane */
    floatingPane: true,
    
    /** @see Echo.Component#pane */
    pane: true
});

/**
 * Component rendering peer: OverlayPane.
 * 
 * This component renders itself over the EchoClient's domainElement, rather than beneath its
 * specified parent element.
 */
Extras.Sync.RichTextArea.OverlayPanePeer = Core.extend(Echo.Render.ComponentSync, {

    /**
     * The rendered DIV.
     * @type Element
     */
    _div: null,

    $load: function() {
        Echo.Render.registerPeer("Extras.RichTextOverlayPane", this);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = document.createElement("div");
        this.client.addElement(this._div);
        this._div.style.cssText = "position:absolute;top:0;right:0;bottom:0;left:0;z-index:20000;";
        if (this.component.children.length == 1) {
            Echo.Render.renderComponentAdd(update, this.component.children[0], this._div);
        } else if (this.component.children.length > 1) {
            throw new Error("Too many children added to OverlayPane.");
        }
        document.body.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function(update) {
        if (this._div.style.display != "block") {
            this._div.style.display = "block";
            this.client.forceRedraw();
        }
        Core.Web.VirtualPosition.redraw(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        if (!this._div) {
            return;
        }
        this.client.removeElement(this._div);
        if (this._div.parentNode) {
            this._div.parentNode.removeChild(this._div);
        }
        this._div = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderHide */
    renderHide: function() {
        this._div.style.display = "none";
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});

/**
 * Dialog window which displays a message.
 */
Extras.Sync.RichTextArea.MessageDialog = Core.extend(
        Extras.Sync.RichTextArea.AbstractDialog, {
   
    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} the RichTextArea
     * @param {String} title the dialog title
     * @param {String} message the dialog message
     */
    $construct: function(rta, title, message) {
        Extras.Sync.RichTextArea.AbstractDialog.call(this, rta,
                Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK, {
                    title: title
                },
                new Echo.Label({
                    text: message,
                    layoutData: {
                        insets: 30
                    }
                }));
    }
});

/**
 * Table creation dialog.  Prompts user for initial settings to insert table.
 */
Extras.Sync.RichTextArea.TableDialog = Core.extend(Extras.Sync.RichTextArea.AbstractDialog, {

    /**
     * Constructor.
     * 
     * @param {Extras.RichTextArea} rta the supported RichTextArea
     */
    $construct: function(rta) {
        Extras.Sync.RichTextArea.AbstractDialog.call(this, rta,
                Extras.Sync.RichTextArea.AbstractDialog.TYPE_OK_CANCEL, {
                    title: rta.peer.msg["TableDialog.Title"], 
                    icon: rta.peer.icons.table,
                    contentWidth: "35em"
                },
                new Echo.Row({
                    insets: "1em",
                    cellSpacing: "1em",
                    children: [
                        this._sizeSelector = new Extras.Sync.RichTextArea.TableSizeSelector({
                            rows: 2,
                            columns: 3,
                            events: {
                                property: Core.method(this, this._processSelectorUpdate)
                            }
                        }),
                        new Echo.Grid({
                            width: "100%",
                            insets: 3,
                            children: [
                                new Echo.Label({
                                    text: rta.peer.msg["TableDialog.PromptRows"],
                                    layoutData: {
                                        alignment: "trailing"
                                    }
                                }),
                                this._rowsField = new Echo.TextField({
                                    text: "2",
                                    alignment: "center",
                                    width: "5em",
                                    events: {
                                        property: Core.method(this, this._processTextUpdate)
                                    }
                                }),
                                new Echo.Label({
                                    text: rta.peer.msg["TableDialog.PromptColumns"],
                                    layoutData: {
                                        alignment: "trailing"
                                    }
                                }),
                                this._columnsField = new Echo.TextField({
                                    text: "3",
                                    alignment: "center",
                                    width: "5em",
                                    events: {
                                        property: Core.method(this, this._processTextUpdate)
                                    }
                                })
                            ]
                        })                    
                    ]
                }));
    },
    
    /** @see Extras.Sync.RichTextArea.AbstractDialog#processOk */
    processOk: function(e) {
        var data = {
            rows: parseInt(this._rowsField.get("text"), 10),
            columns: parseInt(this._columnsField.get("text"), 10)
        };
        if (isNaN(data.rows) || data.rows < 1 || data.rows > 50) {
            this.parent.add(new Extras.Sync.RichTextArea.MessageDialog(this.rta, 
                    this.rta.peer.msg["TableDialog.ErrorDialogTitle"], 
                    this.rta.peer.msg["TableDialog.ErrorDialog.Rows"]));
            return;
        }
        if (isNaN(data.columns) || data.columns < 1 || data.columns > 50) {
            this.parent.add(new Extras.Sync.RichTextArea.MessageDialog(this.rta, 
                    this.rta.peer.msg["TableDialog.ErrorDialogTitle"], 
                    this.rta.peer.msg["TableDialog.ErrorDialog.Columns"]));
            return;
        }
        this.parent.remove(this);
        this.fireEvent({type: "tableInsert", source: this, data: data});
    },
    
    _processSelectorUpdate: function(e) {
        var columns = parseInt(this._sizeSelector.get("columns"), 10),
            rows = parseInt(this._sizeSelector.get("rows"), 10);
        this._columnsField.set("text", columns);
        this._rowsField.set("text", rows);
    },
    
    _processTextUpdate: function(e) {
        var columns = parseInt(this._columnsField.get("text"), 10),
            rows = parseInt(this._rowsField.get("text"), 10);
        if (!isNaN(columns)) {
            this._sizeSelector.set("columns", columns);
        }
        if (!isNaN(rows)) {
            this._sizeSelector.set("rows", rows);
        }
        return true;
    }
});

/**
 * Component to interactively select initial number of columns/rows for a table.
 * 
 * @cp {Number} rows the selected number of rows
 * @cp {Number} columns the selected number of columns
 * @sp {Number} rowSize the number of rows to display
 * @sp {Number} columnSize the number of columns to display
 * @sp {#Border} border the border to use for drawing table cells
 * @sp {#Color} selectedBackground the background color for drawing selected table cells
 * @sp {#Border} selectedBorder the border to use for drawing selected table cells
 */
Extras.Sync.RichTextArea.TableSizeSelector = Core.extend(Echo.Component, {
    
    $load: function() {
        Echo.ComponentFactory.registerType("Extras.RichTextTableSizeSelector", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.RichTextTableSizeSelector"
});

Extras.Sync.RichTextArea.TableSizeSelectorPeer = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Extras.RichTextTableSizeSelector", this);
    },
    
    /**
     * Main container DIV element.
     * @type Element
     */
    _div: null,
    
    /**
     * Table element.
     * @type Element
     */
    _table: null,
    
    _dragInProgress: false,
    
    _drawSelection: function() {
        var rows = parseInt(this.component.render("rows", 0), 10),
            columns = parseInt(this.component.render("columns", 0), 10),
            tr = this._table.firstChild.firstChild,
            y = 0,
            td, x, selected, border, background;
            
        while (tr) {
            td = tr.firstChild;
            x = 0;
            while (td) {
                selected = x < columns  && y < rows;
                background = selected ? this._selectedBackground : null;
                border = selected ? this._selectedBorder : this._border;
                Echo.Sync.Color.renderClear(background, td, "backgroundColor");
                Echo.Sync.Border.renderClear(border, td);
                td = td.nextSibling;
                ++x;
            }
            tr = tr.nextSibling;
            ++y;
        }
    },
    
    _processMouseDown: function(e) {
        this._dragInProgress = true;
        this._processMouseSelection(e);
        return true;
    },
    
    _processMouseMove: function(e) {
        if (this._dragInProgress) {
            this._processMouseSelection(e);
        }
        return true;
    },
    
    _processMouseSelection: function(e) {
        var x = 0, y = 0,
            element = e.target;
        if (!element.nodeName || element.nodeName.toLowerCase() != "td") {
            return;
        }
        while (element.previousSibling) {
            ++x;
            element = element.previousSibling;
        }
        element = element.parentNode;
        while (element.previousSibling) {
            ++y;
            element = element.previousSibling;
        }
        this.component.set("columns", x + 1);
        this.component.set("rows", y + 1);
        
    },
    
    _processMouseUp: function(e) {
        this._dragInProgress = false;
        return true;
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        var tbody, protoTr, tr, td, y, x;
        
        this._rowSize = this.component.render("rowSize", 10);
        this._columnSize = this.component.render("columnSize", 15);
            
        this._border = this.component.render("border", "1px outset #dfdfdf");
        this._selectedBorder = this.component.render("selectedBorder", "1px outset #4f4f5f");
        this._selectedBackground = this.component.render("selectedBackground", "#4f4f5f");
        
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        
        this._table = document.createElement("table");
        this._table.cellPadding = 0;
        this._table.cellSpacing = 0;
        this._table.style.cssText = "padding:0;border:none;font-size:1px;";
        this._table.style.width = (this._columnSize * 18) + "px";
        Echo.Sync.Color.render(this.component.render("background", "#dfdfdf"), this._table, "backgroundColor");
        tbody = document.createElement("tbody");
        this._table.appendChild(tbody);
        
        protoTr = document.createElement("tr");
        for (x = 0; x < this._columnSize; ++x) {
            td = document.createElement("td");
            td.style.cssText = "padding:0;width:16px;height:16px;";
            td.appendChild(document.createTextNode("\u00a0"));
            Echo.Sync.Border.render(this._border, td);
            protoTr.appendChild(td);
        }
        
        for (y = 0; y < this._rowSize; ++y) {
            tbody.appendChild(protoTr.cloneNode(true));
        }
        
        this._div.appendChild(this._table);
        
        Core.Web.Event.Selection.disable(this._div);
        Core.Web.Event.add(this._div, "mousedown", Core.method(this, this._processMouseDown), false);
        Core.Web.Event.add(this._div, "mousemove", Core.method(this, this._processMouseMove), false);
        Core.Web.Event.add(this._div, "mouseup", Core.method(this, this._processMouseUp), false);
        parentElement.appendChild(this._div);
        
        this._drawSelection();
    },
    
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this._div);
        this._table = null;
        this._div = null;
    },
    
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.isUpdatedPropertySetIn({ columns: true, rows: true })) {
            this._drawSelection();
            return;
        }

        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});

/**
 * Toolbar button component: a simple button component which optionally provides the capability to be toggled on/off.
 * Additionally provides the capability to show a currently selected color value (used by color selection buttons).
 * 
 * @cp {Boolean} pressed flag indicating whether button should be displayed as pressed (toggled on)
 * @sp {Boolean} toggle flag indicating whether the button supports a toggled state.
 * @sp {#Color} color the selected color. 
 */
Extras.Sync.RichTextArea.ToolbarButton = Core.extend(Echo.Button, {

    $load: function() {
        Echo.ComponentFactory.registerType("Extras.RichTextToolbarButton", this);
    },
    
    /** @see Echo.Component#componentType */
    componentType: "Extras.RichTextToolbarButton",
    
    /**
     * Programmatically performs a button action.
     */
    doAction: function() {
        if (this.render("toggle")) {
            this.set("pressed", !this.get("pressed"));
        } 
        this.fireEvent({ source: this, type: "action", actionCommand: this.render("actionCommand") });
    }
});

/**
 * Component rendering peer for ToolbarButton component. 
 */
Extras.Sync.RichTextArea.ToolbarButtonPeer = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Extras.RichTextToolbarButton", this);
    },
    
    /**
     * Main DIV rendered DIV element.
     * @type Element
     */
    _div: null,

    /**
     * Processes a mouse click event.
     * 
     * @param e the event
     */
    _processClick: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this.client.application.setFocusedComponent(this.component);
        this.component.doAction();
    },
    
    /**
     * Processes a mouse rollover enter event.
     * 
     * @param e the event
     */
    _processRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return true;
        }
        this._renderButtonState(true);
    },

    /**
     * Processes a mouse rollover exit event.
     * 
     * @param e the event
     */
    _processRolloverExit: function(e) {
        this._renderButtonState(false);
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        var icon = this.component.render("icon");
        
        this._div = document.createElement("div");
        this._div.style.cssText = "position:relative;";
        
        this._renderButtonState(false);
        if (this.component.render("color")) {
            this._renderColor();
        }
        
        Echo.Sync.Insets.render(this.component.render("insets"), this._div, "padding");
        
        if (icon) {
            var imgElement = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(icon, imgElement);
            this._div.appendChild(imgElement);
        }
        
        Core.Web.Event.add(this._div, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.add(this._div, "mouseover", Core.method(this, this._processRolloverEnter), false);
        Core.Web.Event.add(this._div, "mouseout", Core.method(this, this._processRolloverExit), false);
        
        parentElement.appendChild(this._div);
    },
       
    /**
     * Renders the state of the button (pressed/rollover effects).
     * 
     * @param {Boolean} rolloverState flag indicating whether component is currently rolled over.
     */
    _renderButtonState: function(rolloverState) {
        var foreground = this.component.render("foreground");
        var background = this.component.render("background");
        var border = this.component.render("border");
        var backgroundImage = this.component.render("backgroundImage");
        
        // Apply pressed effect.
        if (this.component.render("pressed")) {
            foreground = this.component.render("pressedForeground", foreground);
            background = this.component.render("presssedBackground", background);
            border = this.component.render("pressedBorder", border);
            backgroundImage = this.component.render("pressedBackgroundImage", backgroundImage);
        }
        
        // Apply rollover effect.
        if (rolloverState) {
            foreground = this.component.render("rolloverForeground", foreground);
            background = this.component.render("rolloverBackground", background);
            backgroundImage = this.component.render("rolloverBackgroundImage", backgroundImage);
        }
                        
        Echo.Sync.Color.renderClear(foreground, this._div, "color");
        Echo.Sync.Color.renderClear(background, this._div, "backgroundColor");
        Echo.Sync.Border.renderClear(border, this._div);
        Echo.Sync.FillImage.renderClear(backgroundImage, this._div);
    },
    
    /**
     * Renders the selected color of the button.
     */
    _renderColor: function() {
        var color = this.component.render("color");
        if (!this._colorDiv) {
            this._colorDiv = document.createElement("div");
            this._colorDiv.style.cssText = "position:absolute;bottom:0;left:0;right:0;height:5px;line-height:0px;font-size:1px;";
            if (Core.Web.Env.BROWSER_INTERNET_EXPLORER && Core.Web.Env.BROWSER_VERSION_MAJOR === 6) {
                this._colorDiv.style.width = "16px";
            }
            this._colorDiv.style.backgroundColor = color || "#ffffff";
            this._div.appendChild(this._colorDiv);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        Core.Web.Event.removeAll(this._div);
        this._div = null;
        this._colorDiv = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        // Empty implementation required due to supported component extending (focusable) Echo.Button.
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});
/**
 * Component rendering peer: Extras.RichTextInput.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.RichTextInput = Core.extend(Echo.Render.ComponentSync, {
    
    $load: function() {
        Echo.Render.registerPeer("Extras.RichTextInput", this);
    },
    
    $static: {
        
        DEFAULTS: {
            border: "1px inset #7f7f7f"
        },
        
        /**
         * HTML block-style nodes.
         * Used for Gecko browsers for determining if insertion point is within a block-style node.
         */
        BLOCK_NODES: {
            p: true, h1: true, h2: true, h3: true, h4: true, h5: true, h6: true, pre: true, li: true
        },
        
        /**
         * Property containing browser-modified HTML, used for lazy-processing (cleaning).
         * Invoking toString() method returns processed HTML.
         */
        EditedHtml: Core.extend({
            
            /**
             * The supported RichTextInput peer.
             * @type Extras.Sync.RichTextInput
             */
            _peer: null,
            
            /**
             * Class name (for serialization).
             * @type String
             */
            className: "Extras.RichTextInput.EditedHtml",
            
            /**
             * Creates a new <code>EditedHtml</code> wrapper.
             * 
             * @param {Extras.Sync.RichTextInput} peer the peer
             */
            $construct: function(peer) {
                this._peer = peer;
            },

            /** @see Object#toString */
            toString: function() {
                return this._peer._getProcessedHtml();
            }
        }),
        
        /**
         * HTML manipulation/cleaning utilities.
         */
        Html: {
        
            //FIXME Verify no illegal tags are present or correct.
            //FIXME Verify no unclosed tags are present or correct.
            //FIXME Verify no illegal characters are present or correct.
            //FIXME Provide option to only remove the one trailing BR we add by default.
            
            /**
             * Regular expression to capture leading whitespace.
             * @type RegExp
             */
            _LEADING_WHITESPACE: /^(\s|<br\/?>|&nbsp;)+/i,
        
            /**
             * Regular expression to capture trailing whitespace.
             * @type RegExp
             */
            _TRAILING_WHITESPACE: /(\s|<br\/?>|&nbsp;)+$/i,
            
            /**
             * Regular expression used to correct MSIE's FONT element color attributes which do not enclose attribute values 
             * in quotes.
             * @type RegExp
             */
            _MSIE_INVALID_FONT_COLOR_REPL: /(<font .*?color\=)(#[0-9a-fA-F]{3,6})(.*?>)/ig,
        
            /**
             * Regular expression used to correct MSIE's FONT element background attributes which do not enclose attribute values 
             * in quotes.
             * @type RegExp
             */
            _MSIE_INVALID_FONT_BACKGROUND_REPL: /(<font .*?)(background-color)/ig,
            
            /**
             * Regular expression to determine if a style attribute is setting a bold font.
             * @type RegExp 
             */
            _CSS_BOLD: /font-weight\:\s*bold/i,
    
            /**
             * Regular expression to determine if a style attribute is setting a foreground color.
             * @type RegExp 
             */
            _CSS_FOREGROUND_TEST: /^-?color\:/i,
            
            /**
             * Regular expression to determine the foreground color being set by a style attribute.
             * @type RegExp 
             */
            _CSS_FOREGROUND_RGB: /^-?color\:\s*rgb\s*\(\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})/i,
                    
            /**
             * Regular expression to determine if a style attribute is setting a background color.
             * @type RegExp 
             */
            _CSS_BACKGROUND_TEST: /background-color\:/i,
    
            /**
             * Regular expression to determine the background color being set by a style attribute.
             * @type RegExp 
             */
            _CSS_BACKGROUND_RGB: /background-color\:\s*rgb\s*\(\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})/i,
                    
            /**
             * Regular expression to determine if a style attribute is setting an italic font.
             * @type RegExp 
             */
            _CSS_ITALIC: /font-style\:\s*italic/i,
            
            /**
             * Regular expression to determine if a style attribute is setting an underline font.
             * @type RegExp 
             */
            _CSS_UNDERLINE: /text-decoration\:\s*underline/i,
            
            /**
             * An object which reports style information about a specific node's text content, including inherited style properties.
             */
            StyleData: Core.extend({
                
                /**
                 * Flag indicating whether the text is bold.
                 * @type Boolean
                 */
                bold: false,
                
                /**
                 * Flag indicating whether the text is italicized.
                 * @type Boolean
                 */
                italic: false,
                
                /**
                 * Flag indicating whether the text is underlined.
                 * @type Boolean
                 */
                underline: false,
                
                /**
                 * The paragraph style, one of the following values:
                 * <ul>
                 *  <li>p</li>
                 *  <li>pre</li>
                 *  <li>h1</li>
                 *  <li>h2</li>
                 *  <li>h3</li>
                 *  <li>h4</li>
                 *  <li>h5</li>
                 *  <li>h6</li>
                 * </ul>
                 * 
                 * @type String
                 */
                paragraphStyle: null,
                
                /**
                 * The text foreground color.
                 * @type #Color
                 */
                foreground: null,
                
                /**
                 * The text background color.
                 * @type #Color
                 */
                background: null,
                
                /**
                 * Creates a new style for a specific DOM node.
                 * 
                 * @param {Node} node the node
                 */
                $construct: function(node) {
                    var rgb;
            
                    while (node) { 
                        if (node.nodeType == 1) {
                            switch (node.nodeName.toLowerCase()) {
                            case "b": case "strong":
                                this.bold = true;
                                break;
                            case "i": case "em":
                                this.italic = true;
                                break;
                            case "u":
                                this.underline = true;
                                break;
                            case "h1": case "h2": case "h3": case "h4": case "h5": case "h6": case "p": case "pre":
                                if (!this.paragraphStyle) {
                                    this.paragraphStyle = node.nodeName.toLowerCase();
                                }
                                break;
                            }
                        
                            var css = node.style.cssText;
                            this.bold |= Extras.Sync.RichTextInput.Html._CSS_BOLD.test(css);
                            this.italic |= Extras.Sync.RichTextInput.Html._CSS_ITALIC.test(css);
                            this.underline |= Extras.Sync.RichTextInput.Html._CSS_UNDERLINE.test(css);
                            
                            if (!this.foreground && Extras.Sync.RichTextInput.Html._CSS_FOREGROUND_TEST.test(css)) {
                                rgb = Extras.Sync.RichTextInput.Html._CSS_FOREGROUND_RGB.exec(css);
                                if (rgb) {
                                    this.foreground = Echo.Sync.Color.toHex(
                                            parseInt(rgb[1], 10), parseInt(rgb[2], 10), parseInt(rgb[3], 10));
                                }
                            }
            
                            if (!this.background && Extras.Sync.RichTextInput.Html._CSS_BACKGROUND_TEST.test(css)) {
                                rgb = Extras.Sync.RichTextInput.Html._CSS_BACKGROUND_RGB.exec(css);
                                if (rgb) {
                                    this.background = Echo.Sync.Color.toHex(
                                            parseInt(rgb[1], 10), parseInt(rgb[2], 10), parseInt(rgb[3], 10));
                                }
                            }
                        }
                        node = node.parentNode;
                    }
                }
            }),
            
            /**
             * Cleans HTML input/output.
             * 
             * @param {String} html the HTML to clean
             * @return the cleaned HTML
             * @type String
             */
            clean: function(html) {
                html = html || "<p></p>";
                html = html.replace(Extras.Sync.RichTextInput.Html._LEADING_WHITESPACE, "");
                html = html.replace(Extras.Sync.RichTextInput.Html._TRAILING_WHITESPACE, "");
                if (Core.Web.Env.ENGINE_MSHTML) {
                    html = html.replace(Extras.Sync.RichTextInput.Html._MSIE_INVALID_FONT_COLOR_REPL, "$1\"$2\"$3");
                    html = html.replace(Extras.Sync.RichTextInput.Html._MSIE_INVALID_FONT_BACKGROUND_REPL, "$1background-color");
                }
                return html;
            }
        },
        
        /**
         * A cross-platform range implementation, which provides a subset of functionality available from W3C DOM Range and
         * Internet Explorer's TextRange objects. 
         */
        Range: Core.extend({
            
            /**
             * An Internet Explorer-specific proprietary <code>TextRange</code> object.  Available only when DOM range API is 
             * unavailable, in MSIE-based browsers.
             *
             * @type TextRange
             */
            ieRange: null,
            
            /**
             * W3C DOM Range.  Available on all browsers where supported (i.e., not IE).
             * 
             * @type Range
             */
            domRange: null,
            
            /**
             * The <code>Window</code> containing the range.
             * 
             * @type Window
             */
            window: null,
            
            /**
             * Creates a new <code>Range</code> withing the target <code>Window</code>.
             * 
             * @param {Window} targetWindow the browser window in which the range should exist
             */
            $construct: function(targetWindow) {
                this.window = targetWindow;
                if (Core.Web.Env.ENGINE_MSHTML) {
                    this.ieRange = targetWindow.document.selection.createRange();
                    if (this.ieRange.parentElement().ownerDocument != targetWindow.document) {
                        targetWindow.focus();
                        this.ieRange = targetWindow.document.selection.createRange();
                        if (this.ieRange.parentElement().ownerDocument != targetWindow.document) {
                            this.ieRange = null;
                        }
                    }
                } else {
                    this.domRange = targetWindow.getSelection().getRangeAt(0);
                }
            },
            
            /**
             * Activates the range, moving the client's cursor/selection positions to it.
             */
            activate: function() {
                if (this.domRange) {
                    var selection = this.window.getSelection();
                    if (!selection) {
                        return;
                    }
                    selection.removeAllRanges();
                    selection.addRange(this.domRange);
                } else if (this.ieRange) {
                    this.ieRange.select();
                }
            },
            
            /**
             * Disposes of the range.
             */
            dispose: function() {
                this.domRange = null;
                this.ieRange = null;
                this.window = null;
            },
            
            /**
             * Returns the element/node which contains the range.
             * If an <code>elementName</code> is specified, the returned node will be an element of the specified name,
             * or null if none exists.
             * 
             * @param {String} elementName (optional) the enclosing element name
             */
            getContainingNode: function(elementName) {
                var node;
                if (this.domRange) {
                    node = this.domRange.commonAncestorContainer;
                } else if (this.ieRange) {
                    node = this.ieRange.parentElement();
                }
                
                if (elementName) {
                    while (node != null) {
                        if (node.nodeType == 1 && node.nodeName.toLowerCase() == elementName) {
                            return node;
                        }
                        node = node.parentNode;
                    }
                }
                
                return node;
            }
        }),
        
        /**
         * Key codes which may result in cursor navigating into new style, resulting in a "cursorStyleChange" event being fired.
         */
        _NAVIGATION_KEY_CODES: {
            38: 1, 40: 1, 37: 1, 39: 1, 33: 1, 34: 1, 36: 1, 35: 1, 8: 1, 46: 1
        }
    },
    
    /**
     * Flag indicating whether a style information update is required due to the cursor/selection having been moved/changed.
     * @type Boolean
     */
    _cursorStyleUpdateRequired: false,

    /**
     * Flag indicating whether an action event should be fired.
     * Set by _processKeyPress(), used by _processKeyUp().
     * @type Boolean
     */
    _fireAction: false,
    
    /**
     * The most recently retrieved document HTML.
     * @type String 
     */
    _renderedHtml: null,
    
    /**
     * Listener to receive property events from component.
     * @type Function
     */
    _propertyListener: null,

    /**
     * Listener to receive execCommand events from component.
     * @type Function
     */
    _execCommandListener: null,
    
    /**
     * Root DIV element of rendered DOM hierarchy.
     * @type Element
     */
    _div: null,
    
    /**
     * Rendered IFRAME element containing editable document.
     * @type Element
     */
    _iframe: null,
    
    /**
     * The IFRAME's contained document.
     * @type Document
     */
    _document: null,
    
    _temporaryCssStyleEnabled: false,

    /**
     * Constructor.
     */
    $construct: function() { 
        this._propertyListener = Core.method(this, function(e) {
            if (e.propertyName == "text") {
                this._loadData();
            }
        });
        this._execCommandListener = Core.method(this, function(e) {
            this._execCommand(e.commandName, e.value);
        });
    },
    
    /**
     * Adds listeners to supported Extras.RichTextInput object.
     */
    _addComponentListeners: function() {
        this.component.addListener("execCommand", this._execCommandListener);
        this.component.addListener("property", this._propertyListener);
    },
    

    /**
     * Deletes a column from an HTML table containing the current selection.
     * Takes no action in the event that the selection is not in a table cell. 
     * This method assumes no column or row spans.
     */
    _deleteTableColumn: function() {
        var action = Core.method(this, function(td) {
            td.parentNode.removeChild(td);
        });
        this._updateSelectedTableColumn(action);
    },
    
    /**
     * Deletes a row from an HTML table containing the current selection.
     * Takes no action in the event that the selection is not in a table cell.
     * This method assumes no column or row spans.
     */
    _deleteTableRow: function() {
        var tr = this._selectionRange.getContainingNode("tr");
        if (!tr) {
            return;
        }
        tr.parentNode.removeChild(tr);
    },

    /**
     * Disposes of current selection range.
     */
    _disposeRange: function() {
        if (this._selectionRange) {
            //FIXME 
            this._selectionRange.dispose();
        }
    },
    
    /**
     * Executes a rich text editing command (via document.execCommand()).
     * 
     * @param {String} commandName the command name
     * @param {String} value the command value
     */
    _execCommand: function(commandName, value) {
        if (this._temporaryCssStyleEnabled) {
            this._document.execCommand("styleWithCSS", false, false);
            this._temporaryCssStyleEnabled = false;
        }
        
        if (this._selectionRange) {
            // Select range if it exists.
            this._loadRange();
        } else {
            // Create range if none exists.
            this._storeRange();
        }
        
        switch (commandName) {
        case "tableDeleteColumn":
            this._deleteTableColumn();
            break;
        case "tableDeleteRow":
            this._deleteTableRow();
            break;
        case "tableInsertColumn":
            this._insertTableColumn();
            break;
        case "tableInsertRow":
            this._insertTableRow();
            break;
        case "foreground":
            this._document.execCommand("forecolor", false, value);
            break;
        case "background":
            if (Core.Web.Env.ENGINE_GECKO) {
                this._document.execCommand("styleWithCSS", false, true);
                this._document.execCommand("hilitecolor", false, value);
                this._temporaryCssStyleEnabled = true;
            } else {
                this._document.execCommand(Core.Web.Env.ENGINE_MSHTML ? "backcolor" : "hilitecolor", false, value);
            }
            break;
        case "insertHtml":
            if (Core.Web.Env.ENGINE_MSHTML) {
                if (!this._selectionRange) {
                    this._storeRange(); 
                }
                this._selectionRange.ieRange.pasteHTML(value);
            } else {
                this._document.execCommand("inserthtml", false, value);
            }
            this._storeRange();
            break;
        default: 
            this._document.execCommand(commandName, false, value);
            break;
        }
        
        this._storeData();
        
        this.client.forceRedraw();
        
        // Flag that cursor style update is required.  Some browsers will not render nodes until text is inserted.
        this._cursorStyleUpdateRequired = true;
    },
    
    /**
     * Focuses the rich text input document.
     */
    focusDocument: function() {
        this.client.application.setFocusedComponent(this.component);
        this.client.forceRedraw();
    },
    
    /**
     * Returns a processed version of the currently edited HTML.
     * 
     * @return the processed HTML
     * @type String
     */
    _getProcessedHtml: function() {
        if (this._renderedHtml == null) {
            this._renderedHtml = this._document.body.innerHTML; 
        }
        return Extras.Sync.RichTextInput.Html.clean(this._renderedHtml);
    },
    
    /**
     * Determines the column index of the specified TD or TH element.
     * TD or TH elements contained in a TR are considered columns.
     * This method assumes no column or row spans.
     * 
     * @param {Element} td the TD element
     * @return the column index, or -1 if it cannot be found
     * @type Number 
     */
    _getTableColumnIndex: function(td) {
        var tr = td.parentNode;
        if (tr.nodeName.toLowerCase() != "tr") {
            // Sanity check; should not occur.
            return -1;
        }
        var index = 0;
        var node = tr.firstChild;
        while (node && node != td) {
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName == "td" || nodeName == "th") {
                ++index;
            }
            node = node.nextSibling;
        }
        if (!node) {
            return -1;
        }
        return index;
    },
    
    /**
     * Inserts a column into an HTML table containing the current selection.
     * Takes no action in the event that the selection is not in a table.
     * This method assumes no column or row spans.
     */
    _insertTableColumn: function() {
        var action = Core.method(this, function(td) {
            var newTd = this._document.createElement("td");
            if (!Core.Web.Env.ENGINE_MSHTML) {
                newTd.appendChild(this._document.createElement("br"));
            }
            td.parentNode.insertBefore(newTd, td);
        });
        this._updateSelectedTableColumn(action);
    },
    
    /**
     * Inserts a row into an HTML table containing the current selection.
     * Takes no action in the event that the selection is not in a table.
     * This method assumes no column or row spans.
     */
    _insertTableRow: function() {
        var tr = this._selectionRange.getContainingNode("tr");
        
        var table = this._selectionRange.getContainingNode("table");
        if (!tr || !table) {
            return;
        }
        
        var newTr = this._document.createElement("tr");
        var node = tr.firstChild;
        while (node) {
            if (node.nodeType == 1 && (node.nodeName.toLowerCase() == "td" || node.nodeName.toLowerCase() == "th")) {
                var newTd = this._document.createElement("td");
                if (!Core.Web.Env.ENGINE_MSHTML) {
                    newTd.appendChild(this._document.createElement("br"));
                }
                newTr.appendChild(newTd);
            }
            node = node.nextSibling;
        }
        
        tr.parentNode.insertBefore(newTr, tr);
    },
    
    /**
     * Loads the text data in the component's "text" property into the rendered editable document.
     * @see #_storeData
     */
    _loadData: function() {
        var text = this.component.get("text") || (Core.Web.Env.ENGINE_GECKO ? "<p><br/></p>" : "<p></p>");
        
        if (text instanceof Extras.Sync.RichTextInput.EditedHtml) {
            // Current component text is represented by an EditedHtml object, which references the editable text document 
            // itself: do nothing.
            return;
        }
        
        if (this._renderedHtml == null) {
            this._renderedHtml = this._document.body.innerHTML; 
        }

        if (text == this._renderedHtml) {
            // No update necessary.
            return;
        }

        this._renderedHtml = text;
        this._document.body.innerHTML = text;
        
        this.component.doCursorStyleChange(new Extras.Sync.RichTextInput.Html.StyleData(this._selectionRange.getContainingNode()));
    },
    
    /**
     * Selects (only) the current stored range.
     * @see #_storeRange
     */
    _loadRange: function() {
Core.Debug.consoleWrite("LOADRANGE");            
        if (this._selectionRange) {
            this._selectionRange.activate();
            if (Core.Web.Env.ENGINE_MSHTML && this.component.application.getFocusedComponent() != this.component) {
                // MSIE: Blur focus from content window in the event that it is not currently focused.
                // If this operation is not performed, text may be entered into the window, but key events
                // will not be processed by listeners, resulting in an out-of-sync condition.
                this._iframe.contentWindow.blur();
            }
        }
    },
    
    /**
     * Notifies component object of a potential cursor style change (such that it may notify registered listeners).
     */
    _notifyCursorStyleChange: function() {
        this._cursorStyleUpdateRequired = false;
        Core.Web.Scheduler.run(Core.method(this, function() {
            this.component.doCursorStyleChange(new Extras.Sync.RichTextInput.Html.StyleData(
                  this._selectionRange.getContainingNode()));
        }));
    },
    
    /**
     * Processes a focus event within the input document.
     * 
     * @param e the event
     */
    _processFocus: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            return;
        }
        this.client.application.setFocusedComponent(this.component);
    },
    
    /**
     * Processes a key press event within the input document.
     * 
     * @param e the event
     */
    _processKeyDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            return;
        }
        if (e.keyCode == 13) {
            this._processNewLine();
            this._fireAction = true;
        }
    },
    
    /**
     * Processes a key press event within the input document.
     * 
     * @param e the event
     */
    _processKeyPress: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            return;
        }
    },
    
    /**
     * Processes a key up event within the input document.
     * 
     * @param e the event
     */
    _processKeyUp: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }

        this._storeData();
        this._storeRange();
        
        if (this._cursorStyleUpdateRequired || Extras.Sync.RichTextInput._NAVIGATION_KEY_CODES[e.keyCode]) {
            this._notifyCursorStyleChange();
        }
        
        if (this._fireAction) {
            this._fireAction = false;
            this.component.doAction();
        }
    },
    
    /**
     * Processes a mouse down event within the input document.
     * 
     * @param e the event
     */
    _processMouseDown: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            return;
        }
        this.client.application.setFocusedComponent(this.component);
    },

    /**
     * Processes a mouse up event within the input document.
     * 
     * @param e the event
     */
    _processMouseUp: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            Core.Web.DOM.preventEventDefault(e);
            return;
        }

        this._storeRange();
        
        this._notifyCursorStyleChange();
    },
    
    /**
     * Processes a user newline entry keyboard event (pressing return/enter).
     * Handles special case in Gecko/WebKit browser where cursor is not within
     * a block element (e.g., "p" tag), which will cause enter key to 
     * insert "<br>" (Gecko) or "<div>" (WebKit) tags.  Such behavior is undesirable for cross-browser
     * editing of content (i.e., editing same rich text document by different
     * browsers).
     */
    _processNewLine: function() {
        var node, inBlock;
        
        if (!Core.Web.Env.ENGINE_GECKO && !Core.Web.Env.ENGINE_WEBKIT) {
            // Allow normal operation in non-Gecko browsers.
            return;
        }
        
        this._storeRange();
        node = this._selectionRange.domRange.endContainer;
        inBlock = false;
        while (node.nodeType != 1 || node.nodeName.toLowerCase() != "body") {
            if (node.nodeType == 1 && Extras.Sync.RichTextInput.BLOCK_NODES[node.nodeName.toLowerCase()]) {
                inBlock = true;
                break;
            }
            node = node.parentNode;
        }
        
        if (inBlock) {
            // In block: Gecko browsers will work properly as 'insertbronreturn' flag has been set false.
            return;
        }
        
        this._document.execCommand("formatblock", null, "<p>");
    },
    
    /**
     * Removes listeners from supported Extras.RichTextInput object.
     */
    _removeComponentListeners: function() {
        this.component.removeListener("execCommand", this._execCommandListener);
        this.component.removeListener("property", this._propertyListener);
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._addComponentListeners();
        
        // Create IFRAME container DIV element.
        this._div = document.createElement("div");
        Echo.Sync.Border.render(this.component.render("border", Extras.Sync.RichTextInput.DEFAULTS.border), this._div);
        
        // Create IFRAME element.
        this._iframe = document.createElement("iframe");
        this._iframe.style.width = this.width ? this.width : "100%";

        if (!this.component.get("paneRender")) {
            this._iframe.style.height = this.height ? this.height : "200px";
        }

        this._iframe.style.border = "0px none";
        this._iframe.frameBorder = "0";
    
        this._div.appendChild(this._iframe);
    
        parentElement.appendChild(this._div);
    },
    
    /**
     * Renders the editable content document within the created IFRAME.
     */
    _renderDocument: function() {
        // Ensure element is on-screen before rendering content/enabling design mode.
        var element = this._iframe;
        while (element != document.body) {
            if (element == null) {
                // Not added to parent.
                return;
            }
            if (element.nodeType == 1 && element.style.display == "none") {
                // Not rendered.
                return;
            }
            element = element.parentNode;
        }
        
        var style = "height:100%;width:100%;margin:0px;padding:0px;";
        var foreground = this.component.render("foreground");
        if (foreground) {
            style += "color:" + foreground + ";";
        }
        var background = this.component.render("background");
        if (background) {
            style += "background-color:" + background + ";";
        }
        var backgroundImage = this.component.render("backgroundImage");
        if (backgroundImage) {
            style += "background-attachment: fixed;";
            style += "background-image:url(" + Echo.Sync.FillImage.getUrl(backgroundImage) + ");";
            var backgroundRepeat = Echo.Sync.FillImage.getRepeat(backgroundImage);
            if (backgroundRepeat) {
                style += "background-repeat:" + backgroundRepeat + ";";
            }
            var backgroundPosition = Echo.Sync.FillImage.getPosition(backgroundImage);
            if (backgroundPosition) {
                style += "background-position:" + backgroundPosition + ";";
            }
        }
        
        var text = this.component.get("text");
        this._document = this._iframe.contentWindow.document;
        this._document.open();
        this._document.write("<html><body tabindex=\"0\" width=\"100%\" height=\"100%\"" +
                (style ? (" style=\"" + style + "\"") : "") + ">" + (text || "") + "</body></html>");
        this._document.close();
        if (Core.Web.Env.BROWSER_MOZILLA && !Core.Web.Env.BROWSER_FIREFOX) {
            // workaround for Mozilla (not Firefox)
            var setDesignModeOn = function() {
                this._document.designMode = "on";
            };
            setTimeout(setDesignModeOn, 0);
        } else {
            this._document.designMode = "on";
            if (Core.Web.Env.ENGINE_GECKO || Core.Web.Env.ENGINE_WEBKIT) {
                this._document.execCommand("insertbronreturn", false, false);
                this._document.execCommand("stylewithcss", false, false);
                this._document.execCommand("enableObjectResizing", false, false);
                this._document.execCommand("enableInlineTableEditing", false, false);
            }
        }
        
        Core.Web.Event.add(this._document, "focus",  Core.method(this, this._processFocus), false);
        Core.Web.Event.add(this._document, "keydown",  Core.method(this, this._processKeyDown), false);
        Core.Web.Event.add(this._document, "keypress",  Core.method(this, this._processKeyPress), false);
        Core.Web.Event.add(this._document, "keyup", Core.method(this, this._processKeyUp), false);
        Core.Web.Event.add(this._document, "mousedown", Core.method(this, this._processMouseDown), false);
        Core.Web.Event.add(this._document, "mouseup", Core.method(this, this._processMouseUp), false);

        this._documentRendered = true;
    },
    
    /**
     * Clears the editable document, disposing any resources related to it.
     * Invoked by renderHide() implementation.
     */
    _renderDocumentRemove: function() {
        Core.Web.Event.removeAll(this._document);
        while (this._document.body.firstChild) {
            this._document.body.removeChild(this._document.body.firstChild);
        }
        this._documentRendered = false;
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._removeComponentListeners();
        Core.Web.Event.removeAll(this._document);
        this._div = null;
        this._iframe = null;
        this._document = null;
        this._documentRendered = false;
        this._selectionRange = null;
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        if (!this._documentRendered) {
            this._renderDocument();
        }

        this.client.forceRedraw();
        
        var bounds = new Core.Web.Measure.Bounds(this._div.parentNode);
        
        if (bounds.height) {
            var border = this.component.render("border", Extras.Sync.RichTextInput.DEFAULTS.border);
            var borderSize = Echo.Sync.Border.getPixelSize(border, "top") + Echo.Sync.Border.getPixelSize(border, "bottom");
    
            var calculatedHeight = (bounds.height < 100 ? 100 : bounds.height - borderSize) + "px";
            if (this._iframe.style.height != calculatedHeight) {
                this._iframe.style.height = calculatedHeight; 
            }
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderFocus */
    renderFocus: function() {
        if (Core.Web.Env.BROWSER_SAFARI) {
            // Focus window first to avoid issue where Safari issue with updating content and then focusing.
            window.focus();
        }
        Core.Web.DOM.focusElement(this._iframe.contentWindow);
        this.client.forceRedraw();
    },
    
    /** @see Echo.Render.ComponentSync#renderHide */
    renderHide: function() {
        // Dispose selection range (critical for MSIE).
        this._disposeRange();
        
        // Store state.
        this._renderedHtml = this._document.body.innerHTML;
        
        // Clear editable document and dispose resources.
        this._renderDocumentRemove();
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        if (update.isUpdatedPropertySetIn({text: true })) {
            this._loadData();
            update.renderContext.displayRequired = [];
            return;
        }
    
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
    },
        
    /**
     * Stores the state of the editable document into the "text" property of the component.
     * The HTML is cleaned first.
     * @see #_loadData
     */
    _storeData: function() {
        this._renderedHtml = null;
        this.component.set("text", new Extras.Sync.RichTextInput.EditedHtml(this), true);
    },
    
    /**
     * Stores the current selection range.
     * @see #_loadRange
     */
    _storeRange: function() {
        this._disposeRange();
        this._selectionRange = new Extras.Sync.RichTextInput.Range(this._iframe.contentWindow);
    },

    /**
     * Updates the selected table column, passing each TD/TH element at the column index
     * to the specified action method.
     * 
     * @param {Function} action function to invoke on each TD/TH element of column, the
     *        TD/TH element will be provided as the only parameter to the function
     */
    _updateSelectedTableColumn: function(action) {
        var td = this._selectionRange.getContainingNode("td");
        if (!td) {
            return;
        }
        var index = this._getTableColumnIndex(td);
        if (index === -1) {
            return;
        }
        var table = this._selectionRange.getContainingNode("table");
        this._updateTableColumnFromTbody(table, index, action);
    },

    /**
     * Work method for <code>_updateSelectedTableColumn</code>.
     * Processes TBODY/TABLE elements, searching for TD/TH elements representing the table column
     * specified by <code>index</code>.
     * 
     * @param {Element} tbody the TABLE or TBODY element
     * @param {Number} index the column index
     * @param {Function} action function to invoke on each TD/TH element of column, the
     *        TD/TH element will be provided as the only parameter to the function
     */
    _updateTableColumnFromTbody: function(tbody, index, action) {
        var node = tbody.firstChild;
        while (node) {
            if (node.nodeType == 1) {
                var nodeName = node.nodeName.toLowerCase();
                if (nodeName == "tbody") {
                    this._updateTableColumnFromTbody(node, index, action);
                } else if (nodeName == "tr") {
                    this._updateTableColumnFromTr(node, index, action);
                }
            }
            node = node.nextSibling;
        }
    },
    
    /**
     * Work method for <code>_updateSelectedTableColumn</code>.
     * Processes TR elements, searching for TD/TH elements representing the table column
     * specified by <code>index</code>.
     * 
     * @param {Element} tr the TR element
     * @param {Number} index the column index
     * @param {Function} action function to invoke on each TD/TH element of column, the
     *        TD/TH element will be provided as the only parameter to the function
     */
    _updateTableColumnFromTr: function(tr, index, action) {
        var i = -1;
        var node = tr.firstChild;
        while (node) {
            if (node.nodeType == 1) {
                var nodeName = node.nodeName.toLowerCase();
                if (nodeName == "td" || nodeName == "th") {
                    ++i;
                    if (i == index) {
                        action(node);
                        return;
                    }
                }
            }
            node = node.nextSibling;
        }
    }
});
/**
 * Component rendering peer: TabPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.TabPane = Core.extend(Echo.Render.ComponentSync, {

    $static: {
    
        /**
         * Prototype zero-padding table/tbody/tr hierarchy.
         * @type Element
         */
        _TABLE: null,
    
        /**
         * Generates a zero-pading table/tbody/tr hierarchy.
         * 
         * @return the root table element
         * @type Element
         */
        _createTable: function() {
            if (!this._TABLE) {
                this._TABLE = document.createElement("table");
                this._TABLE.style.cssText = "border-collapse:collapse;padding:0;";
                var tbody = document.createElement("tbody");
                this._TABLE.appendChild(tbody);
                var tr = document.createElement("tr");
                tbody.appendChild(tr);
            }
            return this._TABLE.cloneNode(true);
        },

        /**
         * Supported partial update properties. 
         * @type Array
         */
        _supportedPartialProperties: ["activeTabId", "activeTabIndex"],
        
        /**
         * Default component property settings, used when supported component object does not provide settings. 
         */
        _DEFAULTS: {
            borderType: Extras.TabPane.BORDER_TYPE_ADJACENT_TO_TABS,
            foreground: "#000000",
            insets: 2,
            tabActiveBorder: "1px solid #00004f",
            tabActiveHeightIncrease: 2,
            tabAlignment: "top",
            tabCloseIconTextMargin: 5,
            tabContentInsets: 0,
            tabIconTextMargin: 5,
            tabInactiveBorder: "1px solid #7f7f7f",
            tabInset: 10,
            tabInsets: "1px 8px",
            tabPosition: Extras.TabPane.TAB_POSITION_TOP,
            tabSpacing: 0
        },
        
        /**
         * Runnable to manage scrolling animation.
         */
        ScrollRunnable: Core.extend(Core.Web.Scheduler.Runnable, {
        
            /** @see Core.Web.Scheduler.Runnable#repeat */
            repeat: true,

            /** @see Core.Web.Scheduler.Runnable#timeInterval */
            timeInterval: 20,

            /**
             * Direction of scrolling travel.  True indicates tabs are scrolling in reverse (revealing tabs to the left),
             * true indicating scrolling forward (revealing tabs to the right).
             * @type Boolean
             */
            reverse: false,
            
            /**
             * Current distance scrolled, in pixels.
             * @type Number
             */
            distance: 0,
            
            /** 
             * Minimum distance to move (in case of click rather than hold
             * @type Number 
             */
            clickDistance: 50,
            
            /** 
             * Rate to scroll when scroll button held.
             * @type Number 
             */
            pixelsPerSecond: 400,
            
            /** 
             * Initial scroll position.
             * @type Number 
             */
            initialPosition: null,
            
            /**
             * Flag indicating whether the ScrollRunnable is disposed.
             * @type Boolean
             */
            disposed: false,
            
            /**
             * The TabPane peer for which scrolling is being performed.
             * @type Extras.Sync.TabPane
             */
            peer: null,
            
            /**
             * Last invocation time of run() method.  Used to determine the number of pixels which should be scrolled and 
             * ensure a constant velocity of the tabs.
             */
            lastInvokeTime: null,
        
            /**
             * Creates a new ScrollRunnable.
             * 
             * @param {Extras.Sync.TabPane} the synchronization peer
             * @param {Boolean} direction of scrolling travel
             */
            $construct: function(peer, reverse) {
                this.peer = peer;
                this.reverse = reverse;
                this.initialPosition = peer.scrollPosition;
                this.lastInvokeTime = new Date().getTime();
            },
            
            /**
             * Disposes of the scrolling runnable, removing it from the scheduler.
             */
            dispose: function() {
                if (!this.disposed) {
                    Core.Web.Scheduler.remove(this);
                }
                this.disposed = true;
            },
            
            /**
             * Finishes the tab header scrolling operation in response to the user releasing the scroll button.
             * Ensures the header has been scrolled the minimum "click distance", and if not, scrolls the header
             * that distance.
             */
            finish: function() {
                if (this.distance < this.clickDistance) {
                    this.distance = this.clickDistance;
                    this.updatePosition();
                }
                this.peer.renderDisplay();
                this.dispose();
            },
            
            /** @see Core.Web.Scheduler.Runnable#run */
            run: function() {
                var time = new Date().getTime();
                this.distance += Math.ceil(this.pixelsPerSecond * (time - this.lastInvokeTime) / 1000);
                this.lastInvokeTime = time;
                this.updatePosition();
            },
            
            /**
             * Updates the scroll position of the tab pane header.
             */
            updatePosition: function() {
                var position = this.initialPosition + ((this.reverse ? -1 : 1) * this.distance);
                if (!this.peer.setScrollPosition(position)) {
                    this.dispose();
                }
            }
        })
    },
    
    $load: function() {
        Echo.Render.registerPeer("Extras.TabPane", this);
    },
    
    /**
     * Name-to-ImageReference map for icons used by the TabPane, e.g., tab close and scroll icons.
     * @type Object
     */
    _icons: null,

    /**
     * Primary DIV element.
     * @type Element
     */
    _div: null,

    /**
     * DIV element which contains content.  All child components are rendered within this DIV,
     * only one is allowed to be visibly displayed at a given time.
     * @type Element
     */    
    _contentContainerDiv: null,
    
    /**
     * Element containing _headerContainerDiv.
     */
    _headerContainerBoundsDiv: null,
    
    /**
     * Element containing tab headers.
     * This element is contained withing the _headerContainerBoundsDiv, and positioned left/right to facilitate scrolling of 
     * tab headers.
     * @type Element
     */
    _headerContainerDiv: null,
    
    /**
     * The renderId of the active tab.
     * @type String
     */
    _activeTabId: null,
    
    /**
     * The renderId of the displayed tab.
     * @type String 
     */
    _displayedTabId: null,
    
    /**
     * Scroll previous arrow.
     * @type Element
     */
    _previousControlDiv: null,
    
    /**
     * Scroll next arrow.
     * @type Element
     */
    _nextControlDiv: null,
    
    /**
     * Data object containing information about a pending update to a tab's rollover state.
     */
    _pendingRollover: null,
    
    /**
     * The tab which is currently rolled over.
     * @type String
     */
    _rolloverTabId: null,
    
    /**
     * Flag indicating whether the current rolled over tab's close icon is rolled over.
     * @type Boolean
     */
    _rolloverTabCloseState: false,
    
    /**
     * Runnable used to delay rendering of rollover effects to avoid flicker.
     * @type Core.Web.Scheduler.Runnable
     */
    _rolloverRunnable: null,

    /**
     * Array containing <code>Extras.Sync.TabPane.Tab</code> objects represented the displayed tabs.
     * Each index of this array matches the corresponding child component index.
     * @type Array 
     */
    _tabs: null,
    
    /**
     * Combined width of all tabs, in pixels.
     * @type Number
     */
    _totalTabWidth: 0,
    
    /**
     * Height of the header, in pixels.
     * @type Number
     */
    _headerHeight: null,
    
    /**
     * Flag indicating whether a re-layout operation is required.  Flag is set by renderAdd()/renderUpdate() methods.
     * @type Boolean
     */
    _layoutRequired: false,
    
    /**
     * Flag indicating whether a full header re-render operation is required.  Flag is set by renderUpdate() method in response
     * to child layout data changes to avoid full render.
     * @type Boolean
     */
    _headerUpdateRequired: false,
    
    /** 
     * Method reference to <code>_tabSelectListener</code> of instance.
     * @type Function 
     */
    _tabSelectListenerRef: null,
    
    /**
     * The ScrollRunnable currently scrolling the tab headers.  Null when the tab pane is not actively scrolling. 
     * @type Extras.Sync.TabPane#ScrollRunnable
     */
    _scrollRunnable: null,
    
    /** 
     * Current scroll position of tab header, in pixels.
     * @type Number
     */
    scrollPosition: 0,
    
    /**
     * Flag indicating rendered layout direction of component (true if right-to-left).
     * @type Boolean
     */
    _rtl: false,
    
    /**
     * Constructor.
     */
    $construct: function() {
        this._tabs = [];
        this._tabSelectListenerRef = Core.method(this, this._tabSelectListener);
    },
    
    /**
     * Adds a tab and renders it.
     *
     * @param {Echo.Update.ComponentUpdate} update the component update 
     * @param {Extras.Sync.TabPane.Tab} tab the tab to be added 
     * @param index the index at which the tab should be added
     */
    _addTab: function(update, tab, index) {
        if (index == null || index == this._tabs.length) {
            this._tabs.push(tab);
            tab._renderAdd(update);
            this._headerContainerDiv.appendChild(tab._headerDiv);
            this._contentContainerDiv.appendChild(tab._contentDiv);
        } else {
            this._tabs.splice(index, 0, tab);
            tab._renderAdd(update);
            this._headerContainerDiv.insertBefore(tab._headerDiv, this._headerContainerDiv.childNodes[index]);
            this._contentContainerDiv.insertBefore(tab._contentDiv, this._contentContainerDiv.childNodes[index]);
        }
    },

    /**
     * Measures the height of the header region of the tab pane, adjusting the content region's size to accommodate it.
     * Invoked in renderDisplay phase when <code>_layoutRequired</code> flag has been set.
     */
    _renderLayout: function() {
        if (!this._layoutRequired) {
            return;
        }
        
        this._renderHeaderPositions();
        
        if (this._headerHeight === 0) {
            return;
        }
        this._layoutRequired = false;
        
        if (this._borderDiv) {
            // Adjust image border DIV to match header height.
            this._borderDiv.style[this._tabSide] = (this._headerHeight - this._ibContentInsetsPx[this._tabSide]) + "px";
        }
        
        var borderSize = this._borderType == Extras.TabPane.BORDER_TYPE_NONE ? 0 : Echo.Sync.Border.getPixelSize(this._border);
        this._headerContainerBoundsDiv.style.height = this._headerHeight + "px";
        this._contentContainerDiv.style.left = this._contentContainerDiv.style.right = 
                this._contentContainerDiv.style[this._oppositeSide] = 0;
        this._contentContainerDiv.style[this._tabSide] = (this._headerHeight - borderSize) + "px";
        
        Core.Web.VirtualPosition.redraw(this._contentContainerDiv);
        Core.Web.VirtualPosition.redraw(this._headerContainerDiv);
        Core.Web.VirtualPosition.redraw(this._headerContainerBoundsDiv);
        for (var i = 0; i < this._tabs.length; ++i) {
            this._tabs[i]._renderDisplay();
        }
        
        // Add image monitor to re-execute renderLayout as images are loaded.
        var imageListener = Core.method(this, function() {
            if (this.component) { // Verify component still registered.
                this._layoutRequired = true;
                this._renderLayout();
            }
        });
        Core.Web.Image.monitor(this._headerContainerDiv, imageListener);
    },
    
    /**
     * Positions tabs.
     * Equalizes tab heights to height of tallest tab.
     * Determines and stores the object's <code>_totalTabWidth</code> and <code>_headerHeight</code> properties.
     */
    _renderHeaderPositions: function() {
        var maxActiveHeight = 0,
            maxInactiveHeight = 0,
            tabActiveHeight,
            tabInactiveHeight,
            i,
            clearHeight = this._tabHeight ? (this._tabHeight + "px") : "";
            
        this._totalTabWidth = 0;
        this._headerHeight = 0;

        var maximumTabWidth = this.component.render("tabWidth") ? null : this.component.render("tabMaximumWidth");
        var maximumTabWidthPx;
        if (maximumTabWidth) {
            if (Echo.Sync.Extent.isPercent(maximumTabWidth)) {
                var percent = parseInt(maximumTabWidth, 10);
                maximumTabWidthPx = Math.floor(this._tabContainerWidth * percent / 100); 
            } else {
                maximumTabWidthPx = Echo.Sync.Extent.toPixels(maximumTabWidth);
            }
        }
        
        for (i = 0; i < this._tabs.length; ++i) {
            // Clear height/width settings.
            this._tabs[i]._heightTd.style.height = clearHeight;
            if (maximumTabWidthPx) {
                this._tabs[i]._textDiv.style.width = "";
                var labelBounds = new Core.Web.Measure.Bounds(this._tabs[i]._textDiv, 
                            { flags: Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION });
                if (labelBounds.width > maximumTabWidthPx) {
                    this._tabs[i]._textDiv.style.width = maximumTabWidthPx + "px";
                }
            }
            
            // Determine bounds of tab.
            var headerDivBounds = new Core.Web.Measure.Bounds(this._tabs[i]._headerDiv, 
                    { flags: Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION });
            
            // Determine adjustment in height of tab when it is active.
            var adjust = this._tabActiveHeightIncreasePx + this._tabInactivePositionAdjustPx +
                    this._tabs[i]._activeSurroundHeight - this._tabs[i]._inactiveSurroundHeight;

            // Load tab active and inactive heights.
            if (this._tabs[i]._active) {
                tabActiveHeight = headerDivBounds.height;
                tabInactiveHeight = headerDivBounds.height - adjust;
            } else {
                tabInactiveHeight = headerDivBounds.height;
                tabActiveHeight = headerDivBounds.height + adjust;
            }
            
            // Set maximum active/inactive heights if necessary.
            maxInactiveHeight = tabInactiveHeight > maxInactiveHeight ? tabInactiveHeight : maxInactiveHeight;
            maxActiveHeight = tabActiveHeight > maxActiveHeight ? tabActiveHeight : maxActiveHeight;
            
            // Horizontally position the tab at rightmost position.
            this._tabs[i]._headerDiv.style.left = this._totalTabWidth + "px";
            
            // Set z-index of tab based on position (left to right increase, but with active tab above all inactive tabs,
            // and rollover tab above all tabs).
            this._tabs[i]._headerDiv.style.zIndex = (this._rolloverTabId === this._tabs[i].id) ? (this._tabs.length) : 
                    (this._tabs[i]._active ? this._tabs.length + 1: i);
            
            // Move rendering cursor to right / calculate total width.
            this._totalTabWidth += headerDivBounds.width;
            if (i < this._tabs.length - 1) {
                // Add tab spacing.
                this._totalTabWidth += this._tabSpacingPx;
            }
        }

        // Set minimum heights of tabs for height equalization.
        for (i = 0; i < this._tabs.length; ++i) {
            if (this._tabs[i]._active) {
                this._tabs[i]._heightTd.style.height = (maxActiveHeight -
                        (this._tabs[i]._activeSurroundHeight + this._tabInactivePositionAdjustPx + 
                        this._tabActiveHeightIncreasePx)) + "px";
            } else {
                this._tabs[i]._heightTd.style.height = (maxInactiveHeight - this._tabs[i]._inactiveSurroundHeight) + "px";
            }
        }
        
        // Determine maximum height of tabs (either active or inactive).
        this._headerHeight = maxActiveHeight > maxInactiveHeight ? maxActiveHeight : maxInactiveHeight;
        
        if (Core.Web.VirtualPosition.enabled) {
            for (i = 0; i < this._tabs.length; ++i) {
                if (this._tabs[i]._fibContainer) {
                    Echo.Sync.FillImageBorder.renderContainerDisplay(this._tabs[i]._fibContainer);
                    Core.Web.VirtualPosition.redraw(this._tabs[i]._backgroundDiv);
                }
            }
        }
    },
    
    /**
     * Determines the renderId of the active tab child component.
     * This method first queries the component's <code>activeTabId</code> property, 
     * and if it is not set, the id is determined by finding the child component at the 
     * index specified by the component's <code>activeTabIndex</code> property.
     *
     * @return the active tab renderId
     * @type String
     */
    _getActiveTabId: function() {
        var activeTabId = this.component.get("activeTabId");
        if (!activeTabId) {
            var activeTabIndex = this.component.get("activeTabIndex");
            if (activeTabIndex != null && activeTabIndex < this.component.children.length) {
                activeTabId = this.component.children[activeTabIndex].renderId;
            }
        }
        return activeTabId;
    },
    
    /**
     * Determines the pxiel height of the separation between inactive tabs and the tab content area.  (For a TAB_POSITION_TOP,
     * this is the bottom of the tabs to the top of tab content).
     * 
     * @return the height
     * @type Number
     */
    _getSeparatorHeight: function() {
        if (this._borderType == Extras.TabPane.BORDER_TYPE_NONE) {
            return 0;
        }
        
        if (this._imageBorder) {
            //FIXME, possibly provide a configurable property for this.
            return 0;
        }

        return Echo.Sync.Border.getPixelSize(this._border, this._tabSide);
    },

    /**
     * Retrieves the tab instance with the specified tab id.
     *
     * @param tabId the tab render id
     * @return the tab, or null if no tab is present with the specified id
     * @type Extras.Sync.TabPane.Tab
     */
    _getTabById: function(tabId) {
        for (var i = 0; i < this._tabs.length; ++i) {
            var tab = this._tabs[i];
            if (tab.id == tabId) {
                return tab;
            }
        }
        return null;
    },
    
    /** @see Echo.Render.ComponentSync#isChildDisplayed */
    isChildVisible: function(component) {
        return component.renderId == this._activeTabId;
    },
    
    /**
     * Handler for mouse rollover enter/exit events on previous/next scroll buttons.
     * 
     * @param e the mouse rollover event
     */
    _processScrollRollover: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        
        var previous = e.registeredTarget === this._previousControlDiv;
        var enter = e.type == "mouseover";
        var icon;
        
        if (enter) {
            // Set rollover icon.
            icon = previous ? this._icons.rolloverScrollLeftIcon : this._icons.rolloverScrollRightIcon;
            if (!icon && !(previous ? this._icons.scrollLeftIcon : this._icons.scrollRightIcon)) {
                // Configured rollover icon not found, Use default rollover icon, but only if default icon is in use.
                icon = this.client.getResourceUrl("Extras", previous ? 
                        "image/tabpane/PreviousRollover.png" : "image/tabpane/NextRollover.png");
            }
        } else {
            // Set default icon.
            icon = previous ? this._icons.scrollLeftIcon : this._icons.scrollRightIcon;
            if (!icon) {
                icon = this.client.getResourceUrl("Extras", previous ? "image/tabpane/Previous.png" : "image/tabpane/Next.png");
            }
        }
        
        if (icon) {
            e.registeredTarget.firstChild.src = Echo.Sync.ImageReference.getUrl(icon);
        }
    },
    
    /**
     * Handler for mouse down event on previous/next scroll buttons.
     * 
     * @param e the mouse down event
     */
    _processScrollStart: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        
        this._scrollRunnable = new Extras.Sync.TabPane.ScrollRunnable(this, e.registeredTarget === this._previousControlDiv);
        Core.Web.Scheduler.add(this._scrollRunnable);
    },
    
    /**
     * Handler for mouse up event on previous/next scroll buttons.
     * 
     * @param e the mouse up event
     */
    _processScrollStop: function(e) {
        if (!this._scrollRunnable) {
            return;
        }
        this._scrollRunnable.finish();
        this._scrollRunnable = null;
    },
    
    /**
     * Removes a specific tab.  Removes its rendering from the DOM.
     *
     * @param {Extras.Sync.TabPane.Tab} tab the tab to remove
     */
    _removeTab: function(tab) {
        var tabIndex = Core.Arrays.indexOf(this._tabs, tab);
        if (tabIndex == -1) {
            return;
        }
        if (tab.id == this._activeTabId) {
            this._activeTabId = null;
        }
        this._tabs.splice(tabIndex, 1);
        
        Core.Web.DOM.removeNode(tab._headerDiv);
        Core.Web.DOM.removeNode(tab._contentDiv);
        
        tab._renderDispose();
    },
    
    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this.component.addListener("tabSelect", this._tabSelectListenerRef);
        
        // Store rendering properties.
        this._icons = { 
            scrollLeftIcon: this.component.render("scrollLeftIcon"),
            scrollRightIcon: this.component.render("scrollRightIcon"),
            rolloverScrollLeftIcon: this.component.render("rolloverScrollLeftIcon"),
            rolloverScrollRightIcon: this.component.render("rolloverScrollRightIcon")
        };
        this._rtl = !this.component.getRenderLayoutDirection().isLeftToRight();
        this._activeTabId = this._getActiveTabId();
        this._tabRolloverEnabled = this.component.render("tabRolloverEnabled");
        this._insets = this.component.render("insets", Extras.Sync.TabPane._DEFAULTS.insets);
        this._tabActiveBorder = this.component.render("tabActiveBorder", Extras.Sync.TabPane._DEFAULTS.tabActiveBorder);
        this._imageBorder = this.component.render("imageBorder");
        this._border = this._imageBorder ? null : this._border = this.component.render("border", this._tabActiveBorder);
        this._borderType = this.component.render("borderType", Extras.Sync.TabPane._DEFAULTS.borderType);
        this._tabInactiveBorder = this.component.render("tabInactiveBorder", Extras.Sync.TabPane._DEFAULTS.tabInactiveBorder);
        this._tabInsetPx = Echo.Sync.Extent.toPixels(this.component.render("tabInset",Extras.Sync.TabPane._DEFAULTS.tabInset));
        this._tabPositionBottom = this.component.render("tabPosition", Extras.Sync.TabPane._DEFAULTS.tabPosition) == 
                Extras.TabPane.TAB_POSITION_BOTTOM;
        this._tabSide = this._tabPositionBottom ? "bottom" : "top";
        this._oppositeSide = this._tabPositionBottom ? "top" : "bottom";
        this._tabSpacingPx = Echo.Sync.Extent.toPixels(this.component.render("tabSpacing", 
                Extras.Sync.TabPane._DEFAULTS.tabSpacing));
        this._tabActiveHeightIncreasePx = Echo.Sync.Extent.toPixels(
                this.component.render("tabActiveHeightIncrease", Extras.Sync.TabPane._DEFAULTS.tabActiveHeightIncrease));
        this._tabInactivePositionAdjustPx = this._getSeparatorHeight();
        this._tabCloseEnabled = this.component.render("tabCloseEnabled", false);
        if (this._tabCloseEnabled) {
            this._icons.defaultIcon = this.component.render("tabCloseIcon");
            this._icons.disabledIcon = this.component.render("tabDisabledCloseIcon");
            this._icons.rolloverIcon = this.component.render("tabRolloverCloseIcon");
        }
        this._tabActiveInsets = Echo.Sync.Insets.toPixels(this.component.render("tabActiveInsets"));
        this._tabInactiveInsets = Echo.Sync.Insets.toPixels(this.component.render("tabInactiveInsets"));
        this._tabHeight = Echo.Sync.Extent.toPixels(this.component.render("tabHeight"), false) || 0;

        // Store rendering properties: border/content insets.
        var pixelInsets = Echo.Sync.Insets.toPixels(this._insets);
        if (this._imageBorder) {
            this._ibBorderInsetsPx = Echo.Sync.Insets.toPixels(this._imageBorder.borderInsets);
            this._ibContentInsetsPx = Echo.Sync.Insets.toPixels(this._imageBorder.contentInsets);
        }
        if (this._borderType == Extras.TabPane.BORDER_TYPE_SURROUND) {
            if (this._imageBorder) {
                pixelInsets[this._oppositeSide] += this._ibContentInsetsPx[this._oppositeSide];
                pixelInsets.left += this._ibContentInsetsPx.left;
                pixelInsets.right += this._ibContentInsetsPx.right;
            }
        } else if (this._borderType == Extras.TabPane.BORDER_TYPE_PARALLEL_TO_TABS) {
            if (this._imageBorder) {
                this._imageBorder = {
                    color: this._imageBorder.color,
                    borderInsets: this._ibBorderInsetsPx.top + "px 0 " + this._ibBorderInsetsPx.bottom + "px",
                    contentInsets: this._ibContentInsetsPx.top + "px 0 " + this._ibContentInsetsPx.bottom + "px",
                    top: this._imageBorder.top,
                    bottom: this._imageBorder.bottom
                };
                pixelInsets[this._oppositeSide] += this._ibContentInsetsPx[this._oppositeSide];
            }
            pixelInsets.left = pixelInsets.right = 0;
        } else {
            if (this._imageBorder) {
                var pre = this._tabPositionBottom ? "0 0 " : "";
                var post = this._tabPositionBottom ? "" : " 0 0";
                this._imageBorder = {
                    color: this._imageBorder.color,
                    borderInsets: pre + this._ibBorderInsetsPx[this._tabSide] + "px" + post,
                    contentInsets: pre + this._ibContentInsetsPx[this._tabSide] + "px" + post,
                    top: this._imageBorder.top
                };
            }
            pixelInsets.left = pixelInsets.right = pixelInsets[this._oppositeSide] = 0;
        }

        // Create Main Element.
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        this._div.style.cssText = "position:absolute;top:" + pixelInsets.top + "px;right:" + pixelInsets.right +
                "px;bottom:" + pixelInsets.bottom + "px;left:" + pixelInsets.left + "px;";
                        
        this._headerContainerBoundsDiv = document.createElement("div");
        this._headerContainerBoundsDiv.style.cssText = "position:absolute;overflow:hidden;z-index:1;" +
                (this._tabPositionBottom ? "bottom" : "top") + ":0;" +
                "left:" + this._tabInsetPx + "px;right:" + this._tabInsetPx + "px;";
        this._div.appendChild(this._headerContainerBoundsDiv);
                
        // Render Header Container.
        this._headerContainerDiv = document.createElement("div");
        this._headerContainerDiv.style.cssText = "position:absolute;left:0;right:0;top:0;bottom:0;";
                
        Echo.Sync.Font.render(this.component.render("font"), this._headerContainerDiv);
        Echo.Sync.FillImage.render(this.component.render("tabBackgroundImage"), this._headerContainerDiv);
        this._headerContainerBoundsDiv.appendChild(this._headerContainerDiv);
        
        // Render Image Border (optional).
        if (this._imageBorder) {
            this._borderDiv = Echo.Sync.FillImageBorder.renderContainer(this._imageBorder, { absolute: true });
            if (this._tabPositionBottom) {
                this._borderDiv.style.top = (0 - this._ibContentInsetsPx.top) + "px";
                this._borderDiv.style.bottom = 0;
            } else {
                this._borderDiv.style.top = 0;
                this._borderDiv.style.bottom = (0 - this._ibContentInsetsPx.bottom) + "px";
            }
            this._borderDiv.style.left = (0 - this._ibContentInsetsPx.left) + "px";
            this._borderDiv.style.right = (0 - this._ibContentInsetsPx.right) + "px";
            this._div.appendChild(this._borderDiv);
        }
        
        // Render Content Container.
        this._contentContainerDiv = document.createElement("div");
        this._contentContainerDiv.style.cssText = "position:absolute;overflow:hidden;";
        Echo.Sync.renderComponentDefaults(this.component, this._contentContainerDiv);
        if (this._border) {
            if (this._borderType == Extras.TabPane.BORDER_TYPE_NONE) {
                this._contentContainerDiv.style.border = "0 none";
            } else if (this._borderType == Extras.TabPane.BORDER_TYPE_SURROUND) {
                Echo.Sync.Border.render(this._border, this._contentContainerDiv);
            } else if (this._borderType == Extras.TabPane.BORDER_TYPE_PARALLEL_TO_TABS) {
                Echo.Sync.Border.render(this._border, this._contentContainerDiv, "borderTop");
                Echo.Sync.Border.render(this._border, this._contentContainerDiv, "borderBottom");
            } else if (this._tabPositionBottom) {
                Echo.Sync.Border.render(this._border, this._contentContainerDiv, "borderBottom");
            } else {
                Echo.Sync.Border.render(this._border, this._contentContainerDiv, "borderTop");
            }
        }
        this._div.appendChild(this._contentContainerDiv);

        this._verifyActiveTabAvailable();
        
        // Create tabs.
        for (var i = 0; i < this.component.children.length; ++i) {
            var tab = new Extras.Sync.TabPane.Tab(this.component.children[i], this);
            this._addTab(update, tab);
        }

        this._layoutRequired = true;
        
        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDisplay */
    renderDisplay: function() {
        var i, tab;
        
        Core.Web.VirtualPosition.redraw(this._div);
        this._tabContainerWidth = new Core.Web.Measure.Bounds(this._div, 
                { flags: Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION }).width - (2 * this._tabInsetPx);
        
        this._renderHeaderUpdate();
        
        this._renderLayout();
        
        // Process a change in active tab, update displayed tab.
        if (this._displayedTabId != this._activeTabId) {
            if (this._displayedTabId != null) {
                tab = this._getTabById(this._displayedTabId);
                tab._renderState(false);
            }
            if (this._activeTabId != null) {
                tab = this._getTabById(this._activeTabId);
                tab._renderState(true);
            }
            this._displayedTabId = this._activeTabId;
        }

        this._renderHeaderPositions();

        // Virtual positioning
        if (this._borderDiv) {
            Core.Web.VirtualPosition.redraw(this._borderDiv);
            Echo.Sync.FillImageBorder.renderContainerDisplay(this._borderDiv);
        }
        
        Core.Web.VirtualPosition.redraw(this._contentContainerDiv);
        Core.Web.VirtualPosition.redraw(this._headerContainerDiv);
        
        for (i = 0; i < this._tabs.length; ++i) {
            this._tabs[i]._renderDisplay();
        }

        // Re-bound scroll position.
        this.setScrollPosition(this.scrollPosition);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this.component.removeListener("tabSelect", this._tabSelectListenerRef);

        this._activeTabId = null;
        for (var i = 0; i < this._tabs.length; i++) {
            this._tabs[i]._renderDispose();
        }
        this._tabs = [];
        this._div = null;
        this._borderDiv = null;
        this._headerContainerBoundsDiv = null;
        this._headerContainerDiv = null;
        this._contentContainerDiv = null;
        if (this._previousControlDiv) {
            Core.Web.Event.removeAll(this._previousControlDiv);
            this._previousControlDiv = null;
        }
        if (this._nextControlDiv) {
            Core.Web.Event.removeAll(this._nextControlDiv);
            this._nextControlDiv = null;
        }
    },
    
    /**
     * Renders a full update to the header, if required.
     */
    _renderHeaderUpdate: function() {
        if (!this._headerUpdateRequired) {
            return;
        }
        this._headerUpdateRequired = false;
        for (var i = 0; i < this._tabs.length; ++i) {
            this._tabs[i]._loadProperties();
            this._tabs[i]._renderHeaderState(this._tabs[i].id === this._activeTabId, false, true);
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var fullRender = false,
            tab,
            i;
        
        if (update.hasUpdatedLayoutDataChildren()) {
            this._headerUpdateRequired = true;
        }
        if (!fullRender) {
            if (!Core.Arrays.containsAll(Extras.Sync.TabPane._supportedPartialProperties, 
                    update.getUpdatedPropertyNames(), true)) {
                // Update contains property changes that cannot be partially re-rendered.
                fullRender = true;
            }
        }
        if (!fullRender) {
            var activeTabRemoved = false;
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                // Remove children.
                for (i = 0; i < removedChildren.length; ++i) {
                    tab = this._getTabById(removedChildren[i].renderId);
                    if (!tab) {
                        continue;
                    }
                    if (removedChildren[i].renderId == this._displayedTabId) {
                        this._displayedTabId = null;
                    }
                    this._removeTab(tab);
                }
            }
            var addedChildren = update.getAddedChildren();
            if (addedChildren) {
                // Add children.
                for (i = 0; i < addedChildren.length; ++i) {
                    tab = new Extras.Sync.TabPane.Tab(addedChildren[i], this);
                    this._addTab(update, tab, this.component.indexOf(addedChildren[i]));
                }
            }
            if (update.hasUpdatedProperties()) {
                // partial update
                if (update.getUpdatedProperty("activeTabId")) {
                    this._activeTabId = update.getUpdatedProperty("activeTabId").newValue;
                } else if (update.getUpdatedProperty("activeTabIndex")) {
                    var newIndex = update.getUpdatedProperty("activeTabIndex").newValue;
                    if (newIndex >= 0 && newIndex < this.component.children.length) {
                        this._activeTabId = this.component.children[newIndex].renderId;
                    }
                }
            }
            this._verifyActiveTabAvailable();
            this._layoutRequired = true;
        }
    
        if (fullRender) {
            var div = this._div;
            var containerElement = div.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(div);
            this.renderAdd(update, containerElement);
        }
        return fullRender;
    },
    
    /**
     * Enables/disables the scrolling controls used when the tab header is to wide to be displayed entirely at once.
     * This method will lazy-render the specified scrolling control if it has not been previously enabled. 
     * 
     * @param {Boolean} previous flag indicating which scrolling control should be enabled/disabled, true indicating the
     *        scroll-to-previous control, false indicating the scroll-to-next control
     * @param {Boolean} enabled the new enabled state
     */
    _setOversizeEnabled: function(previous, enabled) {
        var controlDiv = previous ? this._previousControlDiv : this._nextControlDiv,
            img;

        if (enabled) {
            if (controlDiv) {
                controlDiv.style.display = "block";
            } else {
                controlDiv = document.createElement("div");
                controlDiv.style.cssText = "position:absolute;z-index:2;cursor:pointer;";
                
                controlDiv.style[previous ? "left" : "right"] = "2px";
                
                img = document.createElement("img");
                controlDiv.appendChild(img);

                Core.Web.Event.add(controlDiv, "mousedown", Core.method(this, this._processScrollStart));
                Core.Web.Event.add(controlDiv, "mouseup", Core.method(this, this._processScrollStop));
                Core.Web.Event.add(controlDiv, "mouseover", Core.method(this, this._processScrollRollover)); 
                Core.Web.Event.add(controlDiv, "mouseout", Core.method(this, this._processScrollRollover)); 
                Core.Web.Event.Selection.disable(controlDiv);

                if (previous) {
                    img.src = this._icons.scrollLeftIcon ? Echo.Sync.ImageReference.getUrl(this._icons.scrollLeftIcon) :
                            this.client.getResourceUrl("Extras", "image/tabpane/Previous.png");
                    this._previousControlDiv = controlDiv;
                } else {
                    img.src = this._icons.scrollRightIcon ? Echo.Sync.ImageReference.getUrl(this._icons.scrollRightIcon) :
                            this.client.getResourceUrl("Extras", "image/tabpane/Next.png");
                    this._nextControlDiv = controlDiv;
                }
                this._div.appendChild(controlDiv);
                
                var tabContainerHeight = new Core.Web.Measure.Bounds(this._headerContainerDiv,
                        { flags: Core.Web.Measure.Bounds.FLAG_MEASURE_DIMENSION }).height;
                var imageListener = Core.method(this, function() {
                    if (img.height && !isNaN(img.height)) {
                        var imgOffset = Math.floor((tabContainerHeight - img.height) / 2);
                        if (imgOffset > 0) {
                            controlDiv.style[this._tabPositionBottom ? "bottom" : "top"] = imgOffset + "px";
                        }
                    }
                });
                Core.Web.Image.monitor(controlDiv, imageListener);
                imageListener();
            }
        } else if (controlDiv) {
            controlDiv.style.display = "none";
        }
    },
    
    /**
     * Sets the currently rolled-over tab.
     * Enqueues a slightly delayed runnable to perform the operation in order to prevent flicker.
     * 
     * @param {String} tabId the tab id (renderId of child componeent)
     * @param {Boolean} state the rollover state of the tab
     */
    _setRolloverTab: function(tabId, state) {
        this._pendingRollover = { tabId: tabId, state: state };
        if (!this._rolloverRunnable) {
            this._rolloverRunnable = new Core.Web.Scheduler.MethodRunnable(Core.method(this, function() {
                this._setRolloverTabImpl(this._pendingRollover.tabId, this._pendingRollover.state);
            }));
        }
        Core.Web.Scheduler.add(this._rolloverRunnable);
    },
    
    /**
     * Implementation work method for setting currently rolled over tab.
     * 
     * @param {String} tabId the tab id (renderId of child componeent)
     * @param {Boolean} state the rollover state of the tab
     */
    _setRolloverTabImpl: function(tabId, state) {
        var rolloverTab = this._rolloverTabId && this._getTabById(this._rolloverTabId);
        var tab = this._getTabById(tabId);
        if (state) {
            if (this._rolloverTabId != tabId) {
                if (rolloverTab) {
                    rolloverTab.setRollover(false, false);
                }
                this._rolloverTabId = tabId;
                tab.setRollover(true);
            }
        } else {
            if (this._rolloverTabId == tabId) {
                this._rolloverTabId = null;
                rolloverTab.setRollover(false, false);
            } else {
                // Tab state is already non-rollover, do nothing.
            }
        }
    },
    
    /**
     * Sets the scroll position of the tab header.
     * 
     * @param {Number} position the scroll position, in pixels
     * @return a boolean state indicating whether the scroll position could be set exactly (true) or was bounded by
     *         an attempt too be scrolled to far (false)
     * @type Boolean
     */
    setScrollPosition: function(position) {
        var bounded = false,
            oversize = this._totalTabWidth > this._tabContainerWidth;
            
        // Set position to zero in the event that header is not oversize.
        position = oversize ? position : 0;
            
        if (position < 0) {
            position = 0;
            bounded = true;
        } else if (position > 0 && position > this._totalTabWidth - this._tabContainerWidth) {
            position = this._totalTabWidth - this._tabContainerWidth;
            bounded = true;
        }
        this.scrollPosition = position;
        this._headerContainerDiv.style.left = (0 - position) + "px";
        
        if (oversize) {
            this._setOversizeEnabled(true, position > 0);
            this._setOversizeEnabled(false, position < this._totalTabWidth - this._tabContainerWidth);
        } else {
            this._setOversizeEnabled(true, false);
            this._setOversizeEnabled(false, false);
        }
        
        return !bounded;
    },
    
    /**
     * Event listener to component instance for user tab selections.
     * 
     * @param e the event
     */
    _tabSelectListener: function(e) {
        this._activeTabId = e.tab.renderId;
        Echo.Render.renderComponentDisplay(this.component);
    },
    
    /**
     * Ensures an active tab is present, if possible.
     */
    _verifyActiveTabAvailable: function() {
        for (var i = 0; i < this.component.children.length; ++i) {
            if (this.component.children[i].renderId == this._activeTabId) {
                return;
            }
        }
        this._activeTabId = this.component.children.length === 0 ? null : this.component.children[0].renderId; 
    }
});

/**
 * Representation of a single tab (child component) within the tab pane.
 * Provides tab-specific rendering functionality, handles setting active state
 * on/off for an individual tab.
 */
Extras.Sync.TabPane.Tab = Core.extend({
    
    /**
     * Active state of the tab (true indicating the tab is the active tab in its TabPane).
     * Initial (non-rendered) state is indicated by null.
     * @type Boolean
     */
    _active: null,
    
    /**
     * The child component which will be rendered within the tab.
     * @type Echo.Component
     */
    _childComponent: null,
    
    /**
     * The FillImageBorder container component housing the tab, if in use.
     * @type Element
     */
    _fibContainer: null,
    
    /**
     * The TabPane synchronization peer.
     * @type Extras.Sync.TabPane
     */
    _parent: null,
    
    /**
     * DIV element containing tab header (highest level element managed by Tab object in the header).
     * @type Element
     */
    _headerDiv: null,
    
    /**
     * The DIV element which will contain the rendered child component.
     * @type Element
     */
    _contentDiv: null,
    
    /**
     * TD element containing close icon.
     * @type Element
     */
    _closeIconTd: null,
    
    /**
     * Flag indicating whether the tab may be closed.
     * @type Boolean
     */
    _tabCloseEnabled: false,
    
    /**
     * The default set z-index of the tab.  This value is used to store the previous z-index value when
     * a tab is rolled over (and its z-index is thus raised).
     * @type Number
     */
    _defaultZIndex: 0,
    
    /**
     * The total height of the active tab border and insets, in pixels.
     * @type Number 
     */
    _activeSurroundHeight: null,
    
    /**
     * The total height of the inactive tab border and insets, in pixels.
     * @type Number 
     */
    _inactiveSurroundHeight: null,
    
    /**
     * The DIV containing the tab's label, i.e., title and icon.
     * @type Element
     */
    _labelDiv: null,
    
    /**
     * DIV containing the tab's text content.  The width of this DIV is measured and set when using maximum tab widths.
     * @type Element
     */
    _textDiv: null,
    
    /**
     * The tab identifier, i.e., the renderId of the child component.
     * @type String
     */
    id: null,
    
    /**
     * Creates a new Tab instance.
     * 
     * @param {Echo.Component} childComponent the child component which will be rendered within the tab
     * @param {Extras.Sync.TabPane} parent the TabPane synchronization peer
     */
    $construct: function(childComponent, parent) {
        this.id = childComponent.renderId;
        // state
        this._childComponent = childComponent;
        this._parent = parent;
    },
    
    /**
     * Retries the close image (either default or rollover).
     * 
     * @param rollover flag indicating whether rollover (true) or default (false) image should be returned
     * @type #ImageReference
     */
    _getCloseImage: function(rollover) {
        var icons = this._parent._icons;
        var icon;
        if (this._tabCloseEnabled) {
            if (rollover && this._parent.component.render("tabCloseIconRolloverEnabled")) {
                icon = icons.rolloverIcon;
            }
        } else {
            icon = icons.disabledIcon;
        }
        return icon ? icon : icons.defaultIcon || this._parent.client.getResourceUrl("Extras", "image/tabpane/Close.gif");
    },

    /**
     * Determine content inset margin.
     * 
     * @return the content inset margin
     * @type #Insets
     */
    _getContentInsets: function() {
        if (this._childComponent.pane) {
            // Do not render insets on panes.
            return 0;
        } else {
            return this._parent.component.render("defaultContentInsets", Extras.Sync.TabPane._DEFAULTS.tabContentInsets);
        }
    },
    
    /**
     * Returns the style property which should be used for a given tab property.
     * Queries layout data and component properties.
     * Queries rollover properties if applicable (and defaults to non-rollover property if unspecified).
     * 
     * @param {String} name the name of the property, first letter capitalized, e.g., "Background"
     * @param {Boolean} active the active state
     * @param {Boolean} rollover the rollover state
     * @return the property value
     */
    _getProperty: function(name, active, rollover) {
        var value = this._layoutData[(active ? "active" : "inactive") + name] ||
                this._parent.component.render((active ? "tabActive" : "tabInactive") + name);
        if (!active && rollover) {
            value = this._layoutData["rollover" + name] || this._parent.component.render("tabRollover" + name) || value;
        }
        return value;
    },
    
    /**
     * Determines the height of the border and insets surrounding the tab (supports both imageBorder and border properties).
     * Uses layout data information if provided.
     * 
     * @param {Boolean} active true to measure the active border, false for the inactive border
     * @return the combined top and bottom border height, in pixels
     * @type Number
     */
    _getSurroundHeight: function(active) {
        var insets, imageBorder, border, padding;
        
        insets = Echo.Sync.Insets.toPixels(this._getProperty("Insets", active, false) || Extras.Sync.TabPane._DEFAULTS.tabInsets);
        padding = insets.top + insets.bottom;
        
        if (this._useImageBorder) {
            imageBorder = this._getProperty("ImageBorder", active, false);
            insets = Echo.Sync.Insets.toPixels(imageBorder.contentInsets);
            return padding + insets.top + insets.bottom;
        } else {
            border = this._getProperty("Border", active, false) || 
                    (active ? this._parent._tabActiveBorder : this._parent._tabInactiveBorder);
            return padding + Echo.Sync.Border.getPixelSize(border, this._parent._tabSide); 
        }
    },
    
    /**
     * Loads state information.
     */
    _loadProperties: function() {
        this._layoutData = this._childComponent.render("layoutData") || {};
        this._useImageBorder = this._getProperty("ImageBorder", false, false);
        this._tabCloseEnabled = this._parent._tabCloseEnabled && this._layoutData.closeEnabled;
        this._activeSurroundHeight = this._getSurroundHeight(true);
        this._inactiveSurroundHeight = this._getSurroundHeight(false);
    },
    
    /**
     * Tab click handler.
     * 
     * @param e the click event
     */
    _processClick: function(e) {
        if (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component)) {
            return true;
        }
        if (this._closeIconTd && Core.Web.DOM.isAncestorOf(this._closeIconTd, e.target)) {
            // close icon clicked
            if (!this._tabCloseEnabled) {
                return;
            }
            this._parent.component.doTabClose(this.id);
        } else {
            // tab clicked
            this._parent.component.doTabSelect(this.id);
        }
    },
    
    /**
     * Tab close icon rollover enter/exit handler.
     * 
     * @param e the mouse event
     */
    _processCloseRollover: function(e) {
        var enter = e.type == "mouseover" || e.type == "mouseenter";
        if (enter && (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component))) {
            return true;
        }
        this._closeIconTd.firstChild.src = Echo.Sync.ImageReference.getUrl(this._getCloseImage(enter));
        return true;
    },
    
    /**
     * Tab rollover enter/exit handler.
     * 
     * @param e the mouse event
     */
    _processRollover: function(e) {
        var enter = e.type == "mouseover" || e.type == "mouseenter";
        if (enter && (!this._parent || !this._parent.client || !this._parent.client.verifyInput(this._parent.component))) {
            return true;
        }
        this._parent._setRolloverTab(this.id, enter);
    },
    
    /**
     * Renders the tab.
     * 
     * @param {Echo.Update.ComponentUpdate} update the component update 
     */
    _renderAdd: function(update) {
        this._loadProperties();
        
        // Header DIV
        this._headerDiv = document.createElement("div");
        this._headerDiv.style.cssText = "position:absolute;";

        // Content DIV
        this._contentDiv = document.createElement("div");
        this._contentDiv.style.cssText = "position:absolute;top:0;left:0;overflow:auto;";
        // hide content
        if (Core.Web.Env.BROWSER_MOZILLA && !Core.Web.Env.BROWSER_FIREFOX) {
            //FIXME doc/analyze/remove
            this._contentDiv.style.right = "100%";
            this._contentDiv.style.bottom = "100%";
        } else {
            this._contentDiv.style.display = "none";
            this._contentDiv.style.right = "0";
            this._contentDiv.style.bottom = "0";
        }
        Echo.Sync.Insets.render(this._getContentInsets(), this._contentDiv, "padding");
        Echo.Render.renderComponentAdd(update, this._childComponent, this._contentDiv);
        
        this._renderState(this.id == this._parent._activeTabId);
    },
    
    /**
     * Tab-specific renderDisplay() tasks.
     */
    _renderDisplay: function() {
        if (this._fibContainer) {
            Echo.Sync.FillImageBorder.renderContainerDisplay(this._fibContainer);
            Core.Web.VirtualPosition.redraw(this._backgroundDiv);
        }
        Core.Web.VirtualPosition.redraw(this._contentDiv);
    },
    
    /**
     * Disposes of the tab, releasing any resources.
     */
    _renderDispose: function() {
        Core.Web.Event.removeAll(this._headerDiv);
        if (this._rolloverRunnable) {
            Core.Web.Scheduler.remove(this._rolloverRunnable);
        }
        this._fibContainer = null;
        this._parent = null;
        this._childComponent = null;
        this._headerDiv = null;
        this._contentDiv = null;
        this._closeIconTd = null;
        this._iconImg = null;
        this._textDiv = null;
        this._closeImg = null;
        this._heightTd = null;
        this._labelDiv = null;
        this._backgroundDiv = null;
    },
    
    /**
     * Renders the tab header.
     * 
     * @param {Boolean} active the active state of the tab
     */
    _renderHeader: function(active) {
        var tabPane = this._parent.component,
            img, table, tr, td;
        
        Core.Web.Event.removeAll(this._headerDiv);
        Core.Web.DOM.removeAllChildren(this._headerDiv);
        
        // Configure Header DIV.
        this._headerDiv.style[this._parent._tabPositionBottom ? "top" : "bottom"] = 
                active ? 0 : (this._parent._tabInactivePositionAdjustPx + "px");
        if (this._layoutData.toolTipText) {
            this._headerDiv.title = this._layoutData.toolTipText;
        }
        
        // Create Label DIV.
        this._labelDiv = document.createElement("div");
        this._labelDiv.style.cssText = "position:relative;white-space:nowrap;overflow:hidden;";
        Echo.Sync.Extent.render(this._parent.component.render("tabWidth"), this._labelDiv, "width", true, false);
        var headerDivContent = this._labelDiv;

        if (this._useImageBorder) {
            var imageBorder = this._getProperty("ImageBorder", active, false);
            var backgroundInsets = this._getProperty("BackgroundInsets", active, false);
            this._fibContainer = headerDivContent =
                    Echo.Sync.FillImageBorder.renderContainer(imageBorder, { child: this._labelDiv });
            var fibContent = Echo.Sync.FillImageBorder.getContainerContent(this._fibContainer);
            fibContent.style.zIndex = 2;
            this._backgroundDiv = document.createElement("div");
            this._backgroundDiv.style.cssText = "position:absolute;z-index:1;";
            Echo.Sync.Insets.renderPosition(backgroundInsets || imageBorder.borderInsets, this._backgroundDiv);
            this._fibContainer.appendChild(this._backgroundDiv);
            
            if (Core.Web.Env.BROWSER_INTERNET_EXPLORER && Core.Web.Env.BROWSER_VERSION_MAJOR === 6) {
                headerDivContent = Extras.Sync.TabPane._createTable();
                td = document.createElement("td");
                td.style.cssText = "padding:0;";
                td.appendChild(this._fibContainer);
                headerDivContent.firstChild.firstChild.appendChild(td);
            }
        } else {
            var border = this._getProperty("Border", active, false) || 
                    (active ? this._parent._tabActiveBorder : this._parent._tabInactiveBorder);
            this._backgroundDiv = null;
            this._fibContainer = null;
            Echo.Sync.Border.render(border, this._labelDiv, this._parent._tabPositionBottom ? "borderBottom" : "borderTop");
            Echo.Sync.Border.render(border, this._labelDiv, "borderLeft");
            Echo.Sync.Border.render(border, this._labelDiv, "borderRight");
        }
        
        // Render Header Content.
        var icon = this._layoutData && this._layoutData.icon;
        var title = (this._layoutData ? this._layoutData.title : null) || "*";
        var closeIcon = this._parent._tabCloseEnabled && (this._tabCloseEnabled || this._parent._icons.disabledIcon); //FIXME?

        // Render Text and Icon(s)
        table = Extras.Sync.TabPane._createTable();
        tr = table.firstChild.firstChild;
        
        if (icon) {
            td = document.createElement("td");
            td.style.cssText = "padding:0;";
            Echo.Sync.Alignment.render(this._parent.component.render("tabAlignment", 
                    Extras.Sync.TabPane._DEFAULTS.tabAlignment), td, true, this._parent.component);
            this._iconImg = document.createElement("img");
            this._iconImg.style.marginRight = Echo.Sync.Extent.toCssValue(this._parent.component.render("tabIconTextMargin", 
                    Extras.Sync.TabPane._DEFAULTS.tabIconTextMargin), true, false);
            td.appendChild(this._iconImg);
            tr.appendChild(td);
        }

        this._heightTd = document.createElement("td");
        this._heightTd.style.cssText = "padding:0px;width:0px;";
        tr.appendChild(this._heightTd);
        
        td = document.createElement("td");
        td.style.cssText = "padding:0;";
        Echo.Sync.Alignment.render(tabPane.render("tabAlignment", Extras.Sync.TabPane._DEFAULTS.tabAlignment), td, true, tabPane);
        this._textDiv = document.createElement("div");
        this._textDiv.style.cssText = "overflow:hidden;white-space:nowrap;";
        this._textDiv.appendChild(document.createTextNode(title));
        td.appendChild(this._textDiv);
        
        tr.appendChild(td);
        
        if (closeIcon) {
            this._closeIconTd = document.createElement("td");
            this._closeIconTd.style.cssText = "padding:0;";
            Echo.Sync.Alignment.render(this._parent.component.render("tabAlignment", 
                    Extras.Sync.TabPane._DEFAULTS.tabAlignment), this._closeIconTd, true, this._parent.component);
            this._closeIconTd.style.padding = "0 0 0 " + Echo.Sync.Extent.toCssValue(
                    this._parent.component.render("tabCloseIconTextMargin", Extras.Sync.TabPane._DEFAULTS.tabCloseIconTextMargin), 
                    true, false);
            this._closeIconTd.style.cursor = "pointer";
            this._closeImg = document.createElement("img");
            Echo.Sync.ImageReference.renderImg(this._getCloseImage(false), this._closeImg);
            this._closeIconTd.appendChild(this._closeImg);
            tr.appendChild(this._closeIconTd);
        }
        this._labelDiv.appendChild(table);
        
        Core.Web.Event.Selection.disable(this._headerDiv);
        Core.Web.Event.add(this._headerDiv, "click", Core.method(this, this._processClick), false);
        Core.Web.Event.add(this._headerDiv, 
                Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseenter" : "mouseover", 
                Core.method(this, this._processRollover), false);
        Core.Web.Event.add(this._headerDiv,
                Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseleave" : "mouseout",
                Core.method(this, this._processRollover), false);
        if (this._tabCloseEnabled) {
            Core.Web.Event.add(this._closeIconTd, 
                    Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseenter" : "mouseover", 
                    Core.method(this, this._processCloseRollover), false);
            Core.Web.Event.add(this._closeIconTd,
                    Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseleave" : "mouseout",
                    Core.method(this, this._processCloseRollover), false);
        }
        
        this._headerDiv.appendChild(headerDivContent);
    },
    
    /**
     * Renders the appearance of the tab header active or inactive.
     * 
     * @param {Boolean} active the active state of the tab, true for active, false for inactive
     * @param {Boolean} rollover the rollover state of the tab, true for rolled over, false for not
     * @param {Boolean} force force re-render of the tab, even if specified states are identical to rendered states
     *        (method may normally perform no action under such conditions)
     */
    _renderHeaderState: function(active, rollover, force) {
        var fullRender = !this._labelDiv || force;
        
        if (fullRender) {
            this._renderHeader(active);
        }
        
        if (!force && this._active == active && (active || !this._parent._tabRolloverEnabled || this._rolloverState == rollover)) {
            return;
        }
        
        if (rollover) {
            this._defaultZIndex = this._headerDiv.style.zIndex;
            this._headerDiv.style.zIndex = this._parent.component.children.length;
        } else {
            this._headerDiv.style.zIndex = this._defaultZIndex;
        }
        
        this._rolloverState = rollover;

        var tabPane = this._parent.component,
            img, table, tr, td;
        
        Echo.Sync.Color.renderClear(this._getProperty("Foreground", active, rollover), this._labelDiv, "color");
        Echo.Sync.Font.renderClear(this._getProperty("Font", active, rollover), this._labelDiv);
        this._labelDiv.style.cursor = active ? "default" : "pointer";
        Echo.Sync.Insets.render(this._getProperty("Insets", active, false) || Extras.Sync.TabPane._DEFAULTS.tabInsets, 
                this._labelDiv, "padding"); 
                
        this._headerDiv.style[this._parent._tabPositionBottom ? "top" : "bottom"] = 
                active ? 0 : (this._parent._tabInactivePositionAdjustPx + "px");

        if (active) {
            this._labelDiv.style[this._parent._tabPositionBottom ? "paddingTop" : "paddingBottom"] =
                    (parseInt(this._labelDiv.style[this._parent._tabPositionBottom ? "paddingTop" : "paddingBottom"], 10) +
                    (this._parent._tabActiveHeightIncreasePx + this._parent._tabInactivePositionAdjustPx)) + "px";
        }
                
        if (!fullRender) {
            if (this._useImageBorder) {
                // Render FillImageBorder style.
                var imageBorder = this._getProperty("ImageBorder", active, rollover);
                var backgroundInsets = this._getProperty("BackgroundInsets", active, rollover);
                Echo.Sync.FillImageBorder.renderContainer(imageBorder, { update: this._fibContainer });
                Echo.Sync.Insets.renderPosition(backgroundInsets || imageBorder.borderInsets, this._backgroundDiv);
            } else {
                // Render CSS border style.
                var border = this._getProperty("Border", active, rollover) || 
                        (active ? this._parent._tabActiveBorder : this._parent._tabInactiveBorder);
                Echo.Sync.Border.render(border, this._labelDiv, this._parent._tabPositionBottom ? "borderBottom" : "borderTop");
                Echo.Sync.Border.render(border, this._labelDiv, "borderLeft");
                Echo.Sync.Border.render(border, this._labelDiv, "borderRight");
            }
        }
        
        Echo.Sync.Color.renderClear(this._getProperty("Background", active, rollover), 
                this._backgroundDiv || this._labelDiv, "backgroundColor");
        Echo.Sync.FillImage.renderClear(this._getProperty("BackgroundImage", active, rollover), 
                this._backgroundDiv || this._labelDiv, null);

        // Update icon.
        if (this._layoutData && this._layoutData.icon) {
            Echo.Sync.ImageReference.renderImg((active && this._layoutData.activeIcon) || 
                    (rollover && this._layoutData.rolloverIcon) || this._layoutData.icon, this._iconImg);
        }
    },
    
    /**
     * Renders the tab active or inactive, updating header state and showing/hiding tab content.
     * 
     * @param {Boolean} active the active state of the tab, true for active, false for inactive
     */
    _renderState: function(active) {
        if (this._active === active) {
            // Do nothing if values are unchanged.   
            // Note initial value of oldValue is null.
            return;
        }
        
        this._renderHeaderState(active);

        if (this._active !== null && !active) {
            // Notify child component hierarchy that it is being hidden (unless performing initial render,
            // i.e., this._active === null).
            Echo.Render.renderComponentHide(this._childComponent);
        }
        // show/hide content
        if (Core.Web.Env.BROWSER_MOZILLA && !Core.Web.Env.BROWSER_FIREFOX) {
            this._contentDiv.style.right = active ? "0" : "100%";
            this._contentDiv.style.bottom = active ? "0" : "100%";
        } else {
            this._contentDiv.style.display = active ? "block" : "none";
        }
        
        this._active = active;
    },
    
    /**
     * Sets the rollover state of the tab.
     * This is performed after a delay to avoid flickering.
     * 
     * @param {Boolean} rollover the desired rollover state
     */
    setRollover: function(rollover) {
        this._renderHeaderState(this._active, rollover);
        this._parent._renderHeaderPositions();
    }
});
/**
 * Component rendering peer: ToolTipContainer.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.ToolTipContainer = Core.extend(Echo.Render.ComponentSync, {
    
    $load: function() {
        Echo.Render.registerPeer("Extras.ToolTipContainer", this);
    },
    
    /**
     * Main container DIV element.
     * @type Element
     */
    _div: null,
    
    /**
     * DIV container for component to which tool tip is being applied.
     * @type Element
     */
    _applyDiv: null,
    
    /**
     * DIV container for tool tip component.
     * @type Element
     */
    _toolTipDiv: null,
    
    /**
     * Positions tool tip over applied-to component based on mouse position.
     * 
     * @param e a mouse event containing mouse cursor positioning information
     */
    _positionToolTip: function(e) {
        this._toolTipDiv.style.height = "";
        
        // Determine cursor position.
        var cursorX = (e.pageX || (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft)));
        var cursorY = (e.pageY || (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)));
        
        // Determine size of window and tip.
        var bodyBounds = new Core.Web.Measure.Bounds(document.body);
        var tipBounds = new Core.Web.Measure.Bounds(this._toolTipDiv.firstChild);
        
        // Load default tip position.
        var tipX = cursorX + 10;
        var tipY = cursorY + 10;
        
        // Ensure tip is on screen vertically.
        if (tipY + tipBounds.height > bodyBounds.height) {
            tipY = bodyBounds.height - tipBounds.height;
            if (tipY < 0) {
                tipY = 0;
            }
        }
        
        // Ensure tip is on screen horizontally (but never position it under cursor).
        if (cursorY < tipY && (tipX + tipBounds.width > bodyBounds.width)) {
            tipX = bodyBounds.width - tipBounds.width;
            if (tipX < 0) {
                tipX = 0;
            }
        }
        
        // Render tip position.
        this._toolTipDiv.style.left = tipX + "px";
        this._toolTipDiv.style.top = tipY + "px";
        
        Core.Web.VirtualPosition.redraw(this._toolTipDiv);
    },
    
    /**
     * Processes a mouse move event.
     * 
     * @param e the event
     */
    _processMove: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return;
        }
        this._positionToolTip(e);
        return true;
    },
    
    /**
     * Processes a mouse rollover enter event.
     * 
     * @param e the event
     */
    _processRolloverEnter: function(e) {
        if (!this.client || !this.client.verifyInput(this.component) || Core.Web.dragInProgress) {
            return;
        }
        
        if (this._toolTipDiv.parentNode !== document.body) {
            document.body.appendChild(this._toolTipDiv);
            this._positionToolTip(e);
        }
        return true;
    },
    
    /**
     * Processes a mouse rollover exit event.
     * 
     * @param e the event
     */
    _processRolloverExit: function(e) {
        if (!this.client || !this.client.verifyInput(this.component)) {
            return;
        }
        if (this._toolTipDiv.parentNode === document.body) {
            document.body.removeChild(this._toolTipDiv);
        }
        return true;
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._div = document.createElement("div");
        this._div.id = this.component.renderId;
        
        if (this.component.children.length > 0) {
            // Render main "apply to" component.
            this._applyDiv = document.createElement("div");
            this._applyDiv.style.cursor = "default";
            Echo.Render.renderComponentAdd(update, this.component.children[0], this._applyDiv);
            this._div.appendChild(this._applyDiv);
            
            if (this.component.children.length > 1) {
                // Register listeners on "apply to" component container.
                Core.Web.Event.add(this._applyDiv,
                        Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseenter" : "mouseover", 
                        Core.method(this, this._processRolloverEnter), true);
                Core.Web.Event.add(this._applyDiv,
                        Core.Web.Env.PROPRIETARY_EVENT_MOUSE_ENTER_LEAVE_SUPPORTED ? "mouseleave" : "mouseout", 
                        Core.method(this, this._processRolloverExit), true);
                Core.Web.Event.add(this._applyDiv, "mousemove", Core.method(this, this._processMove), true);
    
                // Create container for/render "tool tip" component.
                this._toolTipDiv = document.createElement("div");
                this._toolTipDiv.style.cssText = "position:absolute;z-index:30000;overflow:hidden;right:0;bottom:0;";
                
                var toolTipContentDiv = document.createElement("div");
                toolTipContentDiv.style.cssText = "position:absolute;"; 
                var width = this.component.render("width");
                if (width) {
                    toolTipContentDiv.style.width = Echo.Sync.Extent.toCssValue(width);
                }
                Echo.Render.renderComponentAdd(update, this.component.children[1], toolTipContentDiv);
                this._toolTipDiv.appendChild(toolTipContentDiv);
            }
        }
        
        parentElement.appendChild(this._div);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._div = null;
        
        if (this._applyDiv) {
            Core.Web.Event.removeAll(this._applyDiv);
            this._applyDiv = null;
        }
        
        if (this._toolTipDiv && this._toolTipDiv.parentNode === document.body) {
            document.body.removeChild(this._toolTipDiv);
            this._toolTipDiv = null;
        }
    },
    
    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var element = this._div;
        var containerElement = element.parentNode;
        Echo.Render.renderComponentDispose(update, update.parent);
        containerElement.removeChild(element);
        this.renderAdd(update, containerElement);
        return true;
    }
});
/**
 * Component rendering peer: TransitionPane.
 * This class should not be extended by developers, the implementation is subject to change.
 */
Extras.Sync.TransitionPane = Core.extend(Echo.Render.ComponentSync, {

    $load: function() {
        Echo.Render.registerPeer("Extras.TransitionPane", this);
    },

    /**
     * Outermost/top-level container element.
     * @type Element
     */
    _containerDiv: null,
    
    /**
     * Content element, contains oldChildDiv/childDiv elements.
     * @type Element
     */
    contentDiv: null,
    
    /**
     * The transition type value (retrieved from the component).
     * @type Number
     */
    type: null,
    
    /**
     * The transition which is actively running (null when content is not being transitioned).
     * @type Extras.Sync.TransitionPane.Transition
     */
    _transition: null,
    
    /**
     * Reference to the Extras.Sync.TransitionPane.Transition object type which will be instantiated to perform a transition.
     */
    _transitionClass: null,
    
    /**
     * The element containing the old child element, which is being transitioned FROM.
     * @type Element
     */
    oldChildDiv: null,
    
    /**
     * The element containing the current/new child element, which is being transitioned TO.
     * @type Element
     */
    childDiv: null,
    
    /**
     * Flag indicating whether initial content has been loaded (no transition effect is used on the first load).
     * @type Boolean
     */
    _initialContentLoaded: false,

    /**
     * Performs an immediate transition between old content and new content with no animated effect.
     */
    doImmediateTransition: function() {
        this.removeOldContent();
        if (this.childDiv) {
            this.showContent();
        }
    },

    /**
     * Determines the transition class that will be used to change content based on the
     * type value of the supported Extras.TransitionPane component. 
     */
    _loadTransition: function() {
        this.type = this.component.render("type");
        switch (this.type) {
        case Extras.TransitionPane.TYPE_FADE:
            this._transitionClass = Extras.Sync.TransitionPane.FadeOpacityTransition;
            break;
        case Extras.TransitionPane.TYPE_FADE_TO_BLACK:
        case Extras.TransitionPane.TYPE_FADE_TO_WHITE:
            this._transitionClass = Extras.Sync.TransitionPane.FadeOpacityColorTransition;
            break;
        case Extras.TransitionPane.TYPE_CAMERA_PAN_DOWN:
        case Extras.TransitionPane.TYPE_CAMERA_PAN_LEFT:
        case Extras.TransitionPane.TYPE_CAMERA_PAN_RIGHT:
        case Extras.TransitionPane.TYPE_CAMERA_PAN_UP:
            this._transitionClass = Extras.Sync.TransitionPane.CameraPanTransition;
            break;
        case Extras.TransitionPane.TYPE_BLIND_BLACK_IN:
        case Extras.TransitionPane.TYPE_BLIND_BLACK_OUT:
            this._transitionClass = Extras.Sync.TransitionPane.BlindTransition;
            break;
        default:
            this._transitionClass = null;
        }
    },
    
    /**
     * Removes old content: remove oldChildDiv from parent, set oldChildDiv to null.
     */
    removeOldContent: function() {
        if (this.oldChildDiv) {
            this.contentDiv.removeChild(this.oldChildDiv);
            this.oldChildDiv = null;
        }
    },

    /**
     * Shows new content.
     */
    showContent: function() {
        if (this.childDiv) {
            this.childDiv.style.visibility = "visible";
        }
    },

    /** @see Echo.Render.ComponentSync#renderAdd */
    renderAdd: function(update, parentElement) {
        this._containerDiv = document.createElement("div");
        this._containerDiv.id = this.component.renderId;
        this._containerDiv.style.cssText = "position:absolute;overflow:auto;top:0;left:0;width:100%;height:100%;";
        
        this.contentDiv = document.createElement("div");
        this.contentDiv.style.cssText = "position:absolute;overflow:hidden;top:0;left:0;width:100%;height:100%;";
        this._containerDiv.appendChild(this.contentDiv);
        
        parentElement.appendChild(this._containerDiv);
        if (this.component.children.length > 0) {
            this._renderAddChild(update);
        }
    },
    
    /**
     * Renders new content (a new child) added in an update.  Starts the transition.
     * 
     * @param {Echo.Update.ComponentUpdate} the update 
     */
    _renderAddChild: function(update) {
        this._loadTransition();
        this.childDiv = document.createElement("div");
        this.childDiv.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;";
        
        Echo.Render.renderComponentAdd(update, this.component.children[0], this.childDiv);
        
        if (this._initialContentLoaded) {
            this.childDiv.style.visibility = "hidden";
            if (this._transitionClass) {
                this._transitionStart();
            } else {
                this.doImmediateTransition();
            }
        } else {
            this._initialContentLoaded = true;
        }

        this.contentDiv.appendChild(this.childDiv);
    },
    
    /** @see Echo.Render.ComponentSync#renderDispose */
    renderDispose: function(update) {
        this._initialContentLoaded = false;
        if (this._transition) {
            this._transition.abort();
        }
        this._childDiv = null;
        this.contentDiv = null;
        this._containerDiv = null;
    },

    /** @see Echo.Render.ComponentSync#renderUpdate */
    renderUpdate: function(update) {
        var fullRender = false;
        if (update.hasUpdatedLayoutDataChildren()) {
            fullRender = true;
        } else if (update.hasUpdatedProperties()) {
            // Property updates
            var propertyNames = update.getUpdatedPropertyNames();
            if (!(propertyNames.length == 1 && propertyNames[0] == "type")) {
                // Properties other than 'type' have changed.
                fullRender = true;
            }
        }

        if (fullRender) {
            var contentDiv = this._containerDiv;
            var containerElement = contentDiv.parentNode;
            Echo.Render.renderComponentDispose(update, update.parent);
            containerElement.removeChild(contentDiv);
            this.renderAdd(update, containerElement);
        } else {
            if (this._transition) {
                this._transition.abort();
            }
        
            var removedChildren = update.getRemovedChildren();
            if (removedChildren) {
                // Remove children.
                this.oldChildDiv = this.childDiv;
                this.childDiv = null;
            }
            var addedChildren = update.getAddedChildren();
            if (update.parent.children > 1) {
                throw new Error("Cannot render more than one child in a TransitionPane.");
            }
            
            if (addedChildren) {
                // Add children.
                this._renderAddChild(update); 
            }
        }
        
        return fullRender;
    },
    
    /**
     * Initiates the animated transition effect.
     */
    _transitionStart: function() {
        this._transition = new this._transitionClass(this);
        this._transition.runTime = this.component.render("duration", this._transition.runTime);
        this._transition.start(Core.method(this, this._transitionFinish));
    },
    
    /**
     * Completes the animated transition effect. 
     */
    _transitionFinish: function(abort) {
        // Abort current transition, if necessary.
        if (this._transition) {
            this._transition = null;
            this.showContent();
        }
        
        // Remove content which was transitioned from.
        this.removeOldContent();
        
        // Refocus current focused component if it is within TransitionPane.
        if (this.component && this.component.application) {
            var focusedComponent = this.component.application.getFocusedComponent();
            if (focusedComponent != null && this.component.isAncestorOf(focusedComponent)) {
                Echo.Render.updateFocus(this.client);
            }
        }
    }
});

/**
 * Abstract base class for transition implementations.
 */
Extras.Sync.TransitionPane.Transition = Core.extend(Extras.Sync.Animation, {

    /**
     * The transition pane synchronization peer.
     * @type Extras.Sync.TransitionPane
     */
    transitionPane: null,

    /**
     * Duration of the transition, in milliseconds.
     * This value should be overridden when a custom duration time is desired.
     * This value will automatically be overridden if the TransitionPane component
     * has its "duration" property set.
     * @type Number
     * @see Extras.Sync.Animation#runTime
     */
    runTime: 350,

    /**
     * Interval at which transition steps should be invoked, in milliseconds.
     * @type Number
     * @see Extras.Sync.Animation#sleepInterval
     */
    sleepInterval: 10,
    
    $abstract: true,

    /**
     * Constructor.
     * 
     * @param {Extras.Sync.TransitionPane} transitionPane the transition pane peer 
     */
    $construct: function(transitionPane) {
        this.transitionPane = transitionPane;
    }
});

/**
 * Transition implementation to translate between old content and new content by flipping horizontal blinds, as though the old
 * screen were written to one side and the new screen were written to the other.
 * Uses a series of alpha-channeled PNG images to approximate the effect.
 */
Extras.Sync.TransitionPane.BlindTransition = Core.extend(Extras.Sync.TransitionPane.Transition, {

    /** @see Extras.Sync.Animation#runTime */
    runTime: 700,

    /**
     * The mask DIV that will display the blind graphic effect over the content.
     * @type Element
     */
    _maskDiv: null,
    
    /**
     * Number of steps (images) to display.
     * @type Number
     */
    _stepCount: 14,
    
    /**
     * Step number where old content will be swapped for new content.
     * @type Number
     */
    _swapStep: null,
    
    /**
     * Flag indicating whether the transition will occur in reverse order.
     * @type Boolean
     */
    _reverse: false,
    
    /** @see Extras.Sync.Animation#complete */
    complete: function(abort) {
        this._maskDiv.parentNode.removeChild(this._maskDiv);
    },
    
    /** @see Extras.Sync.Animation#init */
    init: function() {
        this._swapStep = Math.floor(this._stepCount) / 2 + 1;
        this._reverse = this.transitionPane.type === Extras.TransitionPane.TYPE_BLIND_BLACK_OUT;

        this._maskDiv = document.createElement("div");
        this._maskDiv.style.cssText = "position:absolute;width:100%;height:100%;z-index:30000;";
        this.transitionPane.contentDiv.appendChild(this._maskDiv);
    },

    /** @see Extras.Sync.Animation#step */
    step: function(progress) {
        var currentStep = Math.ceil(progress * this._stepCount);
        if (currentStep === 0) {
            currentStep = 1;
        }
        if (currentStep === this._renderedStep) {
            // No need to update, already current.
            return;
        }
        var url = this.transitionPane.client.getResourceUrl("Extras", 
                "image/transitionpane/blindblack/Frame" + currentStep + ".gif");
        this._maskDiv.style.backgroundImage = "url(" + url + ")";
        
        if (currentStep < this._swapStep) {
            if (this.transitionPane.oldChildDiv) {
                if (this._reverse) {
                    this.transitionPane.oldChildDiv.style.top = currentStep + "px";
                } else {
                    this.transitionPane.oldChildDiv.style.top = (0 - currentStep) + "px";
                }
            }
        } else {
            if (this._renderedStep < this._swapStep) {
                // blind is crossing horizontal, swap content.
                this.transitionPane.showContent();
                this.transitionPane.removeOldContent();
            }
            if (this.transitionPane.childDiv) {
                if (this._reverse) {
                    this.transitionPane.childDiv.style.top = (currentStep - this._stepCount) + "px";
                } else {
                    this.transitionPane.childDiv.style.top = (this._stepCount - currentStep) + "px";
                }
            }
        }

        this._renderedStep = currentStep;
    }    
});

/**
 * Transition implementation to pan from old content to new content, as though both were either horizontally
 * or vertically adjacent and the screen (camera) were moving from one to the other.
 */
Extras.Sync.TransitionPane.CameraPanTransition = Core.extend(
        Extras.Sync.TransitionPane.Transition, {
    
    /**
     * Flag indicating whether the new child (being transitioned to) has been placed on the screen.
     * @type Boolean
     */
    _newChildOnScreen: false,
    
    /**
     * The distance, in pixels, which content will travel across the screen (the width/height of the region).
     * @type Number 
     */
    _travel: null,

    /** @see Extras.Sync.Animation#complete */
    complete: function(abort) {
        if (this.transitionPane.childDiv) {
            this.transitionPane.childDiv.style.zIndex = 0;
            this.transitionPane.childDiv.style.top = "0px";
            this.transitionPane.childDiv.style.left = "0px";
        }
    },
    
    /** @see Extras.Sync.Animation#init */
    init: function() {
        var bounds = new Core.Web.Measure.Bounds(this.transitionPane.contentDiv);
        this._travel = (this.transitionPane.type == Extras.TransitionPane.TYPE_CAMERA_PAN_DOWN || 
                this.transitionPane.type == Extras.TransitionPane.TYPE_CAMERA_PAN_UP) ? bounds.height : bounds.width;
        if (this.transitionPane.oldChildDiv) {
            this.transitionPane.oldChildDiv.style.zIndex = 1;
        }
    },
    
    /** @see Extras.Sync.Animation#step */
    step: function(progress) {
        switch (this.transitionPane.type) {
        case Extras.TransitionPane.TYPE_CAMERA_PAN_DOWN:
            if (this.transitionPane.childDiv) {
                this.transitionPane.childDiv.style.top = ((1 - progress) * this._travel) + "px";
            }
            if (this.transitionPane.oldChildDiv) {
                this.transitionPane.oldChildDiv.style.top = (0 - (progress * this._travel)) + "px";
            }
            break;
        case Extras.TransitionPane.TYPE_CAMERA_PAN_UP:
            if (this.transitionPane.childDiv) {
                this.transitionPane.childDiv.style.top = (0 - ((1 - progress) * this._travel)) + "px";
            }
            if (this.transitionPane.oldChildDiv) {
                this.transitionPane.oldChildDiv.style.top = (progress * this._travel) + "px";
            }
            break;
        case Extras.TransitionPane.TYPE_CAMERA_PAN_RIGHT:
            if (this.transitionPane.childDiv) {
                this.transitionPane.childDiv.style.left = ((1 - progress) * this._travel) + "px";
            }
            if (this.transitionPane.oldChildDiv) {
                this.transitionPane.oldChildDiv.style.left = (0 - (progress * this._travel)) + "px";
            }
            break;
        default:
            if (this.transitionPane.childDiv) {
                this.transitionPane.childDiv.style.left = (0 - ((1 - progress) * this._travel)) + "px";
            }
            if (this.transitionPane.oldChildDiv) {
                this.transitionPane.oldChildDiv.style.left = (progress * this._travel) + "px";
            }
            break;
        }
        if (!this._newChildOnScreen && this.transitionPane.childDiv) {
            this.transitionPane.showContent();
            this.transitionPane.childDiv.style.zIndex = 2;
            this._newChildOnScreen = true;
        }
    }
});

/**
 * Transition implementation to fade from old content to new content.
 */
Extras.Sync.TransitionPane.FadeOpacityTransition = Core.extend(Extras.Sync.TransitionPane.Transition, {
    
    /** @see Extras.Sync.Animation#runTime */
    runTime: 1000,
    
    /** @see Extras.Sync.Animation#complete */
    complete: function(abort) {
        if (this.transitionPane.childDiv) {
            this.transitionPane.childDiv.style.zIndex = 0;
            if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
                this.transitionPane.childDiv.style.filter = "";
            } else {
                this.transitionPane.childDiv.style.opacity = 1;
            }
        }
    },
    
    /** @see Extras.Sync.Animation#init */
    init: function() {
        if (this.transitionPane.childDiv) {
            if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
                this.transitionPane.childDiv.style.filter = "alpha(opacity=0)";
            } else {
                this.transitionPane.childDiv.style.opacity = 0;
            }
        }
        this.transitionPane.showContent();
    },
    
    /** @see Extras.Sync.Animation#step */
    step: function(progress) {
        var percent;
        if (this.transitionPane.childDiv) {
            if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
                percent = Math.floor(progress * 100);
                this.transitionPane.childDiv.style.filter = "alpha(opacity=" + percent + ")";
            } else {
                this.transitionPane.childDiv.style.opacity = progress;
            }
        } else if (this.transitionPane.oldChildDiv) {
            if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
                percent = Math.floor((1 - progress) * 100);
                this.transitionPane.oldChildDiv.style.filter = "alpha(opacity=" + percent + ")";
            } else {
                this.transitionPane.oldChildDiv.style.opacity = 1 - progress;
            }
        }
    }
});

/**
 * Transition implementation to fade from old content to a solid color, then fade to new content.
 */
Extras.Sync.TransitionPane.FadeOpacityColorTransition = Core.extend(Extras.Sync.TransitionPane.Transition, {

    /** @see Extras.Sync.Animation#runTime */
    runTime: 1000,

    /**
     * The masking color DIV element being faded in/out over the changing content.
     * @type Element
     */
    _maskDiv: null,
    
    /**
     * Flag indicating whether old content has been fully faded out and swapped for new content.
     * @type Boolean
     */
    _swapped: false,
    
    /** @see Extras.Sync.Animation#complete */
    complete: function(abort) {
        this._maskDiv.parentNode.removeChild(this._maskDiv);
    },
    
    /** @see Extras.Sync.Animation#init */
    init: function() {
        this._maskDiv = document.createElement("div");
        this._maskDiv.style.cssText = "position:absolute;width:100%;height:100%;z-index:30000;";
        if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
            this._maskDiv.style.filter = "alpha(opacity=0)";
        } else {
            this._maskDiv.style.opacity = 0;
        }
        if (this.transitionPane.type === Extras.TransitionPane.TYPE_FADE_TO_WHITE) {
            this._maskDiv.style.backgroundColor = "#ffffff";
        } else {
            this._maskDiv.style.backgroundColor = "#000000";
        }
        this.transitionPane.contentDiv.appendChild(this._maskDiv);
    },

    /** @see Extras.Sync.Animation#step */
    step: function(progress) {
        var opacity = 1 - Math.abs(progress * 2 - 1);
        if (progress > 0.5 && !this._swapped) {
            this.transitionPane.showContent();
            this.transitionPane.removeOldContent();
            this._swapped = true;
        }
        if (Core.Web.Env.PROPRIETARY_IE_OPACITY_FILTER_REQUIRED) {
            var percent = Math.floor(opacity * 100);
            this._maskDiv.style.filter = "alpha(opacity=" + percent + ")";
        } else {
            this._maskDiv.style.opacity = opacity;
        }
    }
});
Extras.Sync.CalendarSelect.resource.set("de", {
    "DayOfWeek.0":      "Sonntag",
    "DayOfWeek.1":      "Montag",
    "DayOfWeek.2":      "Dienstag",
    "DayOfWeek.3":      "Mittwoch",
    "DayOfWeek.4":      "Donnerstag",
    "DayOfWeek.5":      "Freitag",
    "DayOfWeek.6":      "Samstag",
    "Month.0":          "Januar",
    "Month.1":          "Februar",
    "Month.2":          "M\u00e4rz",
    "Month.3":          "April",
    "Month.4":          "Mai",
    "Month.5":          "Juni",
    "Month.6":          "Juli",
    "Month.7":          "August",
    "Month.8":          "September",
    "Month.10":         "November",
    "Month.11":         "Dezember",
    "FirstDayOfWeek":   "1"
});
Extras.Sync.RichTextArea.resource.set("de", {
    "ColorDialog.Title.Foreground" : "Textfarbe",
    "ColorDialog.Title.Background" : "Hintergrundfarbe",
    "ColorDialog.PromptForeground" : "Textfarbe:",
    "ColorDialog.PromptBackground" : "Hintergrundfarbe:",
    "Error.ClipboardAccessDisabled" : "Der Zugriff auf die Zwischenablage ist in diesem Browser deaktiviert. " +
            "Bitte benutzen Sie die entsprechenden Tastenkombinationen oder \u00e4ndern Sie die " +
            "Sicherheitseinstellungen des Browsers.",
    "Generic.Cancel" : "Abbrechen",
    "Generic.Error" : "Fehler",
    "Generic.Ok" : "Ok",
    "HyperlinkDialog.Title" : "Hyperlink einf\u00fcgen",
    "HyperlinkDialog.PromptURL" : "URL:",
    "HyperlinkDialog.PromptDescription" : "Beschreibung:",
    "HyperlinkDialog.ErrorDialogTitle" : "Hyperlink konnte nicht eingef\u00fcgt werden",
    "HyperlinkDialog.ErrorDialog.URL" : "Die eingegebene URL ist nicht g\u00fcltig.",
    "ImageDialog.Title" : "Bild einf\u00fcgen",
    "ImageDialog.PromptURL" : "URL:",
    "ImageDialog.ErrorDialogTitle" : "Bild konnte nicht eingef\u00fcgt werden",
    "ImageDialog.ErrorDialog.URL" : "Die eingegebene URL ist nicht g\u00fcltig.",
    "Menu.Edit" : "Bearbeiten",
    "Menu.Undo" : "R\u00fcckg\u00e4ngig",
    "Menu.Redo" : "Wiederherstellen",
    "Menu.Cut" : "Ausschneiden",
    "Menu.Copy" : "Kopie",
    "Menu.Paste" : "Einf\u00fcgen",
    "Menu.Delete" : "L\u00f6schen",
    "Menu.SelectAll" : "Alles ausw\u00e4hlen",
    "Menu.Insert" : "Einf\u00fcgen",
    "Menu.InsertImage" : "Bild...",
    "Menu.InsertHyperlink" : "Hyperlink...",
    "Menu.InsertHorizontalRule" : "Trennstrich",
    "Menu.InsertTable" : "Tabelle...",
    "Menu.BulletedList" : "Aufz\u00e4hlung (symbolisch)",
    "Menu.NumberedList" : "Aufz\u00e4hlung (numeriert)",
    "Menu.Format" : "Format",
    "Menu.Bold" : "Fett",
    "Menu.Italic" : "Kursiv",
    "Menu.Underline" : "Unterstrichen",
    "Menu.Strikethrough" : "Durchgestrichen",
    "Menu.Superscript" : "Hochgestellt",
    "Menu.Subscript" : "Tiefgestellt",
    "Menu.PlainText" : "Einfacher Text",
    "Menu.TextStyle" : "Textstil",
    "Menu.ParagraphStyle" : "Absatzstil",
    "Menu.Alignment" : "Ausrichtung",
    "Menu.Left" : "Linksb\u00fcndig",
    "Menu.Right" : "Rechtsb\u00fcndig",
    "Menu.Center" : "Zentriert",
    "Menu.Justified" : "Blocksatz",
    "Menu.Indent" : "Einr\u00fccken",
    "Menu.Outdent" : "Ausr\u00fccken",
    "Menu.SetForeground" : "Textfarbe setzen...",
    "Menu.SetBackground" : "Hintergrundfarbe setzen...",
    "Menu.Heading1" : "\u00dcberschrift 1",
    "Menu.Heading2" : "\u00dcberschrift 2",
    "Menu.Heading3" : "\u00dcberschrift 3",
    "Menu.Heading4" : "\u00dcberschrift 4",
    "Menu.Heading5" : "\u00dcberschrift 5",
    "Menu.Heading6" : "\u00dcberschrift 6",
    "Menu.Normal" : "Normal",
    "Menu.Preformatted" : "Formatiert",
    "TableDialog.Title" : "Tabelle einf\u00fcgen",
    "TableDialog.PromptRows" : "Zeilen:",
    "TableDialog.PromptColumns" : "Spalten:",
    "TableDialog.ErrorDialogTitle" : "Tabelle konnte nicht eingef\u00fcgt werden",
    "TableDialog.ErrorDialog.Columns" : "Die Anzahl der Spalten ist nicht g\u00fcltig. " +
            "Bitte geben Sie eine Zahl zwischen 1 und 50 ein.",
    "TableDialog.ErrorDialog.Rows" : "Die Anzahl der Zeilen ist nicht g\u00fcltig. " +
            "Bitte geben Sie eine Zahl zwischen 1 und 50 ein."
});
